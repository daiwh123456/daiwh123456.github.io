{"meta":{"title":"I flourish in the killing value, just like in the dawn","subtitle":"","description":"","author":"SuperLv","url":"http://example.com","root":"/"},"pages":[{"title":"","date":"2021-07-31T01:41:59.528Z","updated":"2021-07-31T01:41:59.527Z","comments":true,"path":"manifest.json","permalink":"http://example.com/manifest.json","excerpt":"","text":"{\"name\":\"string\",\"short_name\":\"Junzhou\",\"theme_color\":\"#49b1f5\",\"background_color\":\"#49b1f5\",\"display\":\"standalone\",\"scope\":\"/\",\"start_url\":\"/\",\"icons\":[{\"src\":\"images/pwaicons/36.png\",\"sizes\":\"36x36\",\"type\":\"image/png\"},{\"src\":\"images/pwaicons/48.png\",\"sizes\":\"48x48\",\"type\":\"image/png\"},{\"src\":\"images/pwaicons/72.png\",\"sizes\":\"72x72\",\"type\":\"image/png\"},{\"src\":\"images/pwaicons/96.png\",\"sizes\":\"96x96\",\"type\":\"image/png\"},{\"src\":\"images/pwaicons/144.png\",\"sizes\":\"144x144\",\"type\":\"image/png\"},{\"src\":\"images/pwaicons/192.png\",\"sizes\":\"192x192\",\"type\":\"image/png\"},{\"src\":\"images/pwaicons/512.png\",\"sizes\":\"512x512\",\"type\":\"image/png\"}],\"splash_pages\":null}"},{"title":"404 Not Found：该页无法显示","date":"2021-07-12T08:00:25.901Z","updated":"2021-07-12T08:00:25.901Z","comments":false,"path":"/404.html","permalink":"http://example.com/404.html","excerpt":"","text":""},{"title":"关于","date":"2021-07-12T08:00:25.905Z","updated":"2021-07-12T08:00:25.905Z","comments":false,"path":"about/index.html","permalink":"http://example.com/about/index.html","excerpt":"","text":"个人详细介绍"},{"title":"书单","date":"2021-07-12T08:00:25.905Z","updated":"2021-07-12T08:00:25.905Z","comments":false,"path":"books/index.html","permalink":"http://example.com/books/index.html","excerpt":"","text":""},{"title":"categories","date":"2021-07-30T13:16:36.000Z","updated":"2021-07-30T13:16:36.999Z","comments":true,"path":"categories/index-1.html","permalink":"http://example.com/categories/index-1.html","excerpt":"","text":""},{"title":"分类","date":"2021-07-30T13:17:11.247Z","updated":"2021-07-30T13:17:11.247Z","comments":false,"path":"categories/index.html","permalink":"http://example.com/categories/index.html","excerpt":"","text":""},{"title":"link","date":"2021-07-30T13:17:28.000Z","updated":"2021-07-30T13:17:48.294Z","comments":true,"path":"link/index.html","permalink":"http://example.com/link/index.html","excerpt":"","text":""},{"title":"友情链接","date":"2021-07-12T08:00:25.907Z","updated":"2021-07-12T08:00:25.907Z","comments":true,"path":"links/index.html","permalink":"http://example.com/links/index.html","excerpt":"","text":""},{"title":"Repositories","date":"2021-07-12T08:00:25.908Z","updated":"2021-07-12T08:00:25.908Z","comments":false,"path":"repository/index.html","permalink":"http://example.com/repository/index.html","excerpt":"","text":""},{"title":"tags","date":"2021-07-30T13:15:06.000Z","updated":"2021-07-30T13:15:06.376Z","comments":true,"path":"tags/index-1.html","permalink":"http://example.com/tags/index-1.html","excerpt":"","text":""},{"title":"标签","date":"2021-07-30T13:16:20.384Z","updated":"2021-07-30T13:16:20.384Z","comments":false,"path":"tags/index.html","permalink":"http://example.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"集合框架(二)","slug":"set-list-map2","date":"2021-07-31T08:30:19.000Z","updated":"2021-07-31T09:44:02.281Z","comments":true,"path":"2021/07/31/set-list-map2/","link":"","permalink":"http://example.com/2021/07/31/set-list-map2/","excerpt":"","text":"集合框架 就是内存中的”容器对象” - 存储数据的.开发中来替代数组的使用. 结构123456789101112131415api:java.util Collection[I] - List[I] - 有序可重复 - ArrayList[C] - LinkedList[C] - Vector[C] - Set[I] - 无序不可重复 - HashSet[C] - SortedSet[I] - TreeSet[C]Map[I] - HashMap[C] - key-value的形式存储数据的,针对key是无序不可重复. - Hashtable[C] - Properteis[C] - 属性文件在内存中的映射的对象 Collection[I] boolean add(E e);//向容器中添加一个元素 void clear();//清空容器 boolean contains(Object o);//判断容器中是否包含某个对象 boolean isEmpty();//如果集合中没有数据,集合大小为0,返回true Iterator iterator();// 获取集合对象的迭代器 boolean remove(Object obj);//删除集合容器中第一次出现的这个对象.只能删除1个 int size();//返回集合中的数据的个数 - 集合的大小 List[I] 特点 - 有序并且是可以重复的. E get(int index);//根据下标去取.集合下标边界[0,集合.size()-1] int indexOf(Object obj);//返回此列表中指定元素的第一次出现的索引，如果此列表不包含元素，则返回-1。 E remove(int index);//根据下标删除,并且返回刚刚删除的那个元素 Object[] toArray();//将集合转换成数组. ArrayList[C] 特点:有序可重复的,底层数据结构就是一个”动态增长”的数组. 优点:因为数组是一个有序的序列,所以它可以通过下标直接取值 - 查询效率高. 缺点:增删效率会低.因为涉及到下标的移动. 分析源码123456789101112131415161718192021222324252627282930 /** * 默认的初始的容量 */private static final int DEFAULT_CAPACITY = 10;/** * Shared empty array instance used for default sized empty instances. We * distinguish this from EMPTY_ELEMENTDATA to know how much to inflate when * first element is added. */private static final Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = &#123;&#125;;//就是真正的存储数据的数组transient Object[] elementData; /** * The size of the ArrayList (the number of elements it contains). * * @serial */private int size;//构造public ArrayList() &#123; //1. 初始化elementData,长度为0 //2. 是为了后面的ensureCapacityInternal方法中判断是否是第一次调用add方法 this.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA; //this.elementData = &#123;&#125;&#125; 剖析add方法 ArrayList扩容的原理 12345public boolean add(E e) &#123;ensureCapacityInternal(size + 1); // Increments modCount!!elementData[size++] = e;return true;&#125; 扩容方法 123456789private void ensureCapacityInternal(int minCapacity) &#123; //第一次进来1if (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123; //true//第一次minCapacity = 10minCapacity = Math.max(DEFAULT_CAPACITY, minCapacity);&#125;ensureExplicitCapacity(minCapacity);&#125; 继续ensureExplicitCapacity(minCapacity); 12345678private void ensureExplicitCapacity(int minCapacity) &#123;modCount++;// overflow-conscious code//第一次进来10-0&gt;0if (minCapacity - elementData.length &gt; 0)grow(minCapacity);&#125; grow(minCapacity) 123456789101112131415private void grow(int minCapacity) &#123;// 第一次//oldCapacity = 0//newCapacity = 0int oldCapacity = elementData.length;int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1); //1.5倍if (newCapacity - minCapacity &lt; 0)//第一次会进来newCapacity = minCapacity;//newCapacity = 10if (newCapacity - MAX_ARRAY_SIZE &gt; 0)newCapacity = hugeCapacity(minCapacity);// minCapacity is usually close to size, so this is a win://第一次执行add方法的时候,底层会给我们初始化了一个长度为10的Object[]数组elementData = Arrays.copyOf(elementData, newCapacity);&#125; 集合的遍历 直接输出 增强for循环 - 只读 123456789101112131415161718192021222324252627282930//只读的循环.如果在循环的过程中进行了remove操作 //抛出java.util.ConcurrentModificationException并发修改异常//实际的底层,调用迭代器对象中的next方法private class Itr implements Iterator&lt;E&gt; &#123; int cursor; // index of next element to return int lastRet = -1; // index of last element returned; -1 if no such int expectedModCount = modCount; public E next() &#123; checkForComodification(); //.... &#125; final void checkForComodification() &#123; //modCount是当初调用add方法,添加1个元素,modCount自增1个 if (modCount != expectedModCount) throw new ConcurrentModificationException(); &#125;&#125;发现只要调用了remove方法 - modCount++ private void fastRemove(int index) &#123; modCount++; int numMoved = size - index - 1; if (numMoved &gt; 0) System.arraycopy(elementData, index+1, elementData, index, numMoved); elementData[--size] = null; // clear to let GC do its work&#125; 普通for 迭代器 因为不同的集合的底层的数据结构是不一样的.数据结构不一样,它的遍历方式不一样 为了访问/遍历不同数据结构的集合提供一种统一的遍历方式 1234567 //1. 获取集合的迭代器Iterator&lt;Long&gt; iter = list.iterator();//2. 调用hasNext方法while(iter.hasNext())&#123; //判断迭代器中是否仍有下一个元素可被迭代 Long p = iter.next(); //获取当前迭代的 System.out.println(p);&#125; jdk8提供的新的遍历方式 1234567891011121314list.forEach(new Consumer&lt;Long&gt;() &#123; //匿名内部类 @Override public void accept(Long aLong) &#123; System.out.println(aLong); &#125;&#125;); //lambda表达式来替代匿名内部类的写法//配合函数式接口[只能包含【一个】抽象方法]System.out.println(&quot;======lambda====&quot;);list.forEach(e -&gt; System.out.println(e)); System.out.println(&quot;========&quot;);list.forEach(System.out::println); LinkedList[C] 有序的序列,底层的数据结构双向链表,jdk6以及之前是双向循环链表 链表结构的特点:查询效率很低,每次都会从头节点开始遍历.但是增删效率高,只会涉及到相邻节点的移动. 适合解决栈列和队列的业务题型 - 贪吃蛇 栈列 - 先进后出 队列 - 先进先出 链表结构 相对于数组这种数据结构,需要占用更多的内存.每个节点除了保存具体的数据,还需要保存相邻节点的地址. 单向链表 head - 头节点 tail - 尾节点 element - 节点中真正的保存的数据 next - 下一个节点的地址 单向循环链表 尾节点的next又指向了头节点. 双向链表 - LinkedList底层数据结构 增加了一个pre - 保存的是上一个节点的地址. 双向循环链表 剖析源码1234567891011121314151617181920212223242526272829303132333435363738394041//Node代表的是链表的节点 private static class Node&lt;E&gt; &#123; E item;//真正的元素 Node&lt;E&gt; next; //下一个节点的地址 Node&lt;E&gt; prev; //上一个节点的地址 Node(Node&lt;E&gt; prev, E element, Node&lt;E&gt; next) &#123; this.item = element; this.next = next; this.prev = prev; &#125; &#125;//双向链表如何插入一个新的节点public boolean add(E e) &#123; linkLast(e); return true;&#125;void linkLast(E e) &#123; //第【一】次进入last最后一个节点Node - null final Node&lt;E&gt; l = last;//l = null //第二次进入 l = new Node&lt;&gt;(null,&quot;ok&quot;,null) //第【一】次进入 //newNode = new Node&lt;&gt;(null,&quot;ok&quot;,null) //第二次进入 //newNode = new Node&lt;&gt;(链表中原来的最后一个节点l, &quot;java&quot;, null); final Node&lt;E&gt; newNode = new Node&lt;&gt;(l, e, null); //新插入的节点肯定是作为最后一个节点 - 尾节点 last = newNode; if (l == null) //第【一】次进入,链表之前没有任何元素 first = newNode; //新的节点作为头节点 else l.next = newNode; //原来链表中的最后一个节点的next同时也指向新的节点 size++; modCount++;&#125; 查找源码 1234567891011121314151617181920212223 public E get(int index) &#123; checkElementIndex(index); return node(index).item; &#125;Node&lt;E&gt; node(int index) &#123; //index = 3 // 假设集合中有10个元素 = size = 10 //index&lt;5 - 链表的坐标 if (index &lt; (size &gt;&gt; 1)) &#123; Node&lt;E&gt; x = first;//确定头节点 for (int i = 0; i &lt; index; i++) x = x.next; //① - x第二个 ,i=0 //i=1 x第三个 //i=2 x第四个 return x; &#125; else &#123;//index&gt;=5 Node&lt;E&gt; x = last; for (int i = size - 1; i &gt; index; i--) x = x.prev; return x; &#125;&#125; 删除源码 12345678910111213141516171819202122232425262728293031 public E remove(int index) &#123; checkElementIndex(index); //找到index对应的Node对象,传入到了unlink方法中. return unlink(node(index)); &#125;E unlink(Node&lt;E&gt; x) &#123; // assert x != null; final E element = x.item; final Node&lt;E&gt; next = x.next; final Node&lt;E&gt; prev = x.prev; if (prev == null) &#123; //防止删除的是头节点 first = next; //需要删除的那个节点的下一个节点作为头节点了. &#125; else &#123; //删除的是中间节点 prev.next = next; //原来节点的上一个节点的next指向原来节点的下一个节点 x.prev = null; //优化,更快让GC会回收pre指针. &#125; if (next == null) &#123; //删除的是尾结点 last = prev; //原来节点的上一个节点作为尾节点 &#125; else &#123; //删除的是中间节点 next.prev = prev; //原来节点的下一个节点指向原来节点的上一个节点 x.next = null; &#125; x.item = null; size--; modCount++; return element;&#125; 练习-括号匹配 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950package stu.aistar.day11.homework;import java.util.LinkedList;import java.util.Scanner;/** * 本类用来演示: 括号匹配 */public class BracketsDemo &#123; public static void main(String[] args) &#123; Scanner sc = new Scanner(System.in); System.out.print(&quot;输入括号: &gt;&quot;); String line = sc.nextLine(); if(matches(line))&#123; //isEmpty() 返回true System.out.println(&quot;匹配&quot;); &#125;else&#123; System.out.println(&quot;不匹配&quot;); &#125; &#125; private static boolean matches(String line) &#123; //1. 将字符串转成字符数组 char[] arr = line.toCharArray(); //2. 新建一个LinkedList集合 LinkedList&lt;Character&gt; list = new LinkedList&lt;&gt;(); //3. 将数组中的第一个元素压入栈顶 list.push(arr[0]); //4. 从arr数组的第二个位置开始遍历 for (int i = 1; i &lt; arr.length; i++) &#123; //()[]&#123;&#125; Character c = arr[i]; //获取当前的arr[i] if(list.isEmpty())&#123; //为了避免在栈顶已经没有元素的情况下还去获取 list.push(c); //栈顶元素,非空判断 continue; &#125; Character top = list.getFirst(); //5. 先获取栈顶元素 //6. 栈顶元素和当前的arr[i]进行匹配 if(top.equals(&#x27;(&#x27;)&amp;&amp;c.equals(&#x27;)&#x27;) || top.equals(&#x27;&#123;&#x27;)&amp;&amp;c.equals(&#x27;&#125;&#x27;) || top.equals(&#x27;[&#x27;)&amp;&amp;c.equals(&#x27;]&#x27;))&#123; list.pop(); //弹出栈顶元素 &#125;else&#123; list.push(c); //继续将当前的arr[i]压入栈顶 &#125; &#125; return list.isEmpty(); &#125;&#125; Map[I]HashMap[C] 数据存储的形式是key-value,针对key是无序不可重复的. jdk8.x之前,底层的数据结构是桶数组+链表 jd8.0开始,底层的数据结构是桶数组+链表+红黑树 桶(哈希桶)数组 - 里面的元素放在数组的这个位置是通过一个哈希算法计算得到的. 图示 剖析put方法123456789101112131415161718192021222324public V put(K key, V value) &#123; return putVal(hash(key), key, value, false, true);&#125;//hash函数就是扰动函数//1. 尽可能减少哈希冲突static final int hash(Object key) &#123; int h; return (key == null) ? 0 : (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16);&#125;//map数据结构图示中每个节点static class Node&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; &#123; final int hash; final K key; V value; Node&lt;K,V&gt; next;//单向链表 Node(int hash, K key, V value, Node&lt;K,V&gt; next) &#123; this.hash = hash; this.key = key; this.value = value; this.next = next; &#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566transient Node&lt;K,V&gt;[] table;//默认值是null//hash(key)final V putVal(int hash, K key, V value, boolean onlyIfAbsent, boolean evict) &#123; //第一次进来 Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; int n, i; //第一次进来,第二次肯定不走 if ((tab = table) == null || (n = tab.length) == 0) //第一次肯定会进来 //1. 对tab进行一个初始化操作 //2. 得到初始化数组的长度,赋值给了n n = (tab = resize()).length;//n=16 //第一次肯定判断结果为null if ((p = tab[i = (n - 1) &amp; hash]) == null) //tab[i] = 新的节点 tab[i] = newNode(hash, key, value, null); else &#123; //哈希碰撞了,哈希冲突了. Node&lt;K,V&gt; e; K k; if (p.hash == hash &amp;&amp; ((k = p.key) == key || (key != null &amp;&amp; key.equals(k)))) //key值冲突了. //e = 数组中的旧的Node对象 e = p; //hash虽然碰撞了,但是key是不一样 else if (p instanceof TreeNode)//判断是否为红黑树结构 //当链表的节点&gt;8个,链表结构转成红黑树结构 //当红黑树节点&lt;6个,恢复成链表结构 e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(this, tab, hash, key, value); else &#123;//链表结构 for (int binCount = 0; ; ++binCount) &#123; //p代表的就是哈希碰撞位置的第一个Node对象 if ((e = p.next) == null) &#123;//新的节点挂载到链表的末尾 p.next = newNode(hash, key, value, null); if (binCount &gt;= TREEIFY_THRESHOLD - 1) // -1 for 1st treeifyBin(tab, hash); break; &#125; //新的节点可能和链表结构中的某个节点的key也是一样的 if (e.hash == hash &amp;&amp; ((k = e.key) == key || (key != null &amp;&amp; key.equals(k)))) break; //e肯定是不为null p = e; &#125; &#125; if (e != null) &#123; // existing mapping for key //把旧的节点的value赋值给了oldValue,put方法的返回结果 V oldValue = e.value; if (!onlyIfAbsent || oldValue == null) //新值覆盖旧值 e.value = value; afterNodeAccess(e); return oldValue; &#125; &#125; ++modCount; if (++size &gt; threshold) resize(); afterNodeInsertion(evict); return null;&#125; 扩容方法 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576final Node&lt;K,V&gt;[] resize() &#123; Node&lt;K,V&gt;[] oldTab = table; int oldCap = (oldTab == null) ? 0 : oldTab.length; int oldThr = threshold; int newCap, newThr = 0; if (oldCap &gt; 0) &#123; if (oldCap &gt;= MAXIMUM_CAPACITY) &#123; threshold = Integer.MAX_VALUE; return oldTab; &#125; else if ((newCap = oldCap &lt;&lt; 1) &lt; MAXIMUM_CAPACITY &amp;&amp; oldCap &gt;= DEFAULT_INITIAL_CAPACITY) newThr = oldThr &lt;&lt; 1; // double threshold &#125; else if (oldThr &gt; 0) // initial capacity was placed in threshold newCap = oldThr; else &#123; // zero initial threshold signifies using defaults //第一进来就会执行到此处 , 16 //扩容因子是0.75 newCap = DEFAULT_INITIAL_CAPACITY; newThr = (int)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY); &#125; if (newThr == 0) &#123; float ft = (float)newCap * loadFactor; newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (float)MAXIMUM_CAPACITY ? (int)ft : Integer.MAX_VALUE); &#125; threshold = newThr; //初始化一个长度为16的数组 @SuppressWarnings(&#123;&quot;rawtypes&quot;,&quot;unchecked&quot;&#125;) Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])new Node[newCap]; table = newTab; if (oldTab != null) &#123; for (int j = 0; j &lt; oldCap; ++j) &#123; Node&lt;K,V&gt; e; if ((e = oldTab[j]) != null) &#123; oldTab[j] = null; if (e.next == null) newTab[e.hash &amp; (newCap - 1)] = e; else if (e instanceof TreeNode) ((TreeNode&lt;K,V&gt;)e).split(this, newTab, j, oldCap); else &#123; // preserve order Node&lt;K,V&gt; loHead = null, loTail = null; Node&lt;K,V&gt; hiHead = null, hiTail = null; Node&lt;K,V&gt; next; do &#123; next = e.next; if ((e.hash &amp; oldCap) == 0) &#123; if (loTail == null) loHead = e; else loTail.next = e; loTail = e; &#125; else &#123; if (hiTail == null) hiHead = e; else hiTail.next = e; hiTail = e; &#125; &#125; while ((e = next) != null); if (loTail != null) &#123; loTail.next = null; newTab[j] = loHead; &#125; if (hiTail != null) &#123; hiTail.next = null; newTab[j + oldCap] = hiHead; &#125; &#125; &#125; &#125; &#125; return newTab; &#125; map集合的迭代方式123456789101112131415161718192021//第一种方式 - 将map集合中所有的key全部取出来放入到一个Set集合中.//set集合 - 无序不可重复,map集合的key也是无序不可重复.Set&lt;Integer&gt; sets = maps.keySet();//遍历set集合Iterator&lt;Integer&gt; iter = sets.iterator();while(iter.hasNext())&#123; Integer key = iter.next(); String value = maps.get(key); System.out.println(key+&quot;:&quot;+value);&#125;//第二种方式 - 将map集合中的每对key-value封装到了一个内置的Entry对象中//然后将每个entry对象放入到Set集合中Set&lt;Map.Entry&lt;Integer,String&gt;&gt; entries = maps.entrySet();Iterator&lt;Map.Entry&lt;Integer,String&gt;&gt; iter2 = entries.iterator();while(iter2.hasNext())&#123; Map.Entry&lt;Integer,String&gt; e = iter2.next(); Integer key = e.getKey(); String value = e.getValue(); System.out.println(key+&quot;-&gt;&quot;+value);&#125; Map作业123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475String str = &quot;python java python java mysql java mysql php&quot;; spilt(&quot;\\\\s&quot;)//统计 String[] arr = [&quot;python&quot;,&quot;java&quot;,&quot;python&quot;,&quot;java&quot;,&quot;php&quot;,&quot;python&quot;]; public static void main(String[] args) &#123; String[] arr = &#123;&quot;python&quot;,&quot;java&quot;,&quot;python&quot;,&quot;java&quot;,&quot;php&quot;,&quot;python&quot;&#125;; Map&lt;String,Integer&gt; maps = new HashMap&lt;&gt;(); for (int i = 0; i &lt; arr.length; i++) &#123; maps.put(arr[i],maps.get(arr[i])==null?1:maps.get(arr[i])+1); &#125; Set&lt;Map.Entry&lt;String, Integer&gt;&gt; entries = maps.entrySet(); //遍历 Iterator&lt;Map.Entry&lt;String, Integer&gt;&gt; it = entries.iterator(); while (it.hasNext())&#123; Map.Entry&lt;String, Integer&gt; e = it.next(); System.out.println(e.getKey()+&quot;:&quot;+e.getValue()); &#125;&#125;//统计 int[] arr = &#123;1,2,1,2,3,4,1,2,5,.....&#125;public class CalNumCount &#123; public static void main(String[] args) &#123; int[] arr = &#123;1,2,1,2,3,4,1,2,5,3,4,2,1,3&#125;; Map&lt;Integer,Integer&gt; maps = new HashMap&lt;&gt;(); for (int i = 0; i &lt; arr.length; i++) &#123; maps.put(arr[i],maps.get(arr[i])==null?1:maps.get(arr[i])+1); &#125; System.out.println(maps); &#125;&#125;//统计 String str = &quot;sfhdsfkdfdfjdfjdfdjfdsa&quot;;public class CountStrDemo &#123; public static void main(String[] args) &#123; String str = &quot;ahfdfjdkfjsdafsed&quot;; count(str); &#125; private static void count(String str) &#123; Map&lt;Character,Integer&gt; maps = new HashMap&lt;&gt;(); for (int i = 0; i &lt; str.length(); i++) &#123; //用增强for循环更方便 if (maps.containsKey(str.charAt(i)))&#123; Integer count = maps.get(str.charAt(i)); maps.put(str.charAt(i),count+1); &#125;else &#123; maps.put(str.charAt(i),1); &#125; &#125; //定义list集合 用来存放map中的数据，只有list集合有sort方法！ List&lt;Map.Entry&lt;Character,Integer&gt;&gt; list = new ArrayList&lt;&gt;(); Set&lt;Map.Entry&lt;Character, Integer&gt;&gt; entries = maps.entrySet(); Iterator&lt;Map.Entry&lt;Character, Integer&gt;&gt; it = entries.iterator(); while (it.hasNext())&#123; Map.Entry&lt;Character, Integer&gt; nt = it.next(); //把map里面的值 传给 list里面 list.add(nt); &#125; list.sort((o1,o2)-&gt;o2.getValue()-o1.getValue()); //遍历排好序的集合，完成了排序 for (Map.Entry&lt;Character, Integer&gt; characterIntegerEntry : list) &#123; System.out.println(characterIntegerEntry); &#125; &#125;&#125;//下面有一个分割的 map 和 list排序方法 一致//分割如下： String str = &quot;python java python java mysql java mysql php&quot;; String[] arr1 = str.split(&quot;\\\\s&quot;); // \\\\s 是空格 其他的符号就用 \\\\+符号 for (String s : arr1) &#123; System.out.print(s+&quot;\\t&quot;); &#125; 排序比较器接口Comparator jdk8.0开始,在List接口中已经定义了排序的方法 void sort(Comparator&lt;? super E&gt; c) 分析:java.util.Comparator[I]函数式接口 - 允许使用lambda表达式 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162package stu.aistar.day11;import stu.aistar.day10.Book;import java.util.ArrayList;import java.util.Comparator;import java.util.List;/** * 本类用来演示: 集合排序 */public class ListSortDemo &#123; public static void main(String[] args) &#123; Book b1 = new Book(1,&quot;1001&quot;,&quot;java&quot;,100.0d); Book b2 = new Book(2,&quot;1002&quot;,&quot;java&quot;,200.0d); Book b3 = new Book(3,&quot;1003&quot;,&quot;java&quot;,200.0d); Book b4 = new Book(4,&quot;1004&quot;,&quot;python&quot;,300.0d); List&lt;Book&gt; bookList = new ArrayList&lt;&gt;(); bookList.add(b1); bookList.add(b2); bookList.add(b3); bookList.add(b4);// bookList.sort(new Comparator&lt;Book&gt;() &#123;// @Override// public int compare(Book o1, Book o2) &#123;// if(o1.getPrice()&gt;o2.getPrice())// return -1;// else if(o1.getPrice()&lt;o2.getPrice())// return 1;// return 0;// &#125;// &#125;); //根据价格降序排// bookList.sort((o1,o2)-&gt;&#123;// if(o1.getPrice()&gt;o2.getPrice())// return -1;// else if(o1.getPrice()&lt;o2.getPrice())// return 1;// return 0;// &#125;); //根据编号降序排 - String类型// bookList.sort((o1, o2) -&gt; o2.getIsbn().compareTo(o1.getIsbn())); //根据价格降序排,如果价格一样的话,按照编号继续降序排 bookList.sort((o1,o2)-&gt;&#123; if(o1.getPrice()&gt;o2.getPrice()) return -1; else if(o1.getPrice()&lt;o2.getPrice()) return 1; return o2.getIsbn().compareTo(o1.getIsbn()); &#125;); for (Book book : bookList) &#123; System.out.println(book); &#125; &#125;&#125; 可比较接口 排序的对象对应的实体类实现java.lang.Comparable接口 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162package stu.aistar.day11.compares;/** * 本类用来演示: 可比较接口 */public class Teacher implements Comparable&lt;Teacher&gt;&#123; private int id; private String name; private int age; public Teacher() &#123; &#125; public Teacher(int id, String name, int age) &#123; this.id = id; this.name = name; this.age = age; &#125; public int getId() &#123; return id; &#125; public void setId(int id) &#123; this.id = id; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125; @Override public String toString() &#123; final StringBuilder sb = new StringBuilder(&quot;Teacher&#123;&quot;); sb.append(&quot;id=&quot;).append(id); sb.append(&quot;, name=&#x27;&quot;).append(name).append(&#x27;\\&#x27;&#x27;); sb.append(&quot;, age=&quot;).append(age); sb.append(&#x27;&#125;&#x27;); return sb.toString(); &#125; @Override public int compareTo(Teacher o) &#123; //定制排序的规则 return o.age - this.age; &#125;&#125; 123456789101112131415161718192021222324252627282930313233package stu.aistar.day11.compares;import java.util.ArrayList;import java.util.Collections;import java.util.List;/** * 本类用来演示: 在类中实现可比较接口，调用的时候用Collections.sort方法 */public class TestTeacherSort &#123; public static void main(String[] args) &#123; Teacher t1 = new Teacher(1,&quot;tom&quot;,23); Teacher t2 = new Teacher(2,&quot;jack&quot;,25); Teacher t3 = new Teacher(3,&quot;james&quot;,18); Teacher t4 = new Teacher(4,&quot;rose&quot;,17); List&lt;Teacher&gt; list = new ArrayList&lt;&gt;(); list.add(t1); list.add(t2); list.add(t3); list.add(t4); //for (Teacher teacher : list) &#123; //为了查看排序之前 // System.out.println(teacher); //&#125; Collections.sort(list); //调用可比较接口 for (Teacher teacher : list) &#123; System.out.println(teacher); &#125; &#125;&#125; Collections java.util.Collections[C] - 集合工具类 面试题 - Collection和Collections有什么区别? static void sort(List list, Comparator&lt;? super T&gt; c)根据指定的比较器引起的顺序对指定的列表进行排序。 12Collections.sort(bookList,((o1, o2) -&gt; (int) (o2.getPrice()-o1.getPrice())));Collections.sort() //有两种方法 这是第一种 static &lt;T extends Comparable&lt;? super T&gt;&gt; void sort(List list) ; //集合中的对象必须要实现java.lang.Comparable可比较接口 - 第二种 HashSet Set[I]接口下的实现类 - 存储的数据是无序不可重复复的. 添加数据到容器的原理: 当把对象添加到容器中之前,会调用对象的hashCode方法,得到一个哈希值. 如果这个哈希值在这之前没有出现过,说明这个位置没有被占用,那么就可以直接将这个对象放入到这个容器中的这个位置 如果这个哈希值在这之前出现过了.产生了哈希碰撞或者哈希冲突.但是这个时候,还不能确定哈希碰撞的俩个对象是同一个对象 继续调用对象的equals方法,如果返回true,说明是同一个对象.则拒绝添加. 底层数据结构 散列表 桶数组 + 链表 + 红黑树 查看HashSet源码 Set sets = new HashSet&lt;&gt;(); 1234public HashSet() &#123;//HashSet的底层是HashMapmap = new HashMap&lt;&gt;();&#125; HashSet的add方法的底层 123456789private static final Object PRESENT = new Object();//此处的e是添加到容器中的对象public boolean add(E e) &#123;//实际上还是在调用map的put方法//HashSet中添加的对象是作为了Map集合的key//Map的key具有什么特点 = HashSet中的数据有何特点.return map.put(e, PRESENT)==null;&#125;","categories":[{"name":"集合框架","slug":"集合框架","permalink":"http://example.com/categories/%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/"}],"tags":[{"name":"java","slug":"java","permalink":"http://example.com/tags/java/"}]},{"title":"集合框架(一)","slug":"set-list-map","date":"2021-07-31T08:13:36.000Z","updated":"2021-07-31T10:01:52.339Z","comments":true,"path":"2021/07/31/set-list-map/","link":"","permalink":"http://example.com/2021/07/31/set-list-map/","excerpt":"","text":"包装类型 每个基本类型都有其对应的包装类型[对象类型] byte-&gt;Byte short-&gt;Short int-&gt;Integer long-&gt;Long float-&gt;Float double-&gt;Double char-&gt;Character boolean-&gt;Boolean 学习掌握目标 包装类型的api的常用方法 包装类型和基本数据类型以及String类型三者之间的相互转换问题. Number api:java.lang包,所有关于上面包装类型[数字]的共同的抽象的父类. byte byteValue()返回指定号码作为值 byte ，这可能涉及舍入或截断。 abstract double doubleValue()返回指定数字的值为 double ，可能涉及四舍五入。 abstract float floatValue()返回指定数字的值为 float ，可能涉及四舍五入。 abstract int intValue()返回指定号码作为值 int ，这可能涉及舍入或截断。 abstract long longValue()返回指定数字的值为 long ，可能涉及四舍五入或截断。 short shortValue()返回指定号码作为值 short ，这可能涉及舍入或截断。 提供的这些方法都是关于包装类型转换成对应的基本类型的方法 Integer构造 Integer(int i); //利用int类型的整数来构建一个Integer对象 - int类型 -&gt; Integer类型 Integer(String s); //此处的字符串一定是数字形式的字符串 - String类型 -&gt; Integer类型 如果传入的是一个非数字形式的字符串,那么会抛出java.lang.NumberFormatException数字格式化失败异常 自动解封箱 jdk5.x开始支持的新的功能 封箱 - 基本数据类型可以自动转换成对应的包装类型 解箱 - 包装类型可以自动转换成对应的基本的数据类型 常用方法 static Integer valueOf(int i);//将int-&gt;Integer 1[-128,127] -&gt; 比较的结果是true,不在这个范围的是返回false !!! 12345678910111213141516171819202122//如果[-128,127]之间,那么直接返回内部的 [缓冲数] 组中的数据//如果不在这个范围,返回一个新的Integer对象public static Integer valueOf(int i) &#123; //缓冲区的底层代码 if (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high) return IntegerCache.cache[i + (-IntegerCache.low)]; return new Integer(i);&#125;private static class IntegerCache &#123; //Integer类内部有一个静态内部类 static final int low = -128; static final int high; //缓冲区,提供了缓冲的数组,数组在静态代码块中进行预初始化,提前赋值了. static final Integer cache[]; static&#123; cache = new Integer[(high - low) + 1]; int j = low; for(int k = 0; k &lt; cache.length; k++) cache[k] = new Integer(j++); &#125;&#125; 12345678910111213141516171819202122232425262728293031323334 // [-128,127] -&gt; 比较的结果是true,不在这个范围的是返回false !!!// 剖析自动封箱Integer a = 127; //Integer a = Integer.valueOf(127);Integer b = 127;System.out.println(a == b); //trueadmindeMacBook-Pro:Desktop admin$ javap -c IntegerHello Compiled from &quot;IntegerHello.java&quot;public class IntegerHello &#123; public IntegerHello(); Code: 0: aload_0 1: invokespecial #1 // Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V 4: return public static void main(java.lang.String[]); Code: 0: bipush 127 2: invokestatic #2 // Method java/lang/Integer.valueOf:(I)Ljava/lang/Integer; 5: astore_1 6: bipush 127 8: invokestatic #2 // Method java/lang/Integer.valueOf:(I)Ljava/lang/Integer; 11: astore_2 12: getstatic #3 // Field java/lang/System.out:Ljava/io/PrintStream; 15: aload_1 16: invokevirtual #4 // Method java/lang/Integer.intValue:()I 19: bipush 7 21: if_icmpne 28 24: iconst_1 25: goto 29 28: iconst_0 29: invokevirtual #5 // Method java/io/PrintStream.println:(Z)V 32: return&#125; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071package stu.aistar.day10;/** * 本类用于演示： 【笔数易错题】 */public class IntegerDemo &#123; public static void main(String[] args) &#123; Integer i = new Integer(&quot;10&quot;); //不可以是非数字的字符串 String -&gt; Integer //Integer -&gt; int Integer内部提供的【非静态】的方法 把Integer转换为Int int i1 = i.intValue(); int i2 = i; //Integer -&gt; int 自动拆箱 Integer j = new Integer(10); //int -&gt; integer System.out.println(j); System.out.println(i == j); //false 创建了两次 都在堆中 有不同的地址值 //封箱 - 基本数据类型可以自动转换成对应的包装类型 //[-128,127]-&gt;比较的结果是true,不在范围的返回false IntegerCache缓冲区属于静态内部类 Integer integer1 = 127; // -&gt; Integer a = Integer.valueOf(-128); Integer integer2 = 127; System.out.println(integer1 == integer2); //Integer中提供的静态方法 将int 转换为Integer类型 Integer x = Integer.valueOf(127); Integer y = Integer.valueOf(&quot;127&quot;); System.out.println(x == y); //true 只要不是new的都符合缓冲区的规则 //Integer -&gt; int Integer z = new Integer(10); //intValue() 是Integer类中的一个【非静态】的方法 (非静态需要通过对象进行调用) int n = z.intValue(); System.out.println(n); //基本类型和包装类型之间的比较 int t = 300; Integer t1 = new Integer(300); //返回值类型是Integer -&gt; int转换为Integer Integer t2 = Integer.valueOf(300); //返回值类型是Integer -&gt; int转换为Integer //当包装类型和基本类型进行比较的时候，包装类型调用调用intValue方法 - // - 转换成基本数据类型之后然后再和基本数据类型进行比较 System.out.println(t == t1); //true System.out.println(t == t2); //true System.out.println(t1 == t2); //false //进制转换 System.out.println(Integer.toBinaryString(10)); //二进制 System.out.println(Integer.toHexString(176)); //十六进制 //八进制 26/8余2 得3/8余3 反转 32 System.out.println(Integer.toOctalString(26)); //String -&gt; int Integer中提供的静态方法 将String转换为Int System.out.println(Integer.parseInt(&quot;10&quot;)); //String -&gt; Integer System.out.println(Integer.valueOf(&quot;100&quot;)); //Integer.valueOf() String -&gt; Integer //int 类型的范围 System.out.println(Integer.MAX_VALUE); System.out.println(Integer.MIN_VALUE); //Integer -&gt; String //String中提供的一个方法将Integer转换为String 任何事务都可以通过String.valueOf System.out.println(String.valueOf(10)); Integer s = new Integer(15); Integer s2 = new Integer(15); System.out.println(s==s2); &#125;&#125; 关于进制转换的方法 2-1. static String toBinaryString(int n); //十进制n转换成对应的二进制 2-2. static String toHexString(int n); //十进制n转换成对应的十六进制 2-3. static String toOctalString(int n); //十进制n转换成对应的八进制 static int parseInt(String s); //将数字形式的字符串转换成int类型,如果传入的是一个非数字形式的字符串,那么会抛出 java.lang.NumberFormatException数字格式化失败异常 static Integer valueOf(String s); //String-&gt;Integer 总结 包装类型和基本数据类型以及String类型三者之间的相互转换问题. int-&gt;Integer 1231. java.lang.Integer的构造Integer(int n)2. jdk5.0提供的自动封箱Integer a = 10;3. java.lang.Integer提供的static Integer valueOf(int n); Integer -&gt; int 12341. int intValue(); //java.lang.Number提供的抽象方法,java.lang.Integer重写了该方法2. jdk5.0提供的自动解箱 //intValue方法在Integer中, 所以他指的是一个Integer对象转换为int对象 ！ int-&gt;String 121. java.lang.String提供的方法static String valueOf(int n); //一切类型都可以通过String.valueOf方法进行转换为String类型 String-&gt;int 1231. java.lang.Integer类static int parseInt(String s); //parseInt(String) 是Integer里面的一个方法 (估计是传参时候才能用得到) // 转发 和 重定向 的时候！ int a = Integer.parseInt(&quot;1000&quot;); String-&gt;Integer 12341. java.lang.Integer的构造Integer(String n) //Integer i = new Integer(&quot;10&quot;); 就是创建Integer的时候 里面必须是数字型字符串2. java.lang.Integer的方法static Integer valueOf(String n); //Integer it = Integer.valueOf(&quot;128&quot;); Integer-&gt;String 121. java.lang.Integer的String toString();2. java.lang.String中提供了static String valueOf(Object obj); 作业1 笔试题:int和Integer之间的区别 Integer是int的包装类；int是基本数据类型； Integer变量必须实例化后才能使用；int变量不需要； Integer实际是对象的引用，指向此new的Integer对象；int是直接存储数据值 ； Integer的默认值是null；int的默认值是0。 泛型不支持int，但是支持Integer int 存储在栈中。Integer 对象的引用存储在栈空间中，对象的数据存储在堆空间中。 作业2 123456789101112131415161718192021222324252627282930313233343536public class Test &#123; public static void main(String[] args) &#123; Scanner scanner = new Scanner(System.in); int[] arr = new int[13]; System.out.println(&quot;请输入13位的校验码：&quot;); for (int i = 0; i &lt;13 ; i++) &#123; //存储校验码 arr[i] = scanner.nextInt(); &#125; int sum = 0; //计数器 for (int i = 0; i &lt; arr.length; i++) &#123; //计算偶数位之和 if (i%2 == 1)&#123; sum += arr[i]; &#125; &#125; System.out.println(&quot;偶数位上之和为：&quot;+sum); // 2 后面要×3 int sum1 = 0; //计数器 for (int i = 0; i &lt; arr.length-1; i++) &#123; //计算奇数位之和 除了最后一个 if (i%2 == 0)&#123; sum1 += arr[i]; &#125; &#125; System.out.println(&quot;奇数位之和为：&quot;+sum1); //×3的结果 加上sum1 int num = sum*3 + sum1; //记录 偶数成3 + 奇数 int num1 = 0; //记录大于等于num 且结果为10 的最小公倍数 for (int i = num; ; i++) &#123; if (i%10 == 0)&#123; num1 = i; break; &#125; &#125; System.out.println(&quot;大于等于num，且结果为10的最小公倍数的值num1为：&quot;+num1); System.out.println(&quot;最终的校验码X为：&quot;+(num1 - num)); &#125;&#125; Object java.lang.Object类是所有的类的基类,根类,超类 所有的类如果没有明确指定父类,都会默认继承Object类. equals boolean equals(Object obj); //对象之间的比较.默认仍然使用的是 == “业内认可的一种说法” - 基本类型用==比较的值 , 对象类型用==比较的是地址 123public boolean equals(Object obj) &#123; return (this == obj);&#125; 默认的比较方式不符合实际的业务需要,因此需要重写equals方法 success版本 12345678910111213141516171819202122 @Overridepublic boolean equals(Object obj)&#123; //1. 非空性 if(obj == null) return false; //2. 自反性 if(this == obj)//p1.equals(p1) return true; //3. 一致类型,判断具体的哪个属性是一致的,才认为返回true // p1.equals(user); if(obj instanceof Product)&#123; Product p = (Product) obj; //return this.id == p.id; //id和name都一致的时候,才认为是同一个对象 //return (this.id == p.id) &amp;&amp; (this.name.equals(p.name)); //需求 - 认为产品的id以及这个产品对应的产品信息的id一致的时候认为返回true return this.id == p.id &amp;&amp; this.getProductInfo().equals(p.productInfo); &#125; return false;&#125; hashCode方法 int hashCode(); //返回对象的哈希值.一般是和equals方法是【成对】出现的.目的是为了提高性能. 容器应用中 - 在什么时候才会去调用equals方法? - 当哈希碰撞的时候,只要哈希不冲突,不会调用equals方法 而调用equals方法执行的时机肯定会慢一点的.因为它需要比较属性值[需要更多的时间] 关于数字31 - 质数 - 1. 尽可能产生更多的哈希值 2. 让哈希碰撞/冲突尽可能少. 1234567@Overridepublic int hashCode() &#123; int result = id != null ? id.hashCode() : 0; result = 31 * result + (name != null ? name.hashCode() : 0); result = 31 * result + (productInfo != null ? productInfo.hashCode() : 0); return result;&#125; 超前知识点 1234567891011121314151617181920212223242526272829303132333435363738394041424344package stu.aistar.day10.hashcodes;import java.util.HashSet;import java.util.Set;/** * 本类用来演示: */public class TestCourse &#123; public static void main(String[] args) &#123; Course c1 = new Course(1,&quot;java&quot;); Course c2 = new Course(1,&quot;java&quot;); Course c3 = new Course(3,&quot;mysql&quot;); Course c4 = new Course(4,&quot;mysql&quot;); Course c5 = new Course(5,&quot;mysql&quot;); Course c6 = new Course(1,&quot;oracle&quot;); //System.out.println(c1 == c2); //false //System.out.println(c1.equals(c2)); //true //集合 - &quot;容器&quot;,比数组更加强大的. //集合 - 里面存储的数据是【无序不可重复】的 //不能存储同一个对象 Set&lt;Course&gt; sets = new HashSet&lt;&gt;(); //1. 当把某个对象放入到该容器之前,先调用了该对象的hashCode方法,得到一个哈希值 //2. 根据这个哈希值就可以被分配一个内存地址 //3. 如果这个哈希值在这之前没有出现过,说明这个位置没有被占用.那么就会直接将该对象放入到 // 这个哈希值对应的在容器中的那个位置 //4. 如果这个哈希值在这之前出现过.但是此时还不能说明这个对象和之前的那个对象是同一个对象 // 因为哈希值是通过哈希算法计算得到的,可能产生&quot;哈希冲突&quot; - &quot;哈希碰撞&quot; //5. 当哈希值一样的时候,那么才会去调用equals方法,如果equals方法仍然返回true,那么才 // 最终确定这个对象曾经出现过,那么就拒绝添加. sets.add(c1); sets.add(c2); //拒绝添加 hashcode一样 hashcode是自定义让他通过id计算的 sets.add(c3); sets.add(c4); sets.add(c5); sets.add(c6); //拒绝添加 for (Course c : sets) &#123; System.out.println(c); &#125; &#125;&#125; 总结 如果俩个对象的hashcode值一样,那么equals比较,不一定返回true 如果俩个对象equals返回true,那么这俩个对象的哈希值必须要一样(必须是hashcode一样才会来走equals) - 数据的完整性. 笔试题 == 和 equals的区别 == 基本类型使用,比较的就是基本类型的数值 equals 对象类型使用.如果某个类没有重写equals方法,那么调用的是java.lang.Object中的equals方法,这个时候仍然使用到的是==比较.如果重写了equals,就看equals提供的是哪些属性一致的时候,才返回true. clone方法 protected Object clone(); // 默认的克隆方法是浅克隆 浅克隆 浅拷贝,浅层复制,浅复制 - 默认的. protected - public 123456@Overridepublic Object clone() throws CloneNotSupportedException &#123;return super.clone();&#125;Object中的clone方法 - native修饰的方法 - 本地方法栈中的方法 - C写的 - Java语言本地调用C程序.protected native Object clone() throws CloneNotSupportedException; 只有实现了java.lang.Cloneable接口[标记接口]的对象才能够调用clone方法,否则会抛出java.lang.CloneNotSupportedException不支持克隆的异常. 123456Product copy = (Product) p1.clone();Product copy2 = new Product(1,&quot;mac&quot;,1000.0d);//为什么需要使用clone,而不直接new一个.//clone方法它直接操作的堆里面的内存 - 效率是高于重新new的. 1234567891011121314151617181920212223242526272829303132333435363738package stu.aistar.day10.obj;/** * 本类用来演示:浅拷贝 * 修改原来对象的基本数据类型以及字符串类型,都不会对副本对象产生影响 * 但是如果修改原来对象中的对象类型的属性值的话,会对副本对象产生影响 */public class TestCloneDemo &#123; public static void main(String[] args) &#123; Product p1 = new Product(1,&quot;mac&quot;,1000.0d); ProductInfo info = new ProductInfo(1,&quot;good&quot;); p1.setProductInfo(info); //System.out.println(p1 instanceof Cloneable);//true try &#123; //浅拷贝 Product copy = (Product) p1.clone(); //1. 修饰基本数据类型以及字符串 - 原来的对象 - 是否对copy对象产生影响 - 不会 p1.setId(10); p1.setName(&quot;tom&quot;); //2. 修改对象类型 - 会对copy的对象产生影响的 p1.getProductInfo().setId(100); p1.getProductInfo().setInfo(&quot;bad&quot;); System.out.println(copy); System.out.println(copy.getProductInfo()); //System.out.println(copy == p1);//false &#125; catch (CloneNotSupportedException e) &#123;//不能被克隆的异常 e.printStackTrace(); &#125; &#125;&#125; 深克隆 深层复制,深拷贝,深复制 - 需要【自己重写】clone里面的具体的代码的 123456789101112131415161718192021222324/** * 深拷贝 - 修改原来对象中的任何类型的数据都不会对副本对象产生影响 * @return * @throws CloneNotSupportedException */@Overridepublic Object clone() throws CloneNotSupportedException &#123; //Product copy = (Product)p1.clone(); //手动新建一个Product对象 Product product = new Product(); product.setId(id); product.setName(name); product.setPrice(price); ProductInfo infos = getProductInfo(); if(infos!=null)&#123; ProductInfo pi = new ProductInfo(); pi.setId(infos.getId()); pi.setInfo(infos.getInfo()); product.setProductInfo(pi); &#125; return product;&#125; 集合框架 就是内存中的”容器对象” - 存储数据的.开发中来替代数组的使用. 结构123456789101112131415api:java.util Collection[I] - List[I] - 【有序可重复】 - ArrayList[C] - LinkedList[C] - Vector[C] - Set[I] - 【无序不可重复】 - HashSet[C] - SortedSet[I] - TreeSet[C]Map[I] - HashMap[C] - 【key-value】的形式存储数据的,针对key是【无序不可重复】. - Hashtable[C] - Properteis[C] - 属性文件在内存中的映射的对象 Collection[I] boolean add(E e);//向容器中添加一个元素 void clear();//清空容器 boolean contains(Object o);//判断容器中是否包含某个对象 boolean isEmpty();//如果集合中没有数据,集合大小为0,返回true Iterator iterator();// 获取集合对象的迭代器 boolean remove(Object obj);//删除集合容器中第一次出现的这个对象.只能删除1个 int size();//返回集合中的数据的个数 - 集合的大小 List[I] 特点 - 有序并且是可以重复的. E get(int index); //根据下标去取.集合下标边界[0,集合.size()-1] int indexOf(Object obj); //返回此列表中指定元素的第一次出现的索引，如果此列表不包含元素，则返回-1。 E remove(int index); //根据下标删除,并且返回刚刚删除的那个元素 Object[] toArray(); //将集合转换成数组. ArrayList[C] 特点:有序可重复的,底层数据结构就是一个”动态增长”的数组. 优点:因为数组是一个有序的序列,所以它可以通过下标直接取值 - 查询效率高. 缺点:增删效率会低. 分析源码123456789101112131415161718192021222324252627282930 /** * 默认的初始的容量 */private static final int DEFAULT_CAPACITY = 10;/** * Shared empty array instance used for default sized empty instances. We * distinguish this from EMPTY_ELEMENTDATA to know how much to inflate when * first element is added. */private static final Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = &#123;&#125;;//就是真正的存储数据的数组transient Object[] elementData; /** * The size of the ArrayList (the number of elements it contains). * * @serial */private int size;//构造public ArrayList() &#123; //1. 初始化elementData,长度为0 //2. 是为了后面的ensureCapacityInternal方法中判断是否是第一次调用add方法 this.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA; //this.elementData = &#123;&#125; ↑&#125; 剖析add方法 ArrayList扩容的原理 12345public boolean add(E e) &#123;ensureCapacityInternal(size + 1); // Increments modCount!!elementData[size++] = e;return true;&#125; 扩容方法 12345678private void ensureCapacityInternal(int minCapacity) &#123; //第一次进来1if (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123; //true minCapacity = Math.max(DEFAULT_CAPACITY, minCapacity); //第一次minCapacity = 10&#125;ensureExplicitCapacity(minCapacity);&#125; 继续ensureExplicitCapacity(minCapacity); 12345678private void ensureExplicitCapacity(int minCapacity) &#123;modCount++;// overflow-conscious code//第一次进来10-0&gt;0if (minCapacity - elementData.length &gt; 0)grow(minCapacity);&#125; grow(minCapacity) 123456789101112131415private void grow(int minCapacity) &#123;// 第一次//oldCapacity = 0//newCapacity = 0int oldCapacity = elementData.length;int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1); //1.5倍if (newCapacity - minCapacity &lt; 0) //第一次会进来 newCapacity = minCapacity; //newCapacity = 10if (newCapacity - MAX_ARRAY_SIZE &gt; 0) newCapacity = hugeCapacity(minCapacity); // minCapacity is usually close to size, so this is a win://第一次执行add方法的时候,底层会给我们初始化了一个长度为10的Object[]数组elementData = Arrays.copyOf(elementData, newCapacity);&#125; 集合的遍历 直接输出 增强for循环 - 只读 1234567891011121314151617181920212223242526272829//只读的循环.如果在循环的过程中进行了remove操作 - // - 抛出java.util.ConcurrentModificationException并发修改异常//实际的底层,调用迭代器对象中的next方法private class Itr implements Iterator&lt;E&gt; &#123; int cursor; // index of next element to return int lastRet = -1; // index of last element returned; -1 if no such int expectedModCount = modCount; public E next() &#123; checkForComodification(); //.... &#125; final void checkForComodification() &#123; //modCount是当初调用add方法,添加1个元素,modCount自增1个 if (modCount != expectedModCount) throw new ConcurrentModificationException(); &#125;&#125;//发现只要调用了remove方法 - modCount++ private void fastRemove(int index) &#123; modCount++; int numMoved = size - index - 1; if (numMoved &gt; 0) System.arraycopy(elementData, index+1, elementData, index, numMoved); elementData[--size] = null; // clear to let GC do its work&#125;","categories":[{"name":"集合框架","slug":"集合框架","permalink":"http://example.com/categories/%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/"}],"tags":[{"name":"java","slug":"java","permalink":"http://example.com/tags/java/"}]},{"title":"String+StringBuilder","slug":"String","date":"2021-07-31T08:12:46.000Z","updated":"2021-07-31T10:08:45.044Z","comments":true,"path":"2021/07/31/String/","link":"","permalink":"http://example.com/2021/07/31/String/","excerpt":"","text":"java.lang.String Java中提供的处理字符串的类. 不可变的字符串 1234//定义到串池中的字符串(只可有一份，如果后面再定义一个&quot;abc&quot;,// - 则在串池中指向的是同一个字符串,而不会再去创建一个&quot;abc&quot;)String s = &quot;abc&quot;; s = &quot;eef&quot;; //ok,&quot;abc&quot;就变成了垃圾对象. 字符串本质上就是一个字符数组 12345678//final修饰的类不可被继承public final class String implements java.io.Serializable, Comparable&lt;String&gt;, CharSequence &#123; //维护的是不可变的字符数组 //String s = &quot;abc&quot;;//将&quot;abc&quot;打散,保存成value[]数组中. private final char value[]; &#125; 字符串构建的方式 通过new关键字来构建 12345//创建了几个对象?//1个或者2个//①通过new关键字在[堆]里面创建一个字符串对象&quot;abc&quot;//②[同时]在&quot;串池&quot;里面扔一个对象&quot;abc&quot;[前提是串池中之前不存在&quot;abc&quot;]String s1 = new String(&quot;abc&quot;); 直接通过”串池”/“字符串常量池”的方式来构建 12345678//创建了几个对象? //它会在&quot;串池&quot;中创建一个&quot;abc&quot;字符串对象,然后将地址给了s1String s1 = &quot;abc&quot;;//&quot;串池&quot;中的特点:优先先到串池中查找是否已经存在&quot;abc&quot;对象,[如果有直接返回地址]给s2//[否则]才会继续[创建新的字符串对象]String s2 = &quot;abc&quot;;System.out.println(s1 == s2);//true 关于字符串的拼接 字符串的拼接使用 + ,但是使用 + 的拼接效率非常低. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647package stu.aistar.day09;import java.util.Date;/** * 本类用来演示: 字符串拼接效率低 - (用时间来证明效率) */public class StringPlusDemo &#123; public static void main(String[] args) &#123; test02();//append - 方法进行字符串的拼接 test01();// + - 方法进行字符串的拼接 &#125; public static void test01()&#123; //在本类中定义静态方法 long t1 = System.currentTimeMillis(); //获取当前系统时间的毫秒数 String str = &quot;&quot;; for (int i = 0; i &lt; 100000; i++) &#123; str+=i; //str = str + i; &#125; long t2 = System.currentTimeMillis(); //+拼接过后的当前系统时间 System.out.println(&quot;str拼接时间:&quot;+(t2-t1)+&quot;ms&quot;); //得到拼接的时间 &#125; public static void test02()&#123; //java.lang.StringBuilder //创建StringBuilder对象,用来接收字符串的拼接 StringBuilder builder = new StringBuilder(); long t1 = System.currentTimeMillis(); //获取当前系统时间的毫秒数 for (int i = 0; i &lt; 100000; i++) &#123; builder.append(i); //拼接方式 &#125; long t2 = System.currentTimeMillis(); //append拼接过后的当前系统时间 System.out.println(&quot;append拼接时间:&quot;+(t2-t1)+&quot;ms&quot;); &#125;&#125;//测试结果+拼接所用的时间远远大于append拼接所用的时间-证明+拼接的效率低 反之append拼接的效率高！ 拼接效率的原因 +底层每次都会产生一个StringBuilder对象 +底层仍然是调用StringBuilder中的append方法 1234567891011121314151617181920212223242526字符串使用+拼接的过程中,会产生新的对象 - 拼接效率低String s1 = &quot;abc&quot;;String s2 = new String(&quot;abc&quot;); admindeMacBook-Pro:Desktop admin$ javap -c HelloStrCompiled from &quot;HelloStr.java&quot;public class HelloStr &#123; public HelloStr(); Code: 0: aload_0 1: invokespecial #1 // Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V 4: return public static void main(java.lang.String[]); Code: 0: ldc #2 // String abc 放在了&quot;串池中&quot; 2: astore_1 3: new #3 // class java/lang/String 6: dup // &quot;abc&quot; -&gt; 堆里面 7: ldc #2 // String abc &quot;串池中已经出现了&quot; 9: invokespecial #4 // Method java/lang/String.&quot;&lt;init&gt;&quot;:(Ljava/lang/String;)V 12: astore_2 13: return&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142String s1 = &quot;abc&quot;;String s2 = new String(&quot;def&quot;);s1 = s1 + s2;//会产生一个新的对象admindeMacBook-Pro:Desktop admin$ javap -c HelloStrCompiled from &quot;HelloStr.java&quot;public class HelloStr &#123; public HelloStr(); Code: 0: aload_0 1: invokespecial #1 // Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V 4: return public static void main(java.lang.String[]); Code: 0: ldc #2 // String abc 在串池中 2: astore_1 3: new #3 // class java/lang/String 6: dup // 同时在堆中开辟一块空间用来存储 String def 7: ldc #4 // String def 在串池中 9: invokespecial #5 // Method java/lang/String.&quot;&lt;init&gt;&quot;:(Ljava/lang/String;)V 12: astore_2 13: new #6 // class java/lang/StringBuilder //字符串每次拼接+,都会产生一个新的StringBuilder对象 16: dup 17: invokespecial #7 // Method java/lang/StringBuilder.&quot;&lt;init&gt;&quot;:()V //StringBuilder builder = new StringBuilder(); 20: aload_1 21: invokevirtual #8 // Method java/lang/StringBuilder.append: //(Ljava/lang/String;)Ljava/lang/StringBuilder; //字符串的+,底层仍然是去调用StringBuilder类中提供的append方法; 24: aload_2 25: invokevirtual #8 // Method java/lang/StringBuilder.append:(Ljava/lang/String;)Ljava/lang/StringBuilder; 28: invokevirtual #9 // Method java/lang/StringBuilder.toString:()Ljava/lang/String; 31: astore_1 32: return&#125; 字符串的比较1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950package stu.aistar.day09;/** * 本类用来演示: 字符串的各种比较 - (笔试题中容易出现) */public class StringCompare &#123; public static void main(String[] args) &#123; String s1 = new String(&quot;abc&quot;); //s1默认指向的是堆里面的字符串对象 String s2 = &quot;abc&quot;; //创建在 串池 中 System.out.println(s1 == s2); //false System.out.println(s1.intern() == s2);//true //因为intern()强制让s1指向串池的对象 String s3 = &quot;b&quot;; String s4 = &quot;a&quot; + s3; //产生一个StringBuilder对象 String s5 = &quot;a&quot; + &quot;b&quot;; //因为此处的&quot;a&quot;和&quot;b&quot;就是字符串常量 //jvm对待字符串常量的拼接 - &quot;a&quot;和&quot;b&quot;的拼接 //当成&quot;ab&quot;的整体,直接扔到常量池中. System.out.println(s4 == s5); //false final String s6 = &quot;b&quot;; //字符串使用final修饰 String s7 = &quot;a&quot; + s6; //&quot;a&quot;+s6 =&gt; &quot;ab&quot;扔到常量池,没有产生新的对象. System.out.println(s5 == s7); //true String x1 = new String(&quot;abc&quot;); //都定义在堆区 x1 x2分别拥有不同的地址值 String x2 = new String(&quot;abc&quot;); System.out.println(x1 == x2); //false 比较的是地址值 System.out.println(x1); //希望字符串的值是一样的,就希望返回true System.out.println(x1.equals(x2)); //true 用equals方法 比较的是字符串的值 //特殊方法获得的字符串 通过subString String o1 = &quot;abc&quot;; String o2 = o1.substring(0); //如果是0开始的话 底层 返回的是他的本身this //也就是o1自己的地址 指向的同一块 System.out.println(o1 == o2); //true 只有当subString全部的时候 才能是true String o3 =o1.substring(1,3); //bc System.out.println(&quot;bc&quot; == o3); //false System.out.println(&quot;ok&quot; == getResult()); &#125; public static String getResult()&#123; // return &quot;ok&quot;; // true 串池中 return new String(&quot;ok&quot;); //false new出来的在堆中 &#125;&#125; 字符串常用方法 构造方法 String(); String(String val); String(StringBuilder builder);//StringBuilder对象转换成String对象 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465package stu.aistar.day09;/** * 本类用来演示: 字符串常用方法 */public class StringMethod &#123; public static void main(String[] args) &#123; String s = new String(&quot;abc&quot;); // 当charAt(&gt;s.length的时候) java.lang.StringIndexOutOfBoundsException //b 1对应的是String对应数组的下标 (string底层是一个char类型的数组) System.out.println(s.charAt(1)); System.out.println(s.length()); //3 字符串的长度 //原来的字符串的末尾添加新的字符串 (底层是通过普通数组的扩容进行拼接的字符串) String result = s.concat(&quot;de&quot;); System.out.println(result); //abcde //判断字符串中是否包含某个序列 (返回类型是一个boolean类型) &lt;- true System.out.println(s.contains(&quot;bc&quot;)); // 判断前缀或者后缀(返回类型是一个boolean类型) &lt;- true System.out.println(&quot;xxx.gif&quot;.endsWith(&quot;.gif&quot;)); System.out.println(&quot;javaScript&quot;.startsWith(&quot;java&quot;));//前缀 &lt;- true System.out.println(&quot;abc&quot;.equals(s)); //true 比较的是字符串的值 System.out.println(&quot;ABc&quot;.equalsIgnoreCase(&quot;abc&quot;));//忽略大小写的比较(ignore) true System.out.println(&quot;abc&quot;.toUpperCase()); //转换大写和小写ABC System.out.println(&quot;ABC&quot;.toLowerCase()); //abc(小写) System.out.println(&quot;abcabc&quot;.indexOf(&quot;bca&quot;));//返回指定字符第一次出现的字符串内的索引(1) //返回最后一个出现该字符的索引(下标) -4 (也可以是一个字符串 &quot;bca&quot;) System.out.println(&quot;abcabc&quot;.lastIndexOf(&quot;b&quot;)); System.out.println(&quot;&quot;.isEmpty());//判断字符串是否为空 长度为0的字符串 - 返回true System.out.println(&quot;I Love Girl&quot;.replace(&quot;Girl&quot;,&quot;Java&quot;));//替换 String ip = &quot;192:168:3:90&quot;; //字符串的切割 String[] arr = ip.split(&quot;\\\\:&quot;); // &quot;\\\\s&quot;指的是空格 想要设置哪个标识进行切割，必须两个\\ for (String s1 : arr) &#123; //增强for循环比遍历arr数组 - (切割过后的值) System.out.println(s1); &#125; //将字符串转换成char类型数组 (String -&gt; Char[]) char[] arr2 = &quot;白日依山尽&quot;.toCharArray(); for (char c : arr2) &#123; System.out.println(c); &#125; String x1 = &quot;abcde&quot;; String x2 = x1.substring(1,3); //[1,3) System.out.println(x2); System.out.println(x1.substring(1));//从1一直截取到最后bcde //trim() - 去除字符串左右两边的空格 System.out.println(&quot; ab c &quot;.trim().length()); //4 System.out.println(&quot; &quot;.trim().length()); //0 String o = String.valueOf(10); //int-&gt;String System.out.println(o+10); &#125;&#125; java.lang.StringBuilder 它是一个[可变]的字符串 - final修饰,性能最高的.默认的容量 [16] .线程不安全的 StringBuilder(); StringBuilder(String val); //String类型转换成StringBuilder类型 扩容机制 研究append方法 12345678910111213141516171819202122232425262728293031323334353637StringBuilder x = new StringBuilder(&quot;abc&quot;);x.append(&quot;def&quot;);//StringBuilder类的父类AbstractStringBuilderpublic AbstractStringBuilder append(String str) &#123;if (str == null) return appendNull();int len = str.length();//len = 3//count+len//count - 原来数组中已经存在的字符的长度//len - 需要存入的新的字符串长度ensureCapacityInternal(count + len);//0+3str.getChars(0, len, value, count);count += len; //把新字符串的长度赋值给count 一遍下一次扩容return this;&#125;//扩容方法private void ensureCapacityInternal(int minimumCapacity) &#123;// overflow-conscious codeif (minimumCapacity - value.length &gt; 0) expandCapacity(minimumCapacity);&#125;//真正的扩容方法void expandCapacity(int minimumCapacity) &#123;int newCapacity = value.length * 2 + 2; //扩容,得到新的长度if (newCapacity - minimumCapacity &lt; 0) //扩容得不够,不够长 newCapacity = minimumCapacity; //直接补充到最长的.if (newCapacity &lt; 0) &#123; //长度会溢出. if (minimumCapacity &lt; 0) // overflow throw new OutOfMemoryError(); newCapacity = Integer.MAX_VALUE;&#125;value = Arrays.copyOf(value, newCapacity);&#125; 常用方法12345678910111213141516171819202122232425262728293031package stu.aistar.day09;/** * 本类用来演示: 常用方法 - 可变的字符串 */public class StringBuilderMethod &#123; public static void main(String[] args) &#123; StringBuilder x = new StringBuilder(&quot;abcd&quot;);//String-&gt;StringBuilder(内部) System.out.println(x); StringBuilder result = x.delete(1,3); //[1,3) System.out.println(&quot;result:&quot;+result); //ad System.out.println(&quot;x:&quot;+x); //ad System.out.println(x.deleteCharAt(0)); //d 根据下标进行删除操作 x.insert(0,&quot;晓恒&quot;); System.out.println(x);//晓恒d System.out.println(x.reverse());//d恒晓 //反转字符串 //int n = 6723; //System.out.println(String.valueOf(n).length());//利用转换成字符串求几位数(字符串的长度=位数) //tringBuilder y = new StringBuilder(String.valueOf(n));//String -&gt; StringBuilder //System.out.println(y.reverse());//利用StringBuilder的反转方法 - (解决数字的反转问题) //StringBuilder-&gt;String System.out.println(x.toString()); &#125;&#125; 总结! String类型和StringBuilder类型之间的相互转换问题 StringBuilder-&gt;String类型 java.lang.StringBuilder中提供的String toString(); java.lang.String类中提供的构造方法String(StringBuilder builder); java.lang.String类中提供的static String valueOf(Object obj);//面向父类编程 String-&gt;StringBuilder java.lang.StringBuilder中提供的构造StringBuilder(String val); java.lang.StringBuffer 它的使用方式和StringBuilder是一模一样的.唯一区别是它是多线程安全的.可变的字符串 因为它里面的方法都使用synchronized关键字进行了修饰,重量级的对象. 性能低于StringBuilder 笔试题 String,StringBuilder,StringBuffer三者的区别? - 查,补充完整 - 作业 三者之间都是使用final修饰的,都是不可被继承的,jdk处于安全角度考虑的 - 共同点 不同点 2-1. String它是不可变的字符串,线程安全的.比较耗系统资源和内存的.性能是三个当中最低的. 2-2. StringBuilder可变的字符串 - 线程不安全的,效率是最高的. 2-3. StringBuffer可变的字符串 - 线程安全的.效率低于StringBuilder,但是高于String String StringBuffer StringBuilder String的值是不可变的，这就导致每次对String的操作都会生成新的String对象，不仅效率低下，而且浪费大量优先的内存空间 StringBuffer是可变类，和线程安全的字符串操作类，任何对它指向的字符串的操作都不会产生新的对象。每个StringBuffer对象都有一定的缓冲区容量，当字符串大小没有超过容量时，不会分配新的容量，当字符串大小超过容量时，会自动增加容量 可变类，速度更快 不可变 可变 可变 线程安全 线程不安全 多线程操作字符串 单线程操作字符串 作业 两道笔试题 1234567891011121314151617181920212223242526272829303132333435363738394041424344//从oldStr中删除指定的target字符串//比如&quot;abcdebcef&quot;,&quot;bc&quot; -&gt; 返回&quot;adeef&quot;//禁止使用replace方法//(此方法为非递归)public class DelByStr &#123;public static void main(String[] args) &#123; String s1 = &quot;abcdebcef&quot;; String s2 = &quot;bc&quot;; System.out.println(delByStr(s1, s2));&#125;public static String delByStr(String oldStr,String target) &#123; while (oldStr.contains(target))&#123; //包含目标串 int index = oldStr.indexOf(target); //获取目标串在老字符串中的索引(下标) //转换成StringBuilder对象,因为里面有一个delete方法 StringBuilder builder = new StringBuilder(oldStr); builder.delete(index,target.length()+index); oldStr = builder.toString(); //转换为原字符串形式 (StringBuilder-&gt;String) &#125; return oldStr;&#125;&#125;//递归方式(easy - 首先得学会递归!) - 根据字符串到原来的字符串中进行删除操作 - 操作的不是原来的字符串// - ,不断返回一个新的字符串.public static String delByStr(String oldStr,String target)&#123; //1. 递归出口 if(!oldStr.contains(target)) return oldStr; //2. oldStr中仍然包含target //找到target字符串在oldStr字符串中的下标位置. //bcbcabca -&gt; ca int startIndex = oldStr.indexOf(target); //返回target在oldStr中第一次出现的下标位置 int endIndex = startIndex+target.length(); //5 //String类型转换成StringBuilder类型 - delete(int start,int end); //[start,end) StringBuilder builder = new StringBuilder(oldStr); StringBuilder result = builder.delete(startIndex,endIndex); //bcbbca return delByStr(result.toString(),target);&#125; 123456789101112131415161718192021222324252627282930//找出俩个字符串中的最大长度的公串//s1：abcbcedfdfdepopoqqq//s2：fdfdbcbceoifdfdeqqa//结果为：bcbce fdfdepublic class FindMaxPublicStr &#123;public static void main(String[] args) &#123; String s1 = &quot;abhbcedfdfdepofabcbc&quot;; String s2 = &quot;fdfdbcbceoifdfabcbc&quot;; String s3 = &quot;&quot;; int max = 0; //记录公串长度 for (int i = 0; i &lt; s1.length(); i++) &#123; for (int j = i; j &lt;= s1.length(); j++) &#123; //不设置= 取不到最后一个 s3 = s1.substring(i,j); //s3中是否包含截取的字符串 if (s2.contains(s3))&#123; if (max&lt;s3.length())&#123; max = s3.length(); //求他的最大公串的长度(这样做可以避免公串有两个的问题) &#125; &#125; &#125; &#125; String str = &quot;&quot;; for (int i = 0; i &lt;= s1.length()-max; i++) &#123; str = s1.substring(i,i+max); if (s2.contains(str))&#123; System.out.println(str); &#125; &#125;&#125;&#125;","categories":[{"name":"字符串","slug":"字符串","permalink":"http://example.com/categories/%E5%AD%97%E7%AC%A6%E4%B8%B2/"}],"tags":[{"name":"java","slug":"java","permalink":"http://example.com/tags/java/"}]},{"title":"单例","slug":"Singleton","date":"2021-07-31T02:29:40.000Z","updated":"2021-07-31T03:12:20.951Z","comments":true,"path":"2021/07/31/Singleton/","link":"","permalink":"http://example.com/2021/07/31/Singleton/","excerpt":"","text":"单例引言 饿汉模式 多线程安全123456789101112131415161718192021222324252627282930package stu.aistar.design.singleton.version01;/** * 本类用于演示：饿汉式 多线程安全 (但是浪费空间,因为如果我只是想调用其中的方法 你干嘛给我创建一个对象) * 将Singleton01设置成饿汉模式 - 单例的 */public class Singleton01 &#123; //2. 初始化一个变量，该变量就是该类的唯一实例[对象] private static Singleton01 instance = new Singleton01(); //1. 私有化构造 private Singleton01()&#123; //比较费时费力的代码，可能需要更多的时间 System.out.println(&quot;Singleton01............&quot;); &#125; //3. 提供一个公开的、静态的、方法来返回这个类的唯一属性 public static Singleton01 getInstance()&#123; return instance; &#125;&#125;//测试public class TestSingleton01 &#123; public static void main(String[] args) &#123; //获取类的实例 Singleton01 s1 = Singleton01.getInstance(); Singleton01 s2 = Singleton01.getInstance(); System.out.println(s1 == s2); //true &#125;&#125; 懒汉模式 多线程不安全1234567891011121314151617181920212223242526272829package stu.aistar.design.singleton.version02;/** * 本类用来演示: 懒汉 * */public class Singleton02 &#123; private static Singleton02 instance; private Singleton02()&#123; System.out.println(&quot;私有化构造&quot;); &#125; public static Singleton02 getInstance()&#123; if (instance == null)&#123; instance = new Singleton02(); &#125; return instance; //return instance == null?instance = new Singleton02():instance; //三元运算符搞定！ &#125;&#125;class TestSingleton02&#123; public static void main(String[] args) &#123; Singleton02 s1 = Singleton02.getInstance(); Singleton02 s2 = Singleton02.getInstance(); System.out.println(s1 == s2); //true &#125;&#125; 双重检查锁 - （笔试脱手写的版本） 懒汉模式下 - 仍然是多线程安全的 123456789101112131415161718192021222324252627282930313233343536package stu.aistar.design.singleton.version03;/** * 本类用来演示:双重检查锁 - (笔试脱手写的版本) */public class Singleton03 &#123; private static Singleton03 instance; private Singleton03()&#123; System.out.println(&quot;私有化构造&quot;); &#125; public static Singleton03 getInstance()&#123; //因为本身&quot;锁&quot;资源就是一个比较昂贵的资源,为了避免跑得慢的线程去抢这个把锁,所以此处也要进行非空判断. if(instance == null)&#123; //跑得快的线程都会进入此处 比如：A,B //A,B线程就会去争抢锁资源,谁抢到锁资源,谁就会进入 //同步代码块去执行里面的代码 //假设A线程抢到了,B就会在等待 synchronized (Singleton03.class)&#123; //A进入判断instance==null //只要抢到&quot;锁&quot;的线程,如果此处没有非null判断 //那么进入到这的线程都会去执行instance = new Singleton03(); if(instance == null)&#123; //由A线程进行实例的初始化 //A继续执行,等A执行完毕之后,那么A就会释放锁资源 //其他线程继续争抢锁资源. instance = new Singleton03(); &#125; &#125; &#125; return instance; &#125;&#125;//测试就是相同的测试... (目前还没到线程进行测试,后续会利用多线程进行单例测试) volatile 可见性 - 忽略 禁止JVM的指令重排 12345678910int i=10;//原子性操作 Student s = new Student();//不是一个原子性操作 ①给s对象分配内存空间 ②调用构造块,执行构造函数 - 初始化动作 ③将引用s指向内存中的那个对象. 但是JVM内部会对这些指令进行一个优化操作. 本来你的顺序应该是①-②-③,经过JVM指令重排之后,顺序有可能 变成①-③-② 123456789101112131415161718192021222324252627282930313233343536package stu.aistar.design.singleton.version03;/** * 本类用来演示:双重检查锁 - (笔试脱手写的版本) */public class Singleton03 &#123; private volatile static Singleton03 instance; //此处就利用volatile进行对jvm的禁止指令重排!!! //private static Singleton03 instance; private Singleton03()&#123; System.out.println(&quot;私有化构造&quot;); &#125; public static Singleton03 getInstance()&#123; //② - 跑得很慢的线程刚刚到达此处,其他线程判断instance是不为null的 //但是instance可能指向的是一个&quot;半成品&quot; - A线程还没有完成构造方法. //其他线程可能会使用到这个&quot;半成品&quot;对象,肯定会有问题. if(instance == null)&#123; synchronized (Singleton03.class)&#123; if(instance == null)&#123; //① - A线程可能执行到2步骤的时候,instance已经不为null //不是一个原子性操作,可能经过JVM指令重排 //1. 给instance对象分配空间 //2. 将对象的内存地址赋值给了instance //3. 调用构造方法 instance = new Singleton03(); &#125; &#125; &#125; return instance; &#125;&#125; PS1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253一、static关键字 1. **static修饰的成员是在JVM加载类的时候就会被立即分配空间以及初始化 - 只有1次**,内存的实例只有1份 2. 非静态的成员的是在每次创建对象的时候才会被分配空间以及初始化 二、作用 &gt; 1. static修饰符类 - 静态内部类[过] &gt; 2. 修饰的属性 - 静态属性 &gt; 3. 方法 - 静态方法 &gt; 4. 代码块 - 静态代码块三、JVM加载类进内存的活动顺序 0. JVM加载类进内存 1. 给所有的静态属性分配空间以及初始化 2. 给所有的静态方法分配空间以及初始化 3. 调用静态代码块 4. 如果创建了对象 4-1. 给这个对象的所有的非静态属性分配空间以及初始化 4-2. 给这个对象的所有的非静态方法分配空间 4-3. 调用普通代码块 4-4. 调用构造块 PS:静态代码块在类第一次被载入时执行，在这里主要是想验证一下，类初始化的顺序。 ( 父类静态变量 父类静态代码块 子类静态变量 子类静态代码块 父类普通变量 父类普通代码块 父类构造函数 子类普通变量 子类普通代码块 子类构造函数 )四、static关键字应用 &gt; 设计模式 - 单例模式 &gt; &gt; 如何保证某个类的对象在内存中永远只有1份.后期,某些类的创建和销毁的时间成本比较高.这些类有必要设计成单例的. &gt; &gt; 比如jdbc中的连接池对象[重量级的对象]","categories":[{"name":"设计模式","slug":"设计模式","permalink":"http://example.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"java","slug":"java","permalink":"http://example.com/tags/java/"}]},{"title":"面试经典题","slug":"InterviewQuestions1-0","date":"2021-07-30T12:50:20.000Z","updated":"2021-07-31T01:15:05.863Z","comments":true,"path":"2021/07/30/InterviewQuestions1-0/","link":"","permalink":"http://example.com/2021/07/30/InterviewQuestions1-0/","excerpt":"","text":"面试题HashMap 和 HashTable 区别 HashMap 是 HashTable 的轻量级实现，他们都完成了Map 接口，主要区别在于 HashMap 允许 null key 和 null value,由于非线程安全，效率上可能高于 Hashtable。主要区别如下: HashMap允许将 null 作为一个 entry 的 key 或者 value，而 Hashtable 不允许。 HashMap 把 Hashtable 的 contains 方法去掉了，改成 containsValue 和 containsKey。因为 contains 方法容易让人引起误解。 HashTable 继承自 Dictionary 类，而 HashMap 是 Java1.2 引进的 Map interface 的一个实现。 HashTable 的方法是 Synchronize 的，而 HashMap 不是，在多个线程访问 Hashtable 时，不需要自己为它的方法实现同步，而 HashMap 就必须为之提供外同步。 Hashtable 和 HashMap 采用的 hash/rehash 算法都大概一样，所以性能不会有很大的差异。 ArrayList和LinkedList区别 ArrayList是实现了基于动态数组的数据结构，LinkedList基于链表的数据结构。 对于随机访问get和set，ArrayList觉得优于LinkedList，因为LinkedList要移动指针。 对于新增和删除操作add和remove，LinedList比较占优势，因为ArrayList要移动数据 List和Set区别 两个接口都是继承自Collection，是常用来存放数据项的集合，主要区别如下： List和Set之间很重要的一个区别是是否允许重复元素的存在，在List中允许插入重复的元素，而在Set中不允许重复元素存在。 与元素先后存放顺序有关，List是有序集合，会保留元素插入时的顺序，Set是无序集合。 List可以通过下标来访问，而Set不能。 HashSet和HashMap区别 HashSet的底层是HashMap HashMap HashSet HashMap实现了Map接口 HashSet实现了Set接口 HashMap储存键值对 HashSet仅仅存储对象 使用put()方法将元素放入map中 使用add()方法将元素放入set中 HashMap中使用键对象来计算hashcode值 HashSet使用成员对象来计算hashcode值，对于两个对象来说hashcode可能相同，所以equals()方法用来判断对象的相等性，如果两个对象不同的话，那么返回false HashMap比较快，因为是使用唯一的键来获取对象 HashSet较HashMap来说比较慢 ArrayList和HashSet区别 1.HashSet 是不重复的 而且是无序的! ​ 唯一性保证. 重复对象equals方法返回为true ，重复对象hashCode方法返回相同的整数 ​ HashSet其实就是一个HashMap,只是你只能通过Set接口操作这个HashMap的key部分, 2.ArrayList是可重复的 有序的 ​ 特点：查询效率高，增删效率低 轻量级 线程不安全。 arraylist：在数据的插入和删除方面速度不佳，但是在随意提取方面较快 HashSet和TreeSet区别 一、HashSet HashSet内部的数据结构是哈希表，是线程不安全的。 HashSet当中，保证集合中元素是唯一的方法。 通过对象的hashCode和equals方法来完成对象唯一性的判断。 假如，对象的hashCode值是一样的，那么就要用equals方法进行比较。 假如，结果是true，那么就要视作相同元素，不存。 假如，结果是false，那么就视为不同元素，存储。 注意了，假如，元素要存储到HashCode当中，那么就一定要覆盖hashCode方法以及equals方法。 二、TreeSet TreeSet能够对Set集合当中的元素进行排序，是线程不安全的。 TreeSet当中，判断元素唯一性的方法是依据比较方法的返回结果是否为0，假如是0，那么是相同的元素，不存，假如不是0，那么就是不同的元素，存储。 TreeSet对元素进行排序的方式： 1、元素自身具备比较功能，也就是自然排序，需要实现Comparable接口，并覆盖其compareTo方法。 2、元素自身不具备比较功能，那么就要实现Comparator接口，并覆盖其compare方法。 除此之外，还要注意了，LinkedHashSet是一种有序的Set集合。 也就是其元素的存入和输出的顺序是相同的。 HashMap和TreeMap区别 HashMap的底层是Array，所以HashMap在添加，查找，删除等方法上面速度会非常快。而TreeMap的底层是一个Tree结构，所以速度会比较慢。 另外HashMap因为要保存一个Array，所以会造成空间的浪费，而TreeMap只保存要保持的节点，所以占用的空间比较小。 HashMap如果出现hash冲突的话，效率会变差，不过在java 8进行TreeNode转换之后，效率有很大的提升。 TreeMap在添加和删除节点的时候会进行重排序，会对性能有所影响。 ArrayList和Vector区别 Vector是线程安全的，ArrayList不是线程安全的。 ArrayList在底层数组不够用时在原来的基础上扩展0.5倍，Vector是扩展1倍。","categories":[{"name":"Interview","slug":"Interview","permalink":"http://example.com/categories/Interview/"}],"tags":[{"name":"Interview","slug":"Interview","permalink":"http://example.com/tags/Interview/"}]},{"title":"分支语句","slug":"java003","date":"2021-07-19T12:07:25.000Z","updated":"2021-07-31T03:12:01.162Z","comments":true,"path":"2021/07/19/java003/","link":"","permalink":"http://example.com/2021/07/19/java003/","excerpt":"","text":"方法的重载(@overload) 前提: 重载的方法是存在于同一个类中 [前提] 重载的方法的方法名必须相同 重载的方法的参数列表必须不相同 重载的方法的返回类型可以不一样,可以一样 1234567891011121314public class LoadMethodDemo &#123; public static void main(String[] args) &#123; add(20); &#125; public static int add()&#123; System.out.println(&quot;add -&gt; 100&quot;); return 100; &#125; public static void add(int i)&#123; System.out.println(i); &#125;&#125; 优点就是简化api - 方便调用的. 学会使用api 通过学习java.lang.Math - 数学工具类 - 提供了很多关于数学计算的方式. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051package tech.aistar.day03;/** * 本类用来演示: java.lang.Math * * @author: success * @date: 2021/7/19 8:59 上午 */public class MathDemo &#123; public static void main(String[] args) &#123; //绝对值 int n = Math.abs(-10); System.out.println(n); //求随机数 - 伪随机的 //static double random();//[0.0,1.0)之间的随机小数 System.out.println(Math.random()); //[1,100]之间随机的整数 int result = (int) (Math.random()*100+1);//[1,100] System.out.println(result); //[3,5]之间的随机整数 int m = (int) (Math.random()*3+3); System.out.println(m); //求俩个数中的最大值/最小值 System.out.println(Math.max(10,20));//20 //笔试填空题 - //返回小于或等于参数的最大（最接近正无穷大） double值，等于一个数学整数。 //floor方法. System.out.println(Math.floor(3.5));//3.0 System.out.println(Math.floor(4.0));//4.0 System.out.println(Math.floor(-3.5));//-4.0 //返回参数中最接近的 long ，其中 long四舍五入为正无穷大。 //Math.floor(a + 1/2) System.out.println(Math.round(-3.5)); //开根 System.out.println(Math.sqrt(9));//3.0 //次方 System.out.println((int)Math.pow(2,3));//8 &#125;&#125; 语句三元操作符 三目运算符 条件表达式 ? result1 : result2 表达式为true,结果就是result1,否则结果是result2 支持无限嵌套的 - 但是不推荐,可读性差 m ? (表达式?result1:result2):result2 if…else.. if语句单独使用场景 123if(条件)&#123;//成立 //code...&#125; {}可以省略的场景 1234if(条件) //code...如果if&#123;&#125;中的代码只有1行,那么&#123;&#125;可以省略,但是一定要缩进 if…else…使用 1234567891011if(条件)&#123; //条件成立&#125;else&#123; //条件不成立&#125;//如果语句仍然只有一行,&#123;&#125;还是可以省略的if(条件) //codeelse //code.. 多条件分支if…else if…else..if … else… 注意条件是互斥的 123456789if(条件)&#123; //条件成立&#125;else if(条件)&#123; //条件不成立&#125;else if(条件)&#123; //code&#125;else&#123; //code..&#125; if..else语句可以无限嵌套使用 1234567891011121314151617181920212223if(条件)&#123; //条件成立 if(条件)&#123; &#125;else&#123; &#125;&#125;else if(条件)&#123; //条件不成立 if(条件)&#123; //条件成立 &#125;else if(条件)&#123; //条件不成立 &#125;else if(条件)&#123; //code &#125;else&#123; //code.. &#125;&#125;else if(条件)&#123; //code&#125;else&#123; //code..&#125; 习题 买奶茶,每第二杯半价,单价是10元.求总价. 110 5 10 5 10 求某年某月最大天数 switch..case 没有if..else if..else灵活 语法: 1234567891011121314151617switch(变量)/ /byte short int char String enum[枚举类型] //包装类型Byte Short Integer Charactercase 值1: //code [break];case 值2: //code [break];case 值3: //code [break];[default: //code.. [break];]&#125; 当switch括号中的变量能够匹配到某个case后面的值的时候,那么就会进入到对应的case中去执行里面的程序 进入到某个case块中执行的过程中,只有遇到break语句才会跳出switch块.如果没有遇到break语句,那么程序会 自动进入到下一个case块中去执行. default语句可以省略,也是可以随便放的,推荐放在末尾.如果switch括号中的变量没有匹配到任何的case后面的值 的时候,那么就会进入到default 循环语句while 属于后置循环 - 先判断循环条件是否成立,如果成立,则进入到循环体中,否则不执行循环. 使用场景:当不知道循环多少次,但是知道循环退出的条件的时候 - 优先选择while循环. 语法: while(条件){ ​ // 循环体… } 12345678910111213141516171819202122232425262728293031323334353637package tech.aistar.day03;/** * 本类用来演示: while循环 * * @author: success * @date: 2021/7/19 10:53 上午 */public class WhileDemo &#123; public static void main(String[] args) &#123; //while可以代替for的使用 //&#x27;a&#x27;-&#x27;z&#x27; char c = &#x27;a&#x27;; while(c &lt;= &#x27;z&#x27;)&#123; System.out.println(c); c++; &#125; System.out.println(&quot;=====&quot;); //&#x27;A&#x27; - &#x27;Z&#x27; int n = 65; while(n&lt;=90)&#123;//退出的条件 System.out.println((char)n); n++; &#125; //1-10 int m = 1; //死循环... while(true)&#123; //死循环的内部一定要有打破循环的语句 - break System.out.println(m); if(m==10) // 循环退出的条件 break; m++; &#125; &#125;&#125; 练习 求俩个数的最大公约数 12345思路:20 12 -&gt; 4 20 % 12 = 8 12 % 8 = 4 8 % 4 = 0 十进制转换二进制 1 for循环 属于后置循环 单层for 1234567891011for(①表达式1;②表达式2;③表达式3)&#123; //④循环体&#125;①表达式1 - 循环过程中的变量的初始化操作.比如int i = 0; - 仅仅只会执行1次.②表达式2 - 循环退出的条件.比如 i&lt;=10 - 至少执行1次③表达式3 - 循环过程中,变量因子的变化.i++ - 有可能是不执行,可能执行执行顺序①-②[成立]-④-③-②[成立]-④-③..... 怪异的写法 1234for(;;)&#123; //死循环 - break打破循环的语句&#125;三个表达式都是可以任意的省略不写,或者写到其他地方 for循环的复合形态 123for(同时定义若干个变量;条件;表达式)&#123; //循环体...&#125; 嵌套for循环,嵌套的层数不建议超过三层.嵌套越多,性能越低. 2-1. 内外层无关 - 里面的for选中的使用可以单独执行.没有使用到外面for的循环的变量因子的. 2-2. 内外层相关 - 里面的for使用到了外面for循环的变量因子的 练习 - 打印所有的三位数.三位数由数字1,2,3,4组成.但是不能出现重复的. 每打印4个换一行 12345678910111213141516171819202122232425262728293031323334353637package tech.aistar.day03; /** * 本类用来演示: * 练习 - 打印所有的三位数.三位数由数字1,2,3,4组成.但是不能出现重复的. * * 每打印4个换一行 * * @author: success * @date: 2021/7/19 2:26 下午 */public class ForExerciseDemo &#123; public static void main(String[] args) &#123; //定义一个计数器 int count = 0; for (int x = 1; x &lt;=4 ; x++) &#123; for (int y = 1; y &lt;=4; y++) &#123; for (int z = 1; z &lt;=4; z++) &#123;// System.out.print(x+&quot;&quot;+y+z); if(x!=y &amp; x!=z &amp; y!=z)&#123; System.out.print(x*100+y*10+z+&quot;\\t&quot;); count++;// if(count % 4==0)&#123;// System.out.println();// &#125; if(count == 4)&#123; System.out.println(); count = 0; &#125; &#125; &#125; &#125; &#125; &#125;&#125; do..while.. 属于前置循环 - 无论循环条件是否成立,优先先进入到循环体中执行一次. 然后再进行判断条件,决定下一次是否再次进入. do{ //循环体… }while(条件); break语句 break可以跳出swtich块 break可以打破它所在的那一层循环 continue语句 出现在循环体中 跳过本轮循环,继续执行下一轮循环. 数组 数组的诞生 - 为了解决单个变量只能存储单个值的缺点. 数组本身也是属于数据结构[数组,栈,堆,树[红黑树],链表,图…] 数组是属于对象类型,数组是存在在JVM内存的堆区,基本类型存储在JVM内存的栈区 数组在内存中一定是一块连续的空间. 数组的大小[长度,数组中存放的数据的个数]一旦确定了,不能改变. 语法1234567891. 元素类型[] 变量名 = new 元素类型[size];//size数组的大小2. 元素类型 变量名[] = new 元素类型[size];//元素类型就是数据类型[8种基本数据类型,以及对象类型]作用 - 元素类型决定了这个数组中可以存放的数据的类型//arr的数据类型是什么?int[] -&gt; 整数型数组// &quot;定义一个长度为3的int型数组&quot;int[] arr = new int[3]; 赋值方式 如果定义了数组,但是没有进行赋值操作,那么系统会默认分配一个默认值 默认值根据元素类型来决定了. byte,short,int,long -&gt; 0 float,double -&gt; 0.0 boolean -&gt; false char -&gt; 空格 对象类型 -&gt; null 先定义数组,然后通过下标一一赋值 123456int[] arr = new int[3];//数组的下标从[0,数组长度-1]范围//如果下标不在此范围,控制台抛出java.lang.ArrayIndexOutOfBoundsException 数组下标越界异常arr[0] = 10;arr[1] = 10;arr[2] = 10; 定义数组的同时进行赋值 1int[] arr = &#123;3,4,5&#125;; 定义数组的同时进行赋值 1int[] arr = new int[]&#123;3,4,5&#125;; 通过普通for去赋值 1234int[] arr = new int[3];for(int i=0;i&lt;arr.length;i++)&#123; arr[i] = (int)(Math.random()*100+1);&#125; 数组的遍历 通过下标一一取值 1System.out.println(arr[下标]); 数组提供了属性length - 获取数组的长度 通过普通for循环进行遍历 123for (int i = 0; i &lt; arr.length; i++) &#123; System.out.println(arr[i]);&#125; 使用jdk5.x提供的增强for循环的语法 属于只读的for 1234567int[] arr2 = &#123;3,4,5&#125;;for(元素类型 元素变量:数组变量名)&#123; System.out.println(元素);&#125;for(int e:arr2)&#123;//此处的e不是代表下标,就是代表真正的元素 System.out.println(e);&#125; 拓展 - 数组的内存123456789101112131415//通过new关键字在Jvm的堆中开辟新的空间01,用来存储这个对象&#123;10,20,30&#125;//然后将这个对象在堆空间中的内存地址赋值给了引用变量arr1[存储在栈]//&quot;结论&quot; - arr1的本质不是对象,只是一个引用变量而已//&quot;结论&quot; - 引用和对象之间的关系// 引用变量中存储的就是对象在堆空间中的内存地址// &quot;气球理论&quot; - 一个引用变量在同一个时刻,只能指向一个对象// - &quot;一个对象可以在同一个时刻被多个引用指向&quot;int[] arr1 = new int[]&#123;10,20,30&#125;;//通过new关键字在Jvm的堆中开辟新的空间02,用来存储这个对象&#123;10,20,30&#125;int[] arr2 = &#123;10,20,30&#125;;arr1 = arr2;//arr1和arr2都是指向第二次创建出来的数组对象 //原来第一次创建出来的对象就成为内存中的垃圾对象 - GC[垃圾回收线程进行回收,释放内存] //&quot;垃圾对象&quot; - 没有任何引用指向的对象 拓展 - 方法的参数传递方式 基本类型采用值传递 对象类型[引用类型]采用地址传递 总结:**Java中只有值传递,没有地址传递.**比较特殊的是String类型[虽然是一个对象类型,但是具备基本类型传递的特点]","categories":[{"name":"java","slug":"java","permalink":"http://example.com/categories/java/"}],"tags":[{"name":"java","slug":"java","permalink":"http://example.com/tags/java/"}]},{"title":"定义变量+修饰符all","slug":"day002","date":"2021-07-16T12:33:36.000Z","updated":"2021-07-31T05:16:05.742Z","comments":true,"path":"2021/07/16/day002/","link":"","permalink":"http://example.com/2021/07/16/day002/","excerpt":"","text":"变量的定义和使用123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101package stu.aistar.day02;import java.util.Date;/** * 本类用来演示: 变量的定义和使用 */public class VarInitDemo &#123; public static void main(String[] args) &#123; byte b = 127; short s = 100;//使用频率很少 //开发中常用的整数型类型 - int,long //int类型可以初始化的值有哪些 int a = 100; //存储一个二进制,只要0b二进制,1010对应的十进制 //java中的int类型表示的是十进制的数据 //1010 = 1*2^3+1+2^1 = 10 int a1 = 0b1010; System.out.println(a1); //java中使用单引号来表示一个字符 //&#x27;a&#x27;-&gt;char类型-&gt;int类型 //&#x27;a&#x27;对应的ascii码97 //&#x27;A&#x27;对应的ascii码是65 //&#x27;0&#x27;对应的ascii码是48 int a2 = &#x27;a&#x27;; System.out.println(a2); //java中以0开头的代表是八进制 //八进制转换十进制032 = 3*8^1 + 2*8^0 = 26 int a3 = 032; System.out.println(a3);//26 //长整型 - long //int类型-&gt;long类型 long x1 = 100; //推荐定义long的方式采用隐式转换 long x2 = 200L; //jdk7.x提供的 - 为了增强数字的可读性而已. long x3 = 3_14_15_926L; System.out.println(x3);// Date date = new Date(3L*24*60*60*100*1000*1000*2000);// System.out.println(date); //浮点数 - 并不是用来进行精确计算的 //后面java.math.Decimal类解决小数计算的时候精度丢失的问题. double d = 1.75; //推荐定义double double d2 = 5.67D; //float的精度是7或者8 //double的精度是16 //double类型强制转换成float类型 float f = (float) 3.14; //隐式转换 float f2 = 3.14F; System.out.println(f2); //补充 //数字进行计算的时候,都会转换成二进制进行计算 //小数进行计算的时候,还是不可逆的 //0.8999999999999999 System.out.println(2.0-1.1); //0.9 System.out.println(2.0f - 1.1f); //int-&gt;float × //int-&gt;double √ int n = 123456789; float ft = n; System.out.println(ft);//1.23456792E8 double db = n; System.out.println(db);//1.23456789E8 float f3 = 1.234567565f; System.out.println(f3);//1.2345675 //定义布尔类型 boolean flag = true; System.out.println(flag); //最特殊的是char类型 char c = 65; System.out.println(c); &#125;&#125; char类型 java中是使用单引号表示char类型,使用双引号来表示字符串. java的底层的编码是unicode编码,char类型也是采用unicode编码 unicode编码是双字节[16bit],所以存储一个汉字. ascii码和unicode码的关系? 不同的国家,符号表示的方式不同,所以ascii码[0127]不够用.所以unicode[065535]码诞生了,几乎 包含了所有国家的符号,unicode码包含ascii码.char类型在进行计算的时候会转换成ascii码来进行计算. 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748package tech.aistar.day02;/** * 本类用来演示: char类型 * * @author: success * @date: 2021/7/16 9:14 上午 */public class CharDemo &#123; public static void main(String[] args) &#123; //java中是使用单引号表示char类型 //char的空间大小也是确定的 char c = &#x27;a&#x27;; System.out.println(c); //十六进制 //由数字0-9或者字母a-f/A-F,字母a代表就是数字10 //cmd - 输入native2ascii -&gt; 输入中文 char c2 = &#x27;\\u34af&#x27;; System.out.println(c2); //char底层采用的是unicode编码,所以存储一个汉字 char c3 = &#x27;星&#x27;; System.out.println(c3); char c4 = 48; System.out.println(c4); int m = 48; char c5 = (char) m; System.out.println(c5); //char类型在进行计算的时候会转换成ascii码来进行计算. //&#x27;a&#x27; = 97,&#x27;A&#x27; = 65,&#x27;0&#x27; = 48 //char类型的计算 - 进阶部分 char n1 = &#x27;a&#x27; + 1;//ok System.out.println(n1);// &#x27;b&#x27; char cc = &#x27;a&#x27;; char nn = (char) (cc + 1); System.out.println(cc); //char-&gt;int int result = &#x27;a&#x27; + &#x27;b&#x27;;//ok System.out.println(result);//195 &#125;&#125; 变量的赋值方式 单个赋值 int a = 10; 通过表达式赋值 1234int a = 10;int b = 20;//表达式:由字面量或者变量以及运算符号组成的合法的语句int result = a + b; 链式赋值 123int a=10,b=20,c=30;//同时声明了三个变量,并且都进行初始化int a,b,c = 100;//此处仅仅是对c进行赋值操作,如果一个局部变量没有进行赋值,那么将不能够使用 可以先定义变量,然后再进行赋值 1234int a;a = 10;a = 20;System.out.println(a); 通过方法进行赋值 - 暂时了解 12345678910int result = getResult(); /** * 自定义了一个方法 - 千万不要将它放在main方法中 * java语法 - 方法体内部是不能够再去定义方法的 * @return 整数 */public static int getResult()&#123; return 100;&#125; 变量的分类 局部变量 - 定义在方法体内部 使用的范围就是在它所在的最近的那个{}中 全局变量 - 定义在方法体外部的变量 生命周期 - 面向对象 常量 使用final修饰的变量 - 常量 - 不可改变的量 语法 1final 数据类型 变量 [= 初始值]; 123456789101112131415161718192021222324252627282930313233343536373839404142434445package tech.aistar.day02;/** * 本类用来演示: 局部变量和全局变量 * * @author: success * @date: 2021/7/16 10:04 上午 */public class LocalVarAndGlobalDemo &#123; //定义全部变量 static int c = 100;//静态变量 - 暂不了解 public static void main(String[] args) &#123; //代码块 //局部变量 - 定义在方法体内部 int a= 10; &#123;// 使用的范围就是在它所在的最近的那个&#123;&#125;中 int b = 20; System.out.println(a);//ok System.out.println(b);//ok &#125; //使用的范围就是在它所在的最近的那个&#123;&#125;中 //System.out.println(b);//error //访问全局变量 System.out.println(c); //定义一个常量 - 不可改变的量 final int s = 100; //s = 200; //final - b肯定不可变 final byte b = 100; byte result = b + 1;//ok &#125;&#125; 运算符算术运算符12345678910111213141516171819201. + java语言中唯一重载[具有多个意义]的运算符 数值之间表示的加法运算,如果出现了&quot;字符串&quot;,表示拼接[后面就会知道拼接效率很低] 2. - 减法 * 乘法 3. / 除法[配合计算过程中需要注意的结果的类型而已] - 取整 4. % 取余/模 /和%结合使用,可以获取某个数字任意位上的数值. 5. += -= *= /= %= 未来知道:开发中尽量不要使用,不是一个原子操作,导致多线程不安全. 底层会判断是否需要进行一个类型的窄化操作[类型的强制转换操作] 6. ++和-- 前++/后++ - 变量本身都会自增1 前--/后-- - 变量本身都会自减1 未来知道:开发中尽量不要使用,不是一个原子操作,导致多线程不安全. 底层会判断是否需要进行一个类型的窄化操作[类型的强制转换操作] 比较运算符12&gt; &lt;= &gt;= &lt; !=比较得到的结果是一个boolean类型即可 逻辑运算符 &amp;&amp; - 逻辑与,短路与.作用不是用来进行计算的,而是用来连接条件[多个,条件表达式(包含比较运算符)]的. 为true - 所有的条件表达式都是返回true 短路的特性:当左边的条件表达式已经能够决定整个结果了,那么后面的条件表达式将不会执行. 推荐:将条件表达式结果最有可能为false的放在最左边 - 提高代码的执行效率. || - 逻辑或,短路或.作用不是用来进行计算的,而是用来连接条件[多个,条件表达式(包含比较运算符)]的. 为true - 只要有一个表达式是true,那么结果就是true 短路的特性:当左边的条件表达式已经能够决定整个结果了,那么后面的条件表达式将不会执行. 推荐:将条件表达式结果最有可能为true的放在最左边 - 提高代码的执行效率. ! - 逻辑非,true成为false,false成为true 位运算符 &amp; - 按位&amp;,非短路与,最主要的作用就是用来计算的,但是可以用来连接条件表达式. ​ 计算:都是1,结果才是1.只要出现1个0,那么结果就是0 ​ 连接条件:为true - 所有的条件表达式都是返回true 1234567891011121310 &amp; 8 = 8 十进制的数不断除以2,直到商为0,然后倒过来取余数 - 101010 / 2 = 商5......余05 / 2 = 商2 ...... 12/ 2 = 1 ........ 01/2 = 0 .........1 1 0 1 0 &amp; 1 0 0 0------------------ 1 0 0 0 -&gt; 对应的十进制8 | - 按位或,非短路或,最主要的作用就是用来计算的,但是可以用来连接条件表达式. 计算:只要存在一个1,结果就是1 连接条件:为true - 只要存在一个条件表达式为true. 123456710 | 8 = ? 1 0 1 0| 1 0 0 0------------------ 1 0 1 0 -&gt; 对应的十进制10 异或^ 作用:进行计算的 - 相同为0,不同为1 12345610 ^ 8 = 2 1 0 1 0 | 1 0 0 0------------------ 0 0 1 0 -&gt; 2 10 ^ 8 ^ 8 = 10 12340 0 1 0 1 0 0 0----------------- 1 0 1 0 -&gt; 10 结论:一个数字连续异或同一个数字俩次结果是它本身. 可以进行加密和解密的操作 123456789101112131415161718192021222324252627282930313233343536373839404142笔试题: 交换俩个变量的值,不允许出现第三方变量package tech.aistar.day02; /** * 本类用来演示: 笔试题: 交换俩个变量的值,不允许出现第三方变量 * * @author: success * @date: 2021/7/16 11:09 上午 */public class ChangeVarValue &#123; public static void main(String[] args) &#123; //1. 使用第三方变量 int a = 10; int b = 20; int temp = a; a = b; b = temp; System.out.println(&quot;a:&quot;+a); System.out.println(&quot;b:&quot;+b); //一个数字连续异或同一个数字俩次结果是它本身. int m = 100; int n = 200; m = m ^ n;//m = 100 ^ 200 n = m ^ n;//n = 100 ^ 200 ^ 200 = 100 m = m ^ n;//m = 100 ^ 200 ^ 100 = 200 System.out.println(&quot;m:&quot;+m); System.out.println(&quot;n:&quot;+n); //自创写法(success独家的) - 不推荐写 - 防止菜鸟看不懂 int x = 100; int y = 200; //y = 100 ^ 200 ^ 200 = 100 y = x ^ (x = y) ^ y; System.out.println(&quot;x:&quot;+x); System.out.println(&quot;y:&quot;+y); &#125;&#125; 取反~,1变0,0变成1 补码 - 负数在计算机中的表现形式就是以补码的形式存在的 123456789101112131415161718192021222324252627282930补码 = 反码 + 1;反码 = 原码符号位不变,其余位依次取反符号位 - 最高位代表的是符号位.1代表的是负数,0代表的是正数.反码本身没有意义的,它的存在就是为了计算补码正数的补码,反码,原码都是它本身.计算一下:-10的二进制是多少?-10的补码是多少?计算步骤:1. -10原码 10000000 00000000 00000000 000010102. -10的反码 10000000 00000000 00000000 00001010 11111111 11111111 11111111 111101013. -10的补码 = 反码+1 11111111 11111111 11111111 11110101 + 1 ------------------------------------- 11111111 11111111 11111111 11110110 -&gt; -10的二进制计算~900000000 00000000 00000000 0000100111111111 11111111 11111111 11110110 -&gt; ~9取反的结果-10 = ~9结论:-(x+1) = ~x 移位操作 笔试题 - 计算性能最高的操作,jdk源码里面很多都是移位操作 12345678910111213141516171819&lt;&lt; 向左移动2&lt;&lt;2 =&gt; 0010 &lt;&lt; 2 = 1000 = 8原题:请你用最高性能的方式计算出2的3次方.&gt;&gt; 带符号的右移动,向右移动多少位,那么就在最高位补符号位-10 &gt;&gt; 2 = -311111111 11111111 11111111 11110110 &gt;&gt; 211111111 11111111 11111111 11111101 -&gt; 负数的二进制,最高位是100000000 00000000 00000000 00000010 取反 ~2=-3&gt;&gt;&gt; 不带符号的右移动,向右移动多少位,就在最高位补0 -10 &gt;&gt;&gt; 2 11111111 11111111 11111111 11110110 &gt;&gt; 2 00111111 11111111 11111111 11111101 -&gt; 计算出十进制 01000000 00000000 00000000 00000000 - 3----------------------------------------- 1073741821 练习-15&gt;&gt;2 -15&gt;&gt;&gt;2 -15 = ~14 11111111…… 0001 &gt;&gt;&gt; 2 00111111 11111111 11111111 11111101 00111111 11111111 11111111 1111100 = 1073741820 方法 - Method 非常重要,如果没有跟上,直接出局. 相当于其他语言中函数function,功能是用来封装代码的逻辑. 把一段代码封装到方法中,方便以后复用,提高了代码的可维护性. 语法1234修饰符 返回类型 方法名([参数列表]) [throws 可抛出的异常列表]&#123;..方法体...&#125;现阶段:修饰符 返回类型 方法名([参数列表])&#123;..方法体...&#125; 修饰符访问修饰符 作用:就是决定了这个方法可以被调用的范围. public - 公开的,公共的.如果一个方法被public进行了修饰,那么代表这个方法可以在别的地方被调用. private - 私有的,只能在当前类内部被调用 - 体现了”封装性” - 不对外公开的. 默认的 受保护的 特殊修饰符[超纲的内容] static - 静态的 如果使用static修饰的方法 - 静态方法 如果没有使用static修饰的方法 - 非静态方法 是否为静态的方法决定了这个方法被调用的方式. 返回类型 有返回类型 可以是八种基本数据类型,也可以是对象类型[内置对象类型或者自定义对象类型] 方法体的最终的出口一定有return 返回值. 12345678return 作用1 - 返回方法最终的执行结果 作用2 - 用来结束整个方法正常情况方法的返回类型是什么,返回值的结果的类型也应该是什么非正常情况 - 支持类型的自动转换和强制类型转换的.调用的时候 - 需要使用数据类型和变量来接受这个方法调用的结果. 方法的返回类型是什么,就用什么类型去定义.当然也是支持类型的转换 无返回类型 - void 1不需要使用return + 返回值; 该如何选择? 如果某个方法的执行结果可能在另外一个地方被使用到,那么一定要定义成有返回类型 如果一个方法仅仅是为了输出,只要定义void 12public static int test01(int m,int n)&#123; //code... return m和n的最大公约数 //System.out.println(公约数) } //int m = test01(20,12);//m-&gt;4 public static int test02(int m,int n){ int 公约数 = test01(m,n); return mn/公约数; } int n = test02(20,12);//n-&gt;60=2012/4=60 1 方法名 参考变量名的命名规则 - 一模一样 标识符 - 给类,包,变量,方法取的名称 参数列表 无参列表 带参列表 可变长列表 该如何定义方法 方法体内部不能够再去定义方法了 main方法仍然是程序的主入口. 自定义的方法希望能够被调用,那么最终肯定是在main方法中进行调用的 方法的调用方式 取决于这个方法是静态的还是非静态的 - static 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253package tech.aistar.day02.method;/** * 本类用来演示: 方法的定义 * * @author: success * @date: 2021/7/16 2:20 下午 */public class MethodHelloDemo &#123; /** * main - 仍然是程序的主入口 * @param args */ public static void main(String[] args) &#123; //类中的方法 - 类里面的成员 //static - 静态的成员被初始化的时机 //静态方法什么时候被初始化的? - 当JVM加载类进内存的时候,就会立即给所有的静态的成员分配空间以及初始化 //在这个阶段,压根就没有对象的概念,只有类. //结论 - 静态的成员属于类的,并且初始化的时机有且1次. //属于谁,就由谁去调用! //1. 调用静态的方法,直接通过类.方法名([参数]) //类 - 该静态方法所在的当前类 MethodHelloDemo.sub(); //non-static -&gt; 非静态的成员被初始化的时机? //当遇到创建对象的语法.每次创建对象的时候,都会给各自的非静态成员分配空间以及初始化 //如果没有创建对象,就不会初始化这些非静态成员. //结论: 非静态成员是属于对象的.属于谁,由谁调用. //2. 非静态方法 - 通过对象去调用 //调用哪个类中的方法,就去创建哪个类的对象 //后面的OO知识点 -&gt; 类名 变量 = new 类名(); //创建了一个 MethodHelloDemo对象,m就是对象名 MethodHelloDemo m = new MethodHelloDemo(); m.add(); &#125; /** * 定义了公开的非静态的无返回类型的方法 */ public void add()&#123; System.out.println(&quot;add...&quot;); &#125; /** * 定义了公开的静态的无返回类型的方法 */ public static void sub()&#123; System.out.println(&quot;sub...&quot;); &#125;&#125; 静态方法中只能够直接调用静态方法 非静态方法中可以直接调用非静态方法以及静态方法 通用的原则 - 类名.静态方法或者对象.非静态方法 静态方法属于类拥有的,非静态方法属于对象拥有的 静态的方法是jvm加载类进内存的时候就会立即被分配空间以及初始化,并且机会仅仅只有1次. 而非静态方法必须是等到创建对象的时候,才会被分配空间以及初始化 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475&gt;package tech.aistar.day02.method;&gt;/**&gt;* 本类用来演示:&gt;*&gt;* @author: success&gt;* @date: 2021/7/16 2:43 下午&gt;*/&gt;public class StaticDetailDemo &#123; //定义了全局变量 //属性,方法 =&gt; 成员 //非静态的属性 int n = 10;//等创建对象的时候,才会分配空间和初始化 //静态属性-初始化的时机优先于静态方法 static int m = 100; public static void main(String[] args) &#123; //此时n还未初始化 //System.out.println(n);//编译错误 //System.out.println(m); //调用test03 - 非静态的 StaticDetailDemo s = new StaticDetailDemo(); s.test03(); System.out.println(s); &#125; //非静态的 public void test01()&#123; System.out.println(&quot;test01..&quot;); &#125; //静态的 public static void test02()&#123; int n = 10; System.out.println(&quot;test02...&quot;); //自定义的方法中是可以调用自己自定义的方法的 //1. 另外一个静态方法test04 StaticDetailDemo.test04(); //静态方法中可以直接调用静态方法 test04(); //2. 另外一个非静态方法test03 StaticDetailDemo s1 = new StaticDetailDemo(); s1.test03(); &#125; public void test03()&#123; //static int n = 20;//非静态方法中不允许定义静态的局部变量 System.out.println(&quot;test03..&quot;); //非静态方法中调用静态方法 - 类名.方法 //StaticDetailDemo.test04();//ok test04();//ok //非静态方法中直接调用另外一个非静态方法呢??? - 肯定是需要一个对象去调用. test01();//ok //实际上省略了一个关键字this //this代表的是当前对象 //当前对象 - 调用该方法[test03]的对象 //this.test01(); System.out.println(this); &#125; public static void test04()&#123; System.out.println(&quot;test04..&quot;); &#125;&gt;&#125; 方法调用补充 方法的调用者和方法的定义者在同一个类中. 方法的调用者和方法的定义者不在同一个类中,但是仍然在同一个package中. 只能使用通用的原则类名.静态方法或者对象.非静态方法 方法的调用者和方法的定义者是存在于不同包下的不同类中. 必须先通过import关键字进行导包操作. 使用jdk中的类的时候,除了java.lang包下的不需要手动import,其余包下的都需要先import 递归算法 - 错误的写法 - 方法内部直接调用自己 private 和 public 该选择使用123456789101112131415161718192021222324252627public class 牛叉的工具类&#123; public static void 牛叉的方法01()&#123; //肯定是会被外面的人调用的... //内部的代码的业务逻辑非常负责,由很多小的功能组成的 小的牛叉方法01(); //... //.. //... &#125; private static void 小的牛叉方法01()&#123; //专门封装了小的功能. &#125; public static void 牛叉的方法02()&#123; //肯定是会被外面的人调用的... //内部的代码的业务逻辑非常负责,由很多小的功能组成的 小的牛叉方法01(); //... //... //... &#125;&#125;","categories":[{"name":"java","slug":"java","permalink":"http://example.com/categories/java/"}],"tags":[{"name":"java","slug":"java","permalink":"http://example.com/tags/java/"}]},{"title":"java开发历史+数据类型","slug":"java001","date":"2021-07-15T12:58:04.000Z","updated":"2021-07-31T03:11:53.446Z","comments":true,"path":"2021/07/15/java001/","link":"","permalink":"http://example.com/2021/07/15/java001/","excerpt":"","text":"Java的历史 原先是属于SUN公司[Standford University Network 斯坦福网络大学] Sun Microsystem -太阳微电子公司 后来在2010年10月份被Oracle公司[出名的产品 -oracle数据库 - NO.1] 74亿美金收购 - www.oracle.com 前身Oak语言[橡树]，印度尼西亚的爪哇岛[咖啡豆 - javabean] 诞生于1995年5月23日，96年正式推出jdk1.0版本 商用的jdk版本 - jdk8.x，jdk11.x，jdk16.x java之父-james gosling 詹姆斯 高斯林 Java支持的三个平台原先的名称j2se，j2ee，j2me JavaSE - Java Standard Editional - Java标准版 适合做桌面应用程序[维护比较麻烦,服务器端如果更新,客户端需要更新],包含了java里面的基础的语法,核心 JavaEE - 2018年 - JakartaEE - 雅佳达EE - Java Enterprise Editional - Java企业版 是一套技术的规范的体系.不是一门具体的技术.里面包含了13种核心技术 比如jdbc,servlet等遵守javaee的规范.现在javaee里面的核心技术已经使用不多了 现在普遍都在使用spring全家桶中的技术. 适合做web应用程序[web网站] JavaME - Java Micro Editional - Java微型版,适合做手持设备 - “不用” 检测JDK的环境变量是否配置成功12345C:\\Users\\ASUS&gt; java -version java version &quot;1.8.0_66&quot;Java(TM) SE Runtime Environment (build 1.8.0_66-b17)Java HotSpot(TM) 64-Bit Server VM (build 25.66-b17, mixed mode) 环境变量的配置 Java.zip - 解压缩 - 比如放在D盘 所有的软件不要放在中文目录下,不要放在带有特殊符号的目录下[programe files(x86)] 尽量不要放在C盘[权限的问题,拒绝你的访问的] 桌面 - 右击计算机 - 属性 - 高级系统设置 - 环境变量(N) - 定位到系统变量 新建 变量名:JAVA_HOME 变量值:jdk1.8.0_66的绝对路径 确定 找到内置的变量名Path - 编辑 - 新建 %JAVA_HOME%\\bin 关闭刚所有打开的设置窗口,重新打开终端[黑窗口] win+r - cmd -&gt;输入 java -version Java语言特点 简单 可移植性 面向对象 - 核心 与平台无关性 [跨平台性，跨操作系统平台] 安全性 - 本身就是属于强类型的语言，在编译期间就要确定数据的类型。 JDK 和 JRE 和 JVM JDK - Java Development Kit - Java开发工具包,针对于开发者的.包含了很多开发工具 比如java.exe , javac.exe, javadoc.exe , jar.exe等 JDK中是包含JRE的 JRE - Java Runtime Enviroment - Java运行时环境,包含了很多核心的内库. 针对于使用java语言开发出来软件的用户.如果一个用户仅仅想运行一个java程序的话 那么计算机中只需要安装jre即可. JRE包含JVM JVM - Java Virtual Machine - Java虚拟机 - 后期重点详细介绍jvm[笔试的大头 - 内存模型] jvm本身就是用C语言编写的 - jvm的源码通读一遍. java程序并不是直接在计算机中进行跑的.而是在虚拟机上执行的.虚拟机是安装在操作系统上的. 注意的是java语言是跨平台的[使用java语言编写的程序可以运行在不同的os上],但是jvm不是跨平台的 不同的操作系统需要安装不同的jvm HelloWorld程序 java的基础单元是类class 类的命名 - 标识符的命名 只能由字母,数字,下划线,$符号组成,但是不能以数字开头 推荐使用”大驼峰”命名规则,单词首字母必须要大写.其余单词小写 不能是jdk中内置的对象类型[String,System] 不能是java中的一些关键字,关键字[java语言赋予了这些单词具备一定的语法含义] byte,short,int,long,float,double,char,boolean,if,for,else,while,break,continue,class, public,private,protected等 不能是java中的保留关键字 - goto,const 不推荐使用中文,防止出现乱码问题. 不推荐使用中文的拼音 推荐见名知意 代码 在D盘根目下新建一个文件HelloWorld.java java的源文件就是以.java为后缀的文件 记事本打开HelloWorld.java文件 12345678910111213141516171819//编程语言中,只要出现了符号,一定必须都是英文输入法下的//整体的结构//java是以类作为基础的单位的 - 定义类//关键是class//类的名称要和文件的名称高度保持一致//&#123;&#125; - block - 块 - 代码块public class HelloWorld&#123;//1. 类 //规范 - 缩进四个空格 //定义一个main方法 - 程序的&quot;大门&quot; //运行该程序的时候,jvm就会自动寻找main方法,然后进入到这个main //方法中去执行 //今天先记住语法 public static void main(String[] args)&#123;//2. 方法 //方法体,现阶段代码一定是放在方法体内部的. //jdk中提供了内置的对象[拥有一些功能],提供好了,开发者就可以直接使用 //java.lang.System类 - 向控制台输出一句话 System.out.println(&quot;HelloWorld&quot;);//3. 具体的程序 &#125;&#125; java源代码是不能够直接执行的.因为计算机是不识别java语言程序的. 需要对.java为后缀的源文件进行一个编译操作.如果一旦语法发生了问题,都会导致编译失败. 假设HelloWorld.java文件是放在D盘根目录下,需要打开终端,然后通过dos命令进入到D盘 12C:/User/admin&gt;d:D:/&gt;javac HelloWorld.java 效果,javac.exe工具其实就是在调用jdk中的编译器,作用:就是.java源文件编译成.class字节码文件 思考如何运行一个java程序呢? 利用java.exe 1D:/&gt;java HelloWorld 过程 编写.java源代码 javac.exe - 编译 java.exe - 执行 Java程序的执行的原理 12345678.java源文件 -&gt; 经过jdk中的编译器,成为.class字节码文件 -&gt; 经过jvm中的解释器[进行逐行翻译(解释)]-&gt; 机器能够识别的符号java属于解释型的语言,&quot;JVM把它YY成以.class字节码为指令的CPU&quot;编译型语言 - C语言,将这个语言编写的程序直接编译成计算机能够执行的程序.比如C语言写的代码可以直接编译成可执行文件 xx.exeC语言执行的性能高于java语言(每次执行都会经过jvm解释器进行解释) 集成开发环境 eclipse[日食] - 免费的,IBM公司的产品[收购SUN公司的] idea - 最好的,收费的 d:/aistar/j03s_student Java中的包-package 包是用来管理类的.包的本质就是一个文件夹.包对于类的作用相当于文件夹对于文件的作用. 包的命名规则 2-1. 推荐全部采用小写字母,如果出现多个单词,请你用.隔开,.隔开的每个部分都是一个目录 2-2. 包的命名推荐采用公司的域名倒置[唯一性] + 项目代号 ​ com.baidu.car tech.aistar 2-3. 不用采用java或者javax开头 - 因为jdk中的内置的类和拓展的类都是在java或者javax包中. 一旦创建了package,需要在类文件的首行采用package关键字来声明包. java中三种注释 单行注释 // ctrl+/ 添加/取消注释 多行注释 12345/* * * 多行注释的内容 - 注释的内容是不会经过jdk的编译器的 * */ 文档注释 可以生成文档树 123456/*** 放在类上面* 放在方法上**/ main方法细节12345678910public[公开的,公共的] static[静态的] - 都是属于后期学习OO中的修饰符修饰符在使用的时候,之间是没有顺序的.public static void main(String[] args)&#123;...&#125; //okstatic public void main(String[] args)&#123;...&#125; //ok//jdk8中方法的参数支持可变长参数public static void main(String... args)&#123;...&#125; //ok//args - 我们传给虚拟机的参数 输出语句 System.out.println(); // 换行 1System.out.print(&quot;\\n&quot;); \\n和\\r 1234567891011121314151617181920212223242526package tech.aistar.day01; /** * 本类用来演示: \\n \\r * * @author: success * @date: 2021/7/15 3:18 下午 */public class NrDemo &#123; public static void main(String[] args) &#123; //相当于是System.out.println(&quot;hello&quot;); System.out.print(&quot;hello\\n&quot;);//输出之后不换行 System.out.println(&quot;world&quot;); // \\n - 当输出完毕之后,光标停在下一行的起始位置 - 换行 // \\r - 当输出完毕之后,光标停在当前行的起始位置 回车 // \\n\\r 诞生的场景就是早期的打字机 //外面的终端执行的结果是 - veyy √ //伪终端显示的结果是 - ve System.out.println(&quot;Loyy\\rve&quot;); &#125;&#125; 特殊字符 \\ 是代表转义字符 \\n - 当输出完毕之后,光标停在下一行的起始位置 - 换行 \\r - 当输出完毕之后,光标停在当前行的起始位置 回车 \\b - 退格 \\t - 制表符,相当于tab键,默认是空4格 双引号 1\\&quot; 单引号 1\\&#x27; 单个\\ 1\\\\ 123456789101112131415161718192021222324252627282930package tech.aistar.day01;/** * 本类用来演示: 特殊字符 * * @author: success * @date: 2021/7/15 3:35 下午 */public class SignDemo &#123; public static void main(String[] args) &#123; //\\b - 退格 System.out.println(&quot;xxx\\byy&quot;);//xxyy //\\t - 制表符,相当于tab键,默认是空4格 System.out.println(&quot;hello\\tworld&quot;); //输出 james:&quot;success is good boy&quot; //双引号 System.out.println(&quot;james:\\&quot;success is good boy\\&quot;&quot;); // \\ 转义含义 //单个\\ System.out.println(&quot;D:\\\\temp\\\\news&quot;); //输出\\\\ System.out.println(&quot;\\\\\\\\&quot;); &#125;&#125; 变量 编程的核心就是从定义变量开始 java语言是一个强类型的语言[在编译期间必须要确定好数据的类型],javascript弱类型的语言 变量的本质 - “内存中某块区域的名称”,编程的任务就是对数据进行crud+数据分析的操作. 但是前提是数据需要先进行存储[内存,磁盘(文件,db数据库) - JVM内存 “JVM对字节码文件进行解释的前奏工作 - 把这个字节码文件加载到自己的内存中,java只能操作内存中的数据” java中是如何定义和存储简单的这些数据呢? 就是通过数据类型以及变量来定义和存储的. 数据类型 java中的数据类型有两大块 基本数据类型(8种) - 编程思想中将void归纳为第9种 数据类型决定了存储数据的这块空间的大小,并且这个大小一旦确定了,将不能够改变了. 对象类型(无数种) 2-1. 内置对象类型 - System,String - Jdk中提供的类 2-2. 自定义对象类型 - 自己定义的那些类HelloWorld,SignDemo 八种基本数据类型 名称 大小 范围 默认值 byte 字节 占1个字节8bit -128~127 0 short 短整型 占2个字节16bit -2^15~2^15-1 0 int 整型 占4个字节32bit -2^31~2^31-1 0 long 长整型 占8个字节64bit -2^63~2^63-1 0 float 单精度浮点数 占4个字节32bit +-(3.4*10^38) 0.0 double 双精度浮点数 占8个字节64bit +-(1.798*10^308) 0.0 char 字符 占2个字节16bit 0~65535 ‘\\u0000’空格 boolean 布尔类型 占1个字节8bit true/false false 变量的定义 变量的命名的规范请你参考类的命名规范,除了类的命名采用的”大驼峰”,而变量命名采用的是”小驼峰” “小驼峰” - 首字母小写,其余每个单词的首字母大写.比如studentAge 语法 1数据类型 变量名 [= 变量值]; 剖析变量的背后12345678910111213141516171819202122232425262728293031323334353637383940package tech.aistar.day01;/** * 本类用来演示: 变量入门 * * @author: success * @date: 2021/7/15 3:43 下午 */public class VarDemo &#123; public static void main(String[] args) &#123; //数据类型 变量名 [= 变量值]; byte b = 10; //代码的背后 - 埋了个&quot;种子&quot;,&quot;发芽&quot; //1. 数据肯定是存储在JVM内存中的 //2. 定义在方法内部的变量 - 局部变量[JVM的栈区] //3. 局部变量的生命周期是伴随着方法(main)的调用的开始和结束 //讲解的本质 //流程 //1. JVM加载VarDemo.class到内存 //2. JVM找到main方法想要去执行里面的程序 //3. 此处需要申请一块区域来保存数据10 // 3-1. 区域的大小由前面的数据类型来决定的 - int类型 - 区域4个字节32bit的大小 // 3-2. 栈里面的区域的大小一旦被确定了,就不能改变 - 肯定有的时候会有内存的浪费 // 3-3. 虽然空间浪费了,但是读取的效率会提高 - 典型的&quot;以空间换时间&quot; //4. 只要是内存中的空间,这个空间必然会有一个地址,所以变量的存在是为了给这个区域取了个名字 // 变量是为了方便用户来通过它访问到这个空间中存储的具体的那个值的 //把整数10赋值给一个int类型的变量a int a = 10; System.out.println(a); // == 比较的就是&quot;坑 - 区域&quot;里面存储的数据 System.out.println(b == a);//true &#125;&#125; 数据类型的转换 常识规定 a. java中看到一个整数,默认就是int类型 b. java中看到一个小数,默认就是double类型 c. 大的数据类型和小的数据类型进行计算的时候,计算得到的结果是偏向类型大的一方. 自动转换 小的数据类型可以自动转换成大的数据类型. byte-&gt;short-&gt;int-&gt;long char-&gt;int int-&gt;double 强制类型转换 大的数据类型转换成小的数据类型的时候,需要进行强制类型转换的操作 123MaxType 变量1 = 值1;MinType 变量2 = (MinType)变量1; 隐式转换","categories":[{"name":"java","slug":"java","permalink":"http://example.com/categories/java/"}],"tags":[{"name":"java","slug":"java","permalink":"http://example.com/tags/java/"}]}],"categories":[{"name":"集合框架","slug":"集合框架","permalink":"http://example.com/categories/%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/"},{"name":"字符串","slug":"字符串","permalink":"http://example.com/categories/%E5%AD%97%E7%AC%A6%E4%B8%B2/"},{"name":"设计模式","slug":"设计模式","permalink":"http://example.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"Interview","slug":"Interview","permalink":"http://example.com/categories/Interview/"},{"name":"java","slug":"java","permalink":"http://example.com/categories/java/"}],"tags":[{"name":"java","slug":"java","permalink":"http://example.com/tags/java/"},{"name":"Interview","slug":"Interview","permalink":"http://example.com/tags/Interview/"}]}