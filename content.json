{"meta":{"title":"I flourish in the killing value, just like in the dawn","subtitle":"","description":"","author":"SuperLv","url":"http://example.com","root":"/"},"pages":[{"title":"404 Not Found：该页无法显示","date":"2021-07-12T08:00:25.901Z","updated":"2021-07-12T08:00:25.901Z","comments":false,"path":"/404.html","permalink":"http://example.com/404.html","excerpt":"","text":""},{"title":"","date":"2021-07-31T01:41:59.528Z","updated":"2021-07-31T01:41:59.527Z","comments":true,"path":"manifest.json","permalink":"http://example.com/manifest.json","excerpt":"","text":"{\"name\":\"string\",\"short_name\":\"Junzhou\",\"theme_color\":\"#49b1f5\",\"background_color\":\"#49b1f5\",\"display\":\"standalone\",\"scope\":\"/\",\"start_url\":\"/\",\"icons\":[{\"src\":\"images/pwaicons/36.png\",\"sizes\":\"36x36\",\"type\":\"image/png\"},{\"src\":\"images/pwaicons/48.png\",\"sizes\":\"48x48\",\"type\":\"image/png\"},{\"src\":\"images/pwaicons/72.png\",\"sizes\":\"72x72\",\"type\":\"image/png\"},{\"src\":\"images/pwaicons/96.png\",\"sizes\":\"96x96\",\"type\":\"image/png\"},{\"src\":\"images/pwaicons/144.png\",\"sizes\":\"144x144\",\"type\":\"image/png\"},{\"src\":\"images/pwaicons/192.png\",\"sizes\":\"192x192\",\"type\":\"image/png\"},{\"src\":\"images/pwaicons/512.png\",\"sizes\":\"512x512\",\"type\":\"image/png\"}],\"splash_pages\":null}"},{"title":"关于","date":"2021-07-12T08:00:25.905Z","updated":"2021-07-12T08:00:25.905Z","comments":false,"path":"about/index.html","permalink":"http://example.com/about/index.html","excerpt":"","text":"个人详细介绍"},{"title":"书单","date":"2021-07-12T08:00:25.905Z","updated":"2021-07-12T08:00:25.905Z","comments":false,"path":"books/index.html","permalink":"http://example.com/books/index.html","excerpt":"","text":""},{"title":"link","date":"2021-07-30T13:17:28.000Z","updated":"2021-07-30T13:17:48.294Z","comments":true,"path":"link/index.html","permalink":"http://example.com/link/index.html","excerpt":"","text":""},{"title":"友情链接","date":"2021-07-12T08:00:25.907Z","updated":"2021-07-12T08:00:25.907Z","comments":true,"path":"links/index.html","permalink":"http://example.com/links/index.html","excerpt":"","text":""},{"title":"Repositories","date":"2021-07-12T08:00:25.908Z","updated":"2021-07-12T08:00:25.908Z","comments":false,"path":"repository/index.html","permalink":"http://example.com/repository/index.html","excerpt":"","text":""},{"title":"categories","date":"2021-07-30T13:16:36.000Z","updated":"2021-07-30T13:16:36.999Z","comments":true,"path":"categories/index-1.html","permalink":"http://example.com/categories/index-1.html","excerpt":"","text":""},{"title":"tags","date":"2021-07-30T13:15:06.000Z","updated":"2021-07-30T13:15:06.376Z","comments":true,"path":"tags/index-1.html","permalink":"http://example.com/tags/index-1.html","excerpt":"","text":""},{"title":"分类","date":"2021-07-30T13:17:11.247Z","updated":"2021-07-30T13:17:11.247Z","comments":false,"path":"categories/index.html","permalink":"http://example.com/categories/index.html","excerpt":"","text":""},{"title":"标签","date":"2021-07-30T13:16:20.384Z","updated":"2021-07-30T13:16:20.384Z","comments":false,"path":"tags/index.html","permalink":"http://example.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"最终冲刺_09","slug":"最终冲刺-09","date":"2021-11-13T06:36:39.000Z","updated":"2021-11-13T07:59:10.532Z","comments":true,"path":"2021/11/13/最终冲刺-09/","link":"","permalink":"http://example.com/2021/11/13/%E6%9C%80%E7%BB%88%E5%86%B2%E5%88%BA-09/","excerpt":"","text":"一、Servlet的生命周期 init() 如果配置文件中的&lt;load-on-startup&gt;0&lt;/load-on-startup&gt;配置了0或者正数 意味着在启动Tomact的时候就会立即初始化该Servlet实例 并且利用该实例立即在调用init()方法 如果值一样，根据上下的配置顺序，如通过值不一样，数值越小，优先级越高 如果没有配置，当Servlet第一次被请求时，Servlet容器就会开始调用这个方法来初始化一个Servlet对象出来 这个方法只会执行一次 service() 每次请求Servlet时，该方法都会被调用 destory() 当要销毁Servlet时，Servlet容器就会调用这个方法 这个方法只会执行一次 完整的servlet生命周期流程： 加载web.xml文件 通过构造函数创建servlet对象 通过init方法初始化servlet 通过service，或者doGet、doPost提供服务 在重启或关闭时自动对servlet进行销毁 二、Post和Get的区别 get请求一般用于获取数据，post请求一般用于发送数据到后台使用 get请求的参数会放在url上，所以安全性比较低，post请求的参数会放在request.body中，比较安全 get请求会被缓存，post请求不会被缓存 get请求的地址长度有限制，post请求url理论上来说没有限制 get请求会被记录在浏览器的历史记录中，post不会 三、如何处理中文乱码1req.setCharacterEncoding(&quot;utf-8&quot;); 四、转发和重定向的区别 转发是发生在服务器端的跳转，重定向是发生在客户端的跳转 转发地址栏不会发生变化，重定向会发生变化 转发共享request作用域中的数据，重定向至少两次请求，不能获取request作用域中的数据 可以重定向到启发站点 补：转发是直接在服务器端跳转到新的地址，而重定向是将新的地址响应给客户端让它重新请求 五、cookie和session的区别 cookie保存的是字符串，session保存的是对象 Cookie数据存放在客户端，Session数据存放在服务器端，两者都是在服务器端创建 Cookie保存的数据不可以超过4KB（很多浏览器限制一个站点只能保存20个cookie） 建议将登录信息等重要信息放入session，其他信息如果需要保留，存在cookie。 session会在一定时间内保存在服务器上。当访问增多，会比较占用你服务器的性能考虑到减轻服务器性能方面，应当使用Cookie。 六、Cookie如何管理Session(Cookie的会话跟踪机制)诞生背景 Http协议是无状态的，每一次数据交互完毕之后都会断开连接，下一次请求服务器的时候，就会重新建立连接，但是下一次的连接无法得知上一次连接的信息 Cookie的会话跟踪机制 当第一次请求服务器或者访问页面的时候，服务器端就会创建一个Session以及此Session的唯一标识SessionID，然后创建Cookie，将这个SessionID放入到Cookie当中，伴随着响应头，将Cookie一起响应到客户端，并且保存到客户端当中。后续的请求，会将这个Cookie对象一起发送给服务器端，服务器会根据Cookie中保存的SessionID，通过ID来查找出对应的Session对象，从而达到可以找到上一次连接的对象 七、Http协议/HTTPS协议八、TCP三次握手网络七层物理层 - 数据链路层 - 网络[IP] - 传输层[TCP和UDP] - 会话层 - 表示层 - 应用层[HTTP] SYN：连接请求/接收 报文段 - 同步位 seq：发送的第一个字节的序号 ACK：确认报文段 ack：确认号。希望收到的下一个数据的第一个字节的序号 client和server一开始都是出于close状态 client自己想要建立请求 - 主动打开,server端被动打开的,然后server进入到listen监听状态. 第一次握手 客户端向服务端发送一个 SYN 报文（SYN = 1），并指明客户端的初始化序列号 ISN(x)，即图中的 seq = x[随机的]，表示本报文段所发送的数据的第一个字节的序号。此时客户端处于 SYN_Send 状态。 SYN-SENT ：在发送连接请求后等待匹配的连接请求 第二次握手 服务器收到客户端的 SYN 报文之后，检查SYN是否为1,当这个值必须是1的时候,才说明client还有建立请求的好意思. 会发送 SYN 报文作为应答（SYN = 1），并且指定自己的初始化序列号 ISN(y)，即图中的 seq = y。同时会把客户端的 ISN + 1 作为**确认号 ack 的值[第一次握手发送过来的seq的值+1]**，表示已经收到了客户端发来的的 SYN 报文，希望收到的下一个数据的第一个字节的序号是 x + 1，此时服务器处于 SYN_REVD 的状态。 第三次握手 客户端收到服务器端响应的 SYN 报文之后，会发送一个 ACK 报文，也是一样把服务器的 ISN + 1 作为 ack 的值，表示已经收到了服务端发来的的 SYN 报文，希望收到的下一个数据的第一个字节的序号是 y + 1，并指明此时客户端的序列号 seq = x + 1（初始为 seq = x，所以第二个报文段要 +1），此时客户端处于 Establised 状态。 为甚不能两次握手 client发送第一个请求①到server,但是由于网络不稳定,此次请求尚未到达server client发现server一直没有回复,再发一次请求②[第一次我握手,嗨,我要建立连接],第二个请求顺利到达server server和client进行第二次握手[好的,你建立吧]. client和server进行第三次握手[那好,我真的建立] 此时第一次请求慢吞吞的到达server了.[syn=1,seq=x],server会认为是一个新的请求过来了. server和client想要进行第二次握手ack=x+1[确认号] client分析ack不是自己的,直接忽略此次来自于server端握手. server就会一直处于等待状态. 九、HTTP状态码 分类 分类描述 举例 1** 信息，服务器收到请求，请求者继续执行操作 100：继续；101：切换协议 2** 成功，操作被成功接收并处理 200：请求成功；201：已创建；202已接收 3** 重定向，需要进一步的操作以完成请求 300：多种选择；304：未修改；305：使用代理 4** 客户端错误，请求包含语法错误或无法完成请求 404：服务器无法根据客户端的请求找到资源(网页)；405： 客户端请求中的方法被禁止 5** 服务器错误，处理请求的过程中发生错误 500： 服务器内部错误，无法完成请求；505：服务器不支持请求HTTP协议的版本，无法处理 十、三大作用域 Request：只作用于当前一次请求 Session：一次会话（多次请求） Application：项目的启动到结束 十一、HttpServletRequest / HttpServletResponse 作用HttpServetRequest：所有的请求的信息都封装到了这个对象中 HttpServetResponse：所有的响应给客户端的信息全部封装到这个对象中 十二、Filter和InterceptorFilter：过滤器，功能是对Servlet容器调用Servlet的过程进行拦截，从而在Servlet进行响应处理前后，实现一些特殊功能 Interceptor： 拦截器，用于在某个方法或字段被访问的前后，进行拦截，加入某些操作 Filter和Interceptor的区别 Filter是基于函数回调的，Interceptor是基于Java反射的 Filter依赖于Servlet容器，Interceptor不依赖于Servlet容器 Filter几乎所有的请求对起作用，Interceptor只能对action请求起作用 在action的生命周期里，Interceptor可以被多次调用，而Filter只能在容器初始化时调用一次 Interceptor可以访问Action的上下文，值栈里的对象，而Filter不能 十三、JSP的九大内置对象(解释理解) out：用于向客户端、浏览器输出数据 request：封装了来自客户端、浏览器的各种信息 response：封装了服务器的响应信息 exception：封装了jsp程序执行过程中发生的异常和错误信息 config：封装了应用程序的配置信息 page：指向了当前jsp程序本身 session：用来保存会话信息。也就是说，可以实现在同一用户的不同请求之间共享 application：代表了当前应用程序的上下文。可以在不同的用户之间共享信息 pageContext：提供了对jsp页面所有对象以及命名空间的访问","categories":[{"name":"面试+工作","slug":"面试-工作","permalink":"http://example.com/categories/%E9%9D%A2%E8%AF%95-%E5%B7%A5%E4%BD%9C/"}],"tags":[{"name":"最终冲刺","slug":"最终冲刺","permalink":"http://example.com/tags/%E6%9C%80%E7%BB%88%E5%86%B2%E5%88%BA/"}]},{"title":"最终冲刺_08","slug":"最终冲刺-08","date":"2021-11-11T08:49:30.000Z","updated":"2021-11-12T12:07:25.803Z","comments":true,"path":"2021/11/11/最终冲刺-08/","link":"","permalink":"http://example.com/2021/11/11/%E6%9C%80%E7%BB%88%E5%86%B2%E5%88%BA-08/","excerpt":"","text":"一、DDL,DCL,DML,DQL,DTL(TCL) DQL(Data Query Language) - 数据查询语言 - 也是整个sql的核心 - 最难的 select DML(Data Manipulation Language) - 数据操纵语言 insert update delete DDL(Data definition Language) - 数据定义语言 create alter drop DCL(Data Control Language) - 数据控制语言 grant[授权],revoke[取消权限] DTL(Data Transaction Language) - 数据事务语言 commit savepoint rollback 二、主键,外键,左连接,右连接主键 primary key - 非空且唯一 作用：用来确定唯一元组 外键 foreign key 外键列通常情况是引入另外一张表的主键列 左连接 left join 以左表为基准表，返回左表的所有记录，和右表中连接字段相等的记录，不相等的为null(在右) 右连接 right join 以右表为基准表，返回右表的所有记录，和左表中连接字段相等的记录，不相等的为null(在左) 三、DB,DBMS,RDBMS,DBS,DBA DB：数据库 DBMS：数据库管理系统 RDBMS：关系型数据管理系统————程序通过DBMS来访问操作DB DBS：数据库系统————DBA+DBMS+DB DBA：数据库管理员 四、事务事务是指一组相关的SQL操作,我们所有的操作都是处在事务中的,执行业务的基本单位不是sql,而是事务. 命令 begin - 标记事务的开始 commit - 提交事务 rollback - 回滚事务 save - 设置事务可以回滚到的保存点 事务的四大特性（ACID） 原子性（Atomicity）：事务不可再分割，要么同时成功，要么同时失败 一致性（Consistency）：事务一旦结束，内存中的数据和数据库中的数据是保持一致的 隔离性（Isolation）：多个用户并发访问数据库，事务之间相互独立，互不干扰 持久性（Durability）：事务一旦提交，则内存中的数据持久化到数据库中，永久保存 五、事务的隔离级别 读未提交[READ UNCOMMITED]事务最低的隔离级别,允许另外一个事务看到这个事务未提交的数据 读已提交[READ COMMITED]保证一个事务修改的数据提交后才能被另外一个事务读取,即另外一个事务不能读取该事务未提交的数据 可重复读[REPEATABLE READ] - mysql默认事务隔离级别 保证一个事务相同情况下前后两次读取的数据是一致的 串行化[SERIALIZABLE] 事务被处理为顺序执行,有点类似于锁表,但性能很低 事务隔离级别 脏读 不可重复读 幻读 读未提交 √ √ √ 读已提交 × √ √ 可重复读 × × √ 串行化 × × × 多事务并发问题 脏读 一个事务读取到了另外一个事务中尚未提交的数据 一个事务正在访问数据并且对数据进行修改,另外一个事务正在查询数据,查询的事务查询到了修改的事务修改了但还没提交的事务,修改的事务可能会回滚,导致查询的事务使用脏数据 不可重复读 一个事务多次读取同一条记录产生不同的结果 事务A正在读取数据库中的记录,事务B正在修改数据库的事务并提交,事务A在事务B提交前和提交后读取到的记录结果不同,导致原来的数据变成不可重复读的数据. 幻读 一个事务修改表中的多行记录,一个事务往表里插入记录,第一个事务查询时发现仍旧有未更新的记录(新插入的),好像出现了幻觉一样 不可重复读的重点是一个事务查一个事务修改,而幻读的重点是一个事务更新,一个事务插入. 六、编程式事务/声明式事务 编程式事务：通过编码的方式实现事务,导致事务和业务的代码耦合在一起,类似JDBC编程实现事务管理. 12345678910try &#123; ..... connection.setAutoCommit(false); ..... // 一连串SQL操作 connection.commit(); &#125; catch(SQLException) &#123; // 发生错误，撤消所有变更 connection.rollback(); &#125; 声明式事务： 建立在AOP之上,最大的优点是不需要通过编程的方式管理事务,不需要在业务逻辑代码中掺杂事务管理的代码,只需要在配置文件中做相关的申明,或通过@Transactional注解的方式就可以将事务规则应用到业务逻辑中. 七、Innodb和myisam的区别 Innodb支持事务，MyISAM 不支持 InnoDB 支持外键，MyISAM 不支持 InnoDB 支持行锁，MyISAM 支持表锁 在索引方面myisam和innodb有很大区别 myisam中索引文件和数据文件是分开的独立的两个文件,innodb中索引文件和数据文件合二为一,只有一个文件. myisam中的聚簇索引和非聚簇索引的方式都是一致的,叶子结点存储的是索引的值和索引文件物理行地址.innodb中的聚簇索引的叶子结点存储的是索引的值和行记录,非聚簇索引的叶子结点存储的是索引的值和主键的值 八、索引数据结构-演变过程二叉树 左子节点必须小于当前结点的键值 右子节点必须大于当前结点的键值 弊端：很有可能在极端的情况下产生一个链表结构的二叉树 平衡二叉树每个结点的左右子树的高度差不能大于1 弊端： 每个结点仅仅只存储一个键值和数据（每个磁盘块只存储一个键值和数据） 其实每次查询的时候，都是一次磁盘交互的情况，非常频繁 如果存储的数据很多，二叉树的结点将会很多，高度也会极高，导致比较的次数增多，多次与磁盘IO交互，查询效率低下 B树特点： 根结点【第一页】 — 永驻内存 每个结点保存更多的key和value - 会导致B树又矮又胖 B树的m阶 —– 看他 最大的子节点的个数就是m的值 每查找一次数据就需要从磁盘中读取一个结点，也就是我们说的一个磁盘块，读取的单位是页，每一页的大小是16KB，可以存储更多的key-value——把磁盘块中的一夜数据【16KB】加载进内存 页与页之间是一个链表的结构 B+树与b树的区别： B+树中非叶子结点仅仅只存储了key值，这样每一个非叶子结点都可以存储更多的key B+树索引的所有数据都放在了叶子结点上，而且是按照顺序存储的 页与页之间是一个双向链表，叶子结点中的数据是单向链表 聚簇索引以主键作为B+树索引的键值而构建的B+树索引 非聚簇索引以主键之外的列值作为B+树的键值而构建的B+树索引 聚簇索引和非聚簇索引的区别 区别就是非聚簇索引的叶子结点不是存储表中的数据，而是存储该列对应的主键列，想要查找数据还需再根据主键再去聚簇索引中进行查找，这个二次查找的过程称为回表 聚簇索引的叶子结点存储的索引列值和行记录 非聚簇索引的叶子结点存储的是索引列值和主键值 有一种查询非聚簇索引在查询时，首先查询到主键值，再根据主键值到聚簇索引中找到行记录,这个过程称之为回表 但是不一定会回表,如果查询的列就是索引列或者是主键列,就不需要回表 以innodb作为存储引擎的表,表中的数据都会有一个主键,即使不创建主键,系统也会创建一个隐式的主键. 九、索引失效场景或者条件/如何提高sql查询效率遵循最左原则简介:针对的是复合索引 - 查询语句where最左边的列一定要和创建复合索引的第一个列保持一致. 复合索引(a,b,c) - 必须要连续. a、ab、abc、 都走索引 ac、ca，ba(底层被优化)走a 必须遵循最左原则—找A 开始，无A则全部失效，以此类推（A后找B） 索引失效条件 范围之后索引列也会失效 12-- a列和b列是走了索引的,但是c列没有走索引.因为c列是范围之后的判断 ----特殊mysql&gt;explain select * from index_test where a=100 and b&gt;10 and c=&#x27;daa&#x27;; 模糊查询（%不是出现在末尾，有：%a，%a%） 123456789101112like &#x27;%&#x27;出现在末尾,仍然a,b,c都是走索引-- key_len = 73 - a,b,c都是走了索引的mysql&gt; explain select * from index_test where a=100 and b=10 and c like &#x27;d%&#x27;;-- like &#x27;%&#x27;如果出现在开始,不走索引的-- 只有a,b是走了索引的,c是没有走索引的-- key_len = 10 mysql&gt;explain select * from index_test where a=100 and b=10 and c like&#x27;%d&#x27;;-- 只有a,b是走了索引的,c是没有走索引的-- key_len=10mysql&gt;explain select * from index_test where a=100 and b=10 and c like&#x27;%d%&#x27;; 索引列使用函数 123索引列套在函数中使用,将会导致索引失效-- 进行了ALL全表扫描mysql&gt; explain select * from index_test where abs(id)=1; 索引列参加了计算 123-- 导致索引列失效mysql&gt; explain select * from index_test where id+1=2;mysql&gt; explain select * from index_test where id = 2 - 1; 索引列参加运算符 ——（有些情况下会失效） 123456789101112-- is null(没有走索引)和is not null(走索引)-- is null - type=&#x27;ALL&#x27;mysql&gt;explain select first_name,commission_pct from s_emp where commission_pct is null;-- is not null type=&#x27;range&#x27; - 走了索引的.mysql&gt; explain select first_name,commission_pct from s_emp where commission_pct is not null;-- in(走索引 - range) not in(不走索引 - ALL)mysql&gt; explain select * from index_test where id in(1,2,3);mysql&gt; explain select * from index_test where id not in(1,2,3); 在查询时使用or连接查询条件 mysql在使用!= &lt;&gt;的时候无法使用索引 建立索引的策略 索引不是越多越好,因为索引也是需要占用空间的,需要进行维护 推荐建立索引的列 主键列 唯一列 不经常改变的列【在update列数据的数据的时候,也会更新索引文件】 满足以上条件并且经常作为查询条件的列 不建议建立索引的列 重复值太多的列 null值太多的列 十、数据库的优化处理sql优化 尽量避免在 where 子句中使用!=或&lt;&gt;操作符 尽量避免在where子句中对字段进行not null值判断 尽量避免在where子句中使用or来连接条件 尽量避免在where子句中对字段进行表达式操作 尽量避免在where子句中对字段进行函数操作 不要在where子句中的“=”左边进行函数、算术运算或其他表达式运算 not in慎用 很多时候用exists代替in[查询性能很低]是一个好的选择 避免频繁创建和删除临时表，以减少系统表资源的消耗。 尽量避免大事务操作，提高系统并发能力。 数据库结构优化 范式优化 ———— 比如消除冗余（节省空间） 反范式优化 ————比如适当加冗余等（减少join） 拆分表 索引优化服务器硬件优化 这个么多花钱咯！ 十一、三大范式 保证列的原子性，不可在分割 所有的非关键列都依赖于关键列，不存在部分非关键列依赖关键列 所有的非关键列都直接的依赖关键列，不存在非关键列传递性的依赖于关键列 十二、 描述使用数据库连接池的优势与原理 优势：不用频繁的和db表进行交互，减少了内存的消耗 原理：建立一个连接池，在里面设置多了连接供用户去使用，可以分别设置他的最小连接数以及最大连接数，当用户去连接的时候，连接池里的连接数不够，连接池会自动放连接在里面，但不超过最大连接数，如果连接池里面空闲的连接比较多，连接池也会关闭几个连接，用户不可以自己手动关闭连接。主要有连接池与DB表进行对接，如果连接池的连接数已经达到最大连接，可以设置一个最大等待时间，这样可以告诉用户等待时间片长。用户使用完立即释放到连接池中供其他用户使用。 十三、悲观锁和乐观锁悲观锁总是假设最坏的情况,每次取数据都认为别人会修改,所以在每个操作上都进行上锁. Java的synchronized和reentrantlock等独占锁就是悲观锁. 乐观锁总是假设最好的情况,每次拿数据都认为别人不修改,所以不上锁,但是在更新的时候会判断一下在此期间有没有人去更新这个数据. 悲观锁和乐观锁的使用场景 悲观锁适用于写的情况比较多的场景. 乐观锁适用于读的情况比较多的场景. 乐观锁的实现方式版本号机制在数据表中加上一个版本号version字段,表示数据被修改的次数,当数据被修改时,version的值会加一. 假设现在同时有线程A和B对数据库的同一行数据进行操作,此时线程A读取版本号version=1然后进行数据更新,在线程A操作的同时线程B也读取版本号version=1并进行修改.线程A提交时先查看数据库的版本是否和自己读取的版本一致,发现是一致的,完成提交. CAS算法 - compare and swap(比较与交换)CAS算法是一种有名的无锁算法,即在不使用锁的情况下实现多线程之间的变量同步.它涉及到三个操作数 需要读写的内存位置V- 主存 需要进行比较的预期值A - 主存中V的旧值 需要写入的新值 首先拷贝一份读写的内存值 十四、truncate和delete,drop区别 truncate 表名 - DDL; delete from 表名 where… - DML delete删除可以rollback,truncate不能回滚[truncate效率更高] truncate不能操作视图,其他的都可以 十五、单行函数!日期函数 字符串转日期 日期转字符串 还有字符串啥的稍微看看 十六、group by / order by / 多行函数 / 组函数group by/order by 语法select 语句 where 语句 group by 语句 [having 组函数判断] order by 语句 order by默认是升序,asc是升序,desc是降序. 多行函数/组函数/聚合函数 count / avg / sum / min / max 十七、视图的定义和优点定义 视图是从一个或多个基本表中到处的虚表，数据库只存放视图的定义，我们通过视图所看到的数据其实仍然存放在基本表中 定义视图create view &lt;视图名&gt;[(&lt;列名&gt;[&lt;列名&gt;]…)]as &lt;子查询&gt;[with check option]; 12345create view &#x27;IS_Student&#x27;asselect Sno,Sname,Sagefrom Studentwhere Sdept = &#x27;IS&#x27; 优点 可以简化数据操作 使数据就有了一定的安全性 可以定制用户数据，聚焦特定的数据 适当的利用视图可以更清晰地表达语句 十八、存储过程的定义语法和优点存储过程的定义语法 创建存储过程 1234567-- 创建存储过程delimiter //create procedure 存储过程名([in|out] [参数列表])begin -- 过程体end //delimiter ; 调用存储过程 1call 存储过程名 删除存储过程 12-- 删除存储过程drop procedure 存储过程名; 优点 重复使用。存储过程可以重复使用，从而减少数据库开发人员的工作量 减少网络流量。存储过程位于服务器上，调用的时候只需要传递存储过程的名称以及参数就可以 安全性。参数化的存储过程可以防止SQL注入式攻击 十九、存储过程和函数的区别区别 存储过程中可以调用函数，函数中不可以调用存储过程 储存过程可以有返回值也可以无返回值，函数必须有返回值 函数的调用用select关键字,存储过程调用使用call关键字 储存过程可以输入输出参数，函数只可以输入参数 存储过程是用in来接受参数,out来返回结果. [存储过程和函数各记一个例子] 123456789101112131415161718-- 存储过程drop procedure if_pro;delimiter //create procedure if_pro(in a int)begin declare msg varchar(20) default &#x27;&#x27;; if a&gt;=90 then set msg = &#x27;优秀&#x27;; elseif a&gt;=80 then set msg = &#x27;良好&#x27;; else set msg = &#x27;及格&#x27;; end if; select msg;end //delimiter ;call if_pro(85); 123456789-- 函数drop function adds;delimiter //create function adds(a int,b int) returns intbegin return a + b;end //delimiter ; 二十、触发器在mysql中,当我们执行一些操作的时候[比如dml操作 - 触发器能够触发的事件],一旦事件被触发,就会执行一段程序 触发器的本质上就是一个特殊的存储过程 分类 after触发器 - 在触发条件之后执行 before触发器 - 在触发条件之前执行 前置触发器/后置触发器 1234567891011121314-- 语法-- 删除触发器drop trigger 触发器名称;-- 创建触发器delimiter //create trigger 触发器名称触发时机(after,before) 触发事件(insert,delete,update) on 触发器事件所在的表名for each row-- 触发器事件程序begin end //delimiter ; 二十一、如何自己使用mysql进行分页操作*limit (pageNow-1)pageSize,pageSize limit缺点 - 如果偏移量很大,性能就会降低. limit的优化 如果要优化limit查询的话，where条件中的字段一定要有索引 二十二、数据库的数据类型数值类型 tinyint 1 Bytes smallint 2 Bytes mediumint 3 Bytes int或者integer 4 Bytes bigint 8 Bytes float 4 Bytes double 8 Bytes decimal 对DECIMAL(M,D) ，如果M&gt;D，为M+2否则为D+2 日期和时间类型 类型 大小 ( bytes) 范围 格式 用途 DATE 3 1000-01-01/9999-12-31 YYYY-MM-DD 日期值 TIME 3 ‘-838:59:59’/‘838:59:59’ HH:MM:SS 时间值或持续时间 YEAR 1 1901/2155 YYYY 年份值 DATETIME 8 1000-01-01 00:00:00/9999-12-31 23:59:59 YYYY-MM-DD HH:MM:SS 混合日期和时间值 TIMESTAMP 4 1970-01-01 00:00:00/2038结束时间是第 2147483647 秒，北京时间 2038-1-19 11:14:07，格林尼治时间 2038年1月19日 凌晨 03:14:07 YYYYMMDD HHMMSS 混合日期和时间值，时间戳 字符串类型 类型 大小 用途 CHAR 0-255 bytes 定长字符串 VARCHAR 0-65535 bytes 变长字符串 TINYBLOB 0-255 bytes 不超过 255 个字符的二进制字符串 TINYTEXT 0-255 bytes 短文本字符串 BLOB（图片存储方式可以blog） 0-65 535 bytes 二进制形式的长文本数据 TEXT 0-65 535 bytes 长文本数据 MEDIUMBLOB 0-16 777 215 bytes 二进制形式的中等长度文本数据 MEDIUMTEXT 0-16 777 215 bytes 中等长度文本数据 LONGBLOB 0-4 294 967 295 bytes 二进制形式的极大文本数据 LONGTEXT 0-4 294 967 295 bytes 极大文本数据 mysql分组子查询[分组效率高] 二十三、约束的类型 default：默认约束 not null：非空约束 unique：唯一约束 primary key ：主键约束 foreign key ：外键约束 check：检查约束 auto_increment：自增长约束 zerofill：零填充约束 unsigned：无符号约束","categories":[{"name":"面试+工作","slug":"面试-工作","permalink":"http://example.com/categories/%E9%9D%A2%E8%AF%95-%E5%B7%A5%E4%BD%9C/"}],"tags":[{"name":"最终冲刺","slug":"最终冲刺","permalink":"http://example.com/tags/%E6%9C%80%E7%BB%88%E5%86%B2%E5%88%BA/"}]},{"title":"最终冲刺_07","slug":"最终冲刺-07","date":"2021-11-10T06:03:43.000Z","updated":"2021-11-12T03:14:44.978Z","comments":true,"path":"2021/11/10/最终冲刺-07/","link":"","permalink":"http://example.com/2021/11/10/%E6%9C%80%E7%BB%88%E5%86%B2%E5%88%BA-07/","excerpt":"","text":"一、什么是反射(定义)，反射的作用什么是反射 在运行状态中,对于任意一个类都能够知道这个类所有的属性和方法 对于任意一个对象,都能够调用它的任意一个方法 这种动态获取信息以及动态调用对象方法的功能称为Java语言的反射机制 作用 在运行时构建任意一个类的对象 在运行时判断任意一个对象所属的类型 在运行时判断任意一个类所具有的成员变量和方法 在运行时调用任意一个对象的方法，甚至可以调用private方法 二、class获取(三种)比如存在一个类Person Person person = new Person(); 第一种 12通过Object类的getClass方法Class&lt;?&gt; c = person.getClass(); 第二种 12通过对象实例方法获取对象Class&lt;?&gt; c = Person.class; 第三种 12通过Class.forName(全限定名)方式Class&lt;?&gt; c = Class.forName(&quot;stu.aistar.design.singleton.version03.Singleton03&quot;); 三、反射的优缺点优点 实现动态创建对象和编译，体现出很大的灵活性 提高了程序的灵活性和扩展性，降低耦合性，提高自适应能力 缺点 性能问题 使用反射基本上是一种解释操作，用于字段和方法接入时要远慢于直接代码。因此反射机制主要应用在对灵活性和扩展性要求很高的系统框架上，普通程序不建议使用 反射包括了一些动态类型，所以JVM无法对这些代码进行优化。因此反射操作的效率要比那些非反射低得多 四、反射的应用，反射在项目中的应用，谈谈对反射的理解 spring框架 JSP的动作 JSP useBean、get、set、 JDBC工具类 五、动态代理,jdk动态代理和cglib动态代理的区别 JDK动态代理——接口 CGlib动态代理——继承 首先理解一下什么是动态代理： 创建一个InvocationHandler的实例, 就是代理类对象, 负责接口方法的调用 通过Proxy.newInstance()创建一个目标类接口的实例, 他需要传入3个三参数 参数1: 加载器, (将目标类接口生成字节码加载进内存) 参数2: 目标类接口(用于生成字节码，也就是说$Proxy的生产仅仅需要接口数组就可以完成) 参数3: 代理类对象(用于回调invoke方法，实现方法的增强) 第一个参数其实并不是很重要, 他就是负责将目标类接口生成的字节码加载进内存, 然后反射调用构造方法,初始化创建$Poxy对象,将反射获取到的$Poxy对象返回.所以第二个参数这个目标类的接口才是关键 jdk和cglib动态代理的原理区别： java动态代理是利用反射机制生成一个实现代理接口的匿名类，在调用具体方法前调用InvokeHandler来处理。 而cglib动态代理是利用asm开源包，对代理对象类的class文件加载进来，通过修改其字节码生成子类来处理。 JDK动态代理和CGLIB字节码生成的区别？ JDK动态代理只能对实现了接口的类生成代理，而不能针对类 CGLIB是针对类来实现代理的，他的原理是对指定的目标类生成一个子类，覆盖其中的方法，实现增强 因为是继承，所以不能对final修饰的类进行代理。 六、注解开发和xml开发的区别 @interface @target //定义一个注解可以在哪里可以使用 区别 XML配置起来有时候冗长，注解是简化了XML配置 注解相对于XML是类型安全的，XML只能在运行期才能发现问题 xml配置可以让软件具有扩展性，注解缺乏灵活性 XML方式比注解的可扩展性和复杂性维护上好的多 七、JVM8.x和7.x区别 JDK8.x将永久代剔除了,取而代之的是元空间(meta space)（元空间里有方法区和常量池） HashMap 新增红黑树 函数式接口:指的是只有一个函数的接口，这样的接口可以隐式转换为Lambda表达式 Lambda表达式:它允许我们将函数当成参数传递给某个方法，或者把代码本身当作数据处理 引入了新的Date-Time API(JSR 310)来改进时间、日期的处理 堆空间中的新生代和老年代 新生代也可以细分为伊甸园，from和to区域（比例为8:1:1） 首先创建出来的对象会被放进伊甸园，后期GC会进行垃圾检测，把存活的对象放置到from区域，然后，GC会时不时的进行检查，把存活的对象用复制算法，复制到to区域，以此类推…如果有对象经过GC的检测超过15次，还是存活的，那么就会被放置到老生代当中（用来存放存活率较高的数据） 然后老年代也会被GC扫描–使用的是标记整理算法—把存活的对象放置到内存的一边，然后把剩余的空间清理掉。 jdk8之后拥有新生代和老年代新生代（Young Generation）占1/3堆空间 - 存活率低分为伊甸园(8/10)+from(1/10)+to(1/10)from - to 采用的是复制算法，需执行15次进入老年代老年代（Old Generation） 占2/3堆空间 - 存活率高标记整理算法 - 清除垃圾对象 - 把存活的对象移到内存的一端，然后把剩余的空间全部清空掉。 八、堆栈区别栈 存放的是基本数据类型和对象的引用 速度仅次于寄存器 创建程序的时候，Java编译器必须知道存放在栈中的数据的大小和生命周期 当程序执行的时候，就会创建一个栈帧，并且压栈，当方法执行完毕之后，栈帧出栈并销毁 堆 存放new出来的对象 在堆中存放的数据有很大的灵活性。你只要是new出来的对象，就会自动的在堆中分配一个空间进行存储 但是，也需要付出相应的代价，在堆中存储分配比在栈中需要更多的时间 堆中的数据是被所有线程共享的，在JVM中只有一个堆 栈和堆比较 栈和堆都是用来存储数据的地方 栈的优势：存取速度快，仅次于cpu中的寄存器。但是缺乏灵活性，存在栈中的数据的大小和生命周期必须是确定的 堆的优势：可以动态的分配内存大小，生命周期也不必事先告诉编译器。Java垃圾收集器会自动的处理一些不再使用的数据。缺点是运行期间分配大小，存取速度慢 九、GC垃圾回收机制程序的运行必然会申请内存资源，无效的对象如果不进行及时的处理 内存就会被一直占用，很有可能会导致内存的溢出，所以要进行内存资源的管理 为了让程序员更加关注于代码的实现，而不用过多的考虑资源的释放，内存的释放由系统自动识别完成，所以有了GC垃圾回收机制。如果有不合理的垃圾回收机制的算法也会导致内存溢出 垃圾回收机制—主要用来回收垃圾对象的 垃圾对象：没有任何引用指向的对象 对象搜索法 引用计数 给对象一个计数器，每当这个对象被引用的时候，计数器加一，引用失效就减一。当为0的时候，就可以判断为垃圾对象—–被GC回收 缺点：底层频繁进行计数加减，性能会低下，无法解决循环引用问题。 可达性分析算法 设置一个根结点，只要从该结点可达一个对象，就证明这个对象是存活的 垃圾回收算法 标记-清除算法 步骤 当GC发现需要释放内存空间的时候，Jvm正在执行的程序会进入等待状态 GC标记垃圾对象 GC清理垃圾对象 清除之后，Jvm继续执行 缺点 垃圾回收之后会产生大量的不连续的碎片空间，导致程序申请内存的时候，如果是一个较大的对象，会无法找到一个合适的空间，会迫使GC再次执行 复制算法 主要复制存活的对象 缺点 把村内可使用的空间减少了一半，造成了空间的浪费 对象存活数量较多的时候，复制性能比较差 标记-整理算法 针对复制算法的两个缺点，在老年代一般会使用这种算法 把存活的对象移动到内存的一端，然后把剩余的空间全部清空掉 分代收集算法 把内存划分为多个区域，一般为老年代、新生代。 然后根据不同区域不同的特点，用不同的回收算法去回收垃圾 例如：新生代，存活率较低，适合使用复制算法，老年代存活率高，适合使用标记整理算法 下图也可用于参考(点击可查看高清)","categories":[{"name":"面试+工作","slug":"面试-工作","permalink":"http://example.com/categories/%E9%9D%A2%E8%AF%95-%E5%B7%A5%E4%BD%9C/"}],"tags":[{"name":"最终冲刺","slug":"最终冲刺","permalink":"http://example.com/tags/%E6%9C%80%E7%BB%88%E5%86%B2%E5%88%BA/"}]},{"title":"最终冲刺_06","slug":"最终冲刺-06","date":"2021-11-09T10:05:34.000Z","updated":"2021-11-10T06:04:29.979Z","comments":true,"path":"2021/11/09/最终冲刺-06/","link":"","permalink":"http://example.com/2021/11/09/%E6%9C%80%E7%BB%88%E5%86%B2%E5%88%BA-06/","excerpt":"","text":"一、字节流和字符流的区别 字节流是按字节读写，字符流按字符读写 字节流默认不使用缓冲区，字符流使用缓冲区 字节流可用于任何类型的对象，包括二进制对象，而字符流只能处理字符或者字符串 字符流是字节流的包装 二、字节流和字符流 （记一些 - 了解一下api）字节流 字节输入流 int read()// 读取并返回1字节数据，若返回-1，表示读到了输入流的末尾。 int read(byte[] b)// 将数据读入一个字节数组，同时返回实际读取的字节数。如果返回-1，表示读到了输入流的末尾。 int read(byte[] b, int off, int len)//将数据读入一个字节数组，同时返回实际读取的字节数。如果返回-1，表示读到了输入流的末尾，off指定在数组b中存放数据的起始偏移位置；len指定读取的最大字节数。 long skip(long n)// 跳过和丢弃此输入流中数据的n个字节 void close()// 关闭此输入流并释放与该流关联的所有系统资源。 字节输出流 void write(byte[] b)// 将b.length个字节从指定的byte数组写入此输出流 void write(byte[] b, int off, int len)// 将指定byte数组中从偏移量off开始的len个字节写入此输出流 void write(int b)// 将1字节写入此输出流 void close() // 关闭此输出流并释放与此流有关的所有系统资源 void flush() // 刷新此输出流并强制写出所有缓冲的输出字节 字符流 字符输入流 int read()// 读取并返回1字符数据，若返回-1，表示读到了输入流的末尾。 int read(char[] b)// 将数据读入一个字符数组，同时返回实际读取的字符数。如果返回-1，表示读到了输入流的末尾。 int read(char[] b, int off, int len)//将数据读入一个字符数组，同时返回实际读取的字符数。如果返回-1，表示读到了输入流的末尾，off指定在数组b中存放数据的起始偏移位置；len指定读取的最大字符数。 long skip(long n)// 跳过和丢弃此输入流中数据的n个字符 void close()// 关闭此输入流并释放与该流关联的所有系统资源。 字符输出流 void write(char[] b)// 将b.length个字符从指定的byte数组写入此输出流 void write(char[] b, int off, int len)// 将指定byte数组中从偏移量off开始的len个字符写入此输出流 void write(int b)// 将1字符写入此输出流。 void write(String b)// 将字符串写入此输出流 void close() // 关闭此输出流并释放与此流有关的所有系统资源 void flush() // 刷新此输出流并强制写出所有缓冲的输出字 三、分类 按照流的方向：输入流（inputStream）和输出流（outputStream） 按照实现功能分：节点流和拓展流，采用了”装饰器设计模式思想” 节点流才具备真正操作文件的能力，拓展流只是让流的功能更加强大而已,拓展流脱离了节点流的话,那么是不允许的拓展流的使用必须要建立在节点流的基础之上 按照处理数据的单位： 字节流和字符流 分别由四个抽象类来表示（每种流包括输入和输出两种所以一共四个）:InputStream，OutputStream，Reader，Writer。Java中其他多种多样变化的流均是由它们派生出来的 四、装饰器模式定义 在不改变对象现有结构的情况下，动态的给对象添加额外的功能 相比于继承，装饰器模式能对不支持继承的类进行增强；并且比继承更灵活，不需要生成大量的子类 在装饰器模式中的角色有（理解） 抽象构件(Component)角色：给出一个抽象接口，已规范准备接收附加责任的对象。 具体构件(ConcreteComponent)角色：定义一个将要接收附加责任的类 装饰(Decorator)角色：持有一个构件(Component)对象的实例，并定义一个与抽象构件接口一致的接口。 具体装饰(ConcreteDecorator)角色：负责给构件对象增加新的责任 优点 比继承更灵活。继承是静态的，而且一旦继承所有子类都有一样的功能。而装饰模式采用把功能分离到每个装饰器中，然后通过对象组合的方式，在运行时动态的组合功能，每个被装饰的对象最终有哪些功能，是由运行期动态组合的功能决定的 更容易复用功能。有利于装饰器功能的复用，可以给一个对象多次增加同一个装饰器，也可以用同一个装饰器来装饰不同的对象 简化高层定义。装饰模式可以通过组合装饰器方式给对象增添任意多的功能，因此在进行高层定义的时候，只需要定义最基本的功能就可以了，需要的时候结合相应装饰器完成需要的功能 缺点 多层装饰比较复杂 五、BIO NIO AIO [IO模型]什么叫对象序列化，什么是反序列化 对象序列化：将对象以二进制的形式保存在硬盘上 反序列化：将二进制的文件转化为对象，读取实现serializable接口 不想让字段放在硬盘上就加transient 通俗理解同步异步、阻塞非阻塞 同步和异步 同步和异步指的是一个执行流程中每个方法是否必须依赖前一个方法完成后才可以继续执行。假设我们的执行流程中：依次是方法一和方法二。 同步指的是调用一旦开始，调用者必须等到方法调用返回后，才能继续后续的行为。即方法二一定要等到方法一执行完成后才可以执行。 异步指的是调用立刻返回，调用者不必等待方法内的代码执行结束，就可以继续后续的行为。（具体方法内的代码交由另外的线程执行完成后，可能会进行回调）。即执行方法一的时候，直接交给其他线程执行，不由主线程执行，也就不会阻塞主线程，所以方法二不必等到方法一完成即可开始执行。 阻塞与非阻塞 阻塞与非阻塞指的是单个线程内遇到同步等待时，是否在原地不做任何操作 阻塞指的是遇到同步等待后，一直在原地等待同步方法处理完成 非阻塞指的是遇到同步等待，不在原地等待，先去做其他的操作，隔断时间再来观察同步方法是否完成 BIO - 传统的IO模型 - 同步阻塞IO 同步阻塞，在服务器中实现的模式为一个连接一个线程。线程发起IO请求后，一直阻塞IO，直到缓冲区数据就绪后，再进入下一步操作。BIO一般适用于连接数目小且固定的架构，这种方式对于服务器资源要求比较高，而且并发局限于应用中，是JDK1.4之前的唯一选择，但好在程序直观简单，易理解。 NIO - 同步非阻塞IO 同步非阻塞，在服务器中实现的模式为一个线程处理多个请求(连接)，同步指的是必须等待IO缓冲区内的数据就绪，而非阻塞指的是，用户线程不原地等待IO缓冲区，可以先做一些其他操作，但是要定时轮询检查IO缓冲区数据是否就绪。NIO一般适用于连接数目多且连接比较短（轻操作）的架构，并发局限于应用中，编程比较复杂，从JDK1.4开始支持。(间隔轮询,不断发送请求,会消耗cpu资源) AIO - 异步非阻塞IO 异步非阻塞，在服务器中实现的模式为一个有效请求一个线程，用户线程只需要告诉内核,当缓冲区就绪后,通知用户线程或者执行用户线程交给内核的回调函数。AIO一般适用于连接数目多且连接比较长（重操作）的架构，充分调用操作系统参与并发操作，编程比较复杂，从JDK1.7开始支持。 理解各种 同步阻塞：你到饭馆点餐，然后在那等着，还要一边喊：好了没啊！（BIO） 同步非阻塞：在饭馆点完餐，就去遛狗了。不过溜一会儿，就回饭馆喊一声：好了没啊！（NIO） 异步阻塞：遛狗的时候，接到饭馆电话，说饭做好了，让您亲自去拿。 异步非阻塞：饭馆打电话说，我们知道您的位置，一会给你送过来，安心遛狗就可以了。（AIO） 六、BIO和NIO的区别、NIO和AIO的区别（以下可用于回答）阻塞IO调用 ： 在用户进程中调用执行的时候，进程会等待该IO操作，而且进程无法执行其他操作 非阻塞IO调用： 在用户进程中调用执行的时候，无论成功与否，该IO操作会立即返回，进程可以进行其他操作（当然如果是读取到数据，一般就接着进行数据处理）。 同步IO： 用户进程发出IO调用，去获取IO设备数据，双方的数据要经过内核缓冲区同步，完全准备好后，再复制返回到用户进程。整个过程会导致请求进程阻塞，直到I/O操作完成。 异步IO： 用户进程发出IO调用，去获取IO设备数据，并不需要同步，内核直接复制到进程，整个过程不会导致请求进程阻塞。 NIO与IO的区别 首先来讲一下传统的IO和NIO的区别，传统的IO又称BIO，即阻塞式IO，NIO就是非阻塞IO了。还有一种AIO就是异步IO，这里不加阐述了。 Java IO的各种流是阻塞的。这意味着，当一个线程调用read() 或 write()时，该线程被阻塞，直到有一些数据被读取，或数据完全写入。该线程在此期间不能再干任何事情了。 Java NIO的非阻塞模式，使一个线程从某通道发送请求读取数据，但是它仅能得到目前可用的数据，如果目前没有数据可用时，就什么都不会获取。而不是保持线程阻塞，所以直至数据变的可以读取之前，该线程可以继续做其他的事情。 非阻塞写也是如此。一个线程请求写入一些数据到某通道，但不需要等待它完全写入，这个线程同时可以去做别的事情。 线程通常将非阻塞IO的空闲时间用于在其它通道上执行IO操作，所以一个单独的线程现在可以管理多个输入和输出通道（channel）。","categories":[{"name":"面试+工作","slug":"面试-工作","permalink":"http://example.com/categories/%E9%9D%A2%E8%AF%95-%E5%B7%A5%E4%BD%9C/"}],"tags":[{"name":"最终冲刺","slug":"最终冲刺","permalink":"http://example.com/tags/%E6%9C%80%E7%BB%88%E5%86%B2%E5%88%BA/"}]},{"title":"最终冲刺_05","slug":"最终冲刺-05","date":"2021-11-08T05:36:00.000Z","updated":"2021-11-10T03:27:30.498Z","comments":true,"path":"2021/11/08/最终冲刺-05/","link":"","permalink":"http://example.com/2021/11/08/%E6%9C%80%E7%BB%88%E5%86%B2%E5%88%BA-05/","excerpt":"","text":"一、泛型好处？类型检测和安全Java语言引入泛型的好处是安全简单。泛型的好处是在编译的时候检查类型安全，并且所有的强制转换都是自动和隐式的，提高代码的重用率。 好处 类型安全，保证了代码的健壮性 消除强制类型转换 优化了程序设计，代码变得更加简洁 把运行时期的问题提前到了编译期间（以下解释） 泛型是没有多态的 泛型只有编译期间的概念，泛型仅仅是在编译期间是有效的 在编译期间一旦确定了泛型，那么在编译期间就只能向这个容器中添加对应类型的数据，否则会报错 运行期间将会被擦除，泛型是不存在运行时类型的 二、浮点类型——BigDecimal四个常用API 加：add() 减：subtract() 乘：multiply() 除：divide() 12345678910111213141516public class BigDecimalDemo &#123; public static void main(String[] args) &#123; //小数在进行计算的时候，会丢失精度 System.out.println(0.1+0.2); BigDecimal d1 = new BigDecimal(&quot;0.1&quot;); BigDecimal d2 = new BigDecimal(String.valueOf(0.2)); //用String类型构建BigDecimal对象--搭配--doubleValue()获取计算过的数据 //可以解决小数进行计算精度丢失的问题 System.out.println(d1.add(d2).doubleValue()); //0.3 System.out.println(d1.subtract(d2).doubleValue()); //-0.1 System.out.println(d1.multiply(d2).doubleValue()); //0.02 System.out.println(d1.divide(d2).doubleValue()); //0.5 &#125;&#125; 两个构造 BigDecimal(double val) BigDecimal(String val) 三、枚举类型枚举的特点 每个枚举类型默认都会自动继承java.lang.Enum&lt;E extends Enum&gt; 多个枚举常量使用“，”如果最后一个枚举常量下面有代码需要用分号隔开 枚举可以有构造,但不允许使用public或protected修饰 枚举类型可以提供普通属性 枚举类型不能够被实例化 枚举类型不支持再去extends其他的类或枚举类型 有时作用于 实现过单例，防止序列化和反序列化产生多个实例 防止反射破坏单例(因为反射的newInstance方法中会判断是否枚举,如果是枚举则抛出异常) 枚举单例 1234567891011121314151617181920212223242526272829303132333435363738394041424344public enum Singleton05 &#123; //public static final Singleton05 INSTANCE = new Singleton05(); INSTANCE; Singleton05() &#123; System.out.println(&quot;比较繁琐的操作的事情,费时费力的事情！&quot;); &#125; public static Singleton05 getInstance()&#123; return INSTANCE; &#125;&#125;//防止序列化检测class TestSingleton05&#123; public static void main(String[] args) &#123; Singleton05 s1 = Singleton05.getInstance(); Singleton05 s2 = Singleton05.getInstance(); System.out.println(s1 == s2); //true //序列化 try(ObjectOutputStream out = new ObjectOutputStream(new FileOutputStream(&quot;src/stu/aistar/design/ss.txt&quot;)))&#123; //对单例进行序列化操作 out.writeObject(s1); &#125; catch (FileNotFoundException e) &#123; e.printStackTrace(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; //反序列化 try(ObjectInputStream in = new ObjectInputStream(new FileInputStream(&quot;src/stu/aistar/design/ss.txt&quot;))) &#123; Singleton05 s3 = (Singleton05) in.readObject(); System.out.println(s3 == s1); //true System.out.println(s3 == s2); //true &#125; catch (FileNotFoundException e) &#123; e.printStackTrace(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; catch (ClassNotFoundException e) &#123; e.printStackTrace(); &#125; &#125;&#125; 四、进程和线程什么是进程和线程 一个程序至少一个进程，一个进程至少一个线程。线程不能单独执行运行，他一定是运行在进程的内部的 进程：是并发执行的程序，在执行过程中分配和管理资源的基本单位(是一个动态概念) 线程：是进程的一个执行单元，是进程内部的调度实体 进程和线程的关系 进程是资源分配的最小单元 线程是程序执行的最小单元 线程是进程的一个执行单元，是进程内部的调度实体 进程之间的资源是独立的，同一进程内的线程共享本进程的资源 进程和线程的区别 进程之间的资源是独立的，同一进程内的线程共享本进程的资源 一个进程崩溃之后，不会对其他进程产生影响，但是一个线程崩溃之后，会导致整个进程都死掉——多进程比多线程健壮 进程是程序过程中分配和管理资源的基本单位，线程是处理器调度的基本单位 两者均可并发执行 五、创建线程的方式 extends Thread类，重写run方法【共享代码，不共享资源】 将资源设置为静态的 —— 也是可以资源共享的 implement Runnable接口，重写run方法【共享代码，共享资源】 implement Callable接口【推荐配合Future+线程池一起使用】 Callable和Runnable的区别 Callable调用的是call方法，Runnable调用的是run方法 call方法可以抛出一个异常列表，但是run方法是不允许抛出异常列表 Callable可以通过Future来得到异步计算的结果 - 拿到线程执行之后的结果. 六、synchronized使用方式特点 Java语言的关键字 可用来给对象和方法或者代码块加锁 当它锁定一个方法[同步方法]或者一个代码块[同步代码块]的时候，并发线程同一时刻最多只有一个线程执行这段代码，其余的线程必须进入阻塞状态 非公平锁 如果同步代码块中出现了异常,那么仍然还是会自动释放锁资源的 不同场景使用方式 修饰普通方法 —— 对象锁 修饰静态方法 —— 类锁 修饰代码块synchronized(this) —— 对象锁 修饰代码块synchronized(xxx.class) —— 类锁 对象锁：不同对象拥有独立的一把锁，每个对象的锁是不冲突的 类锁：作用于这个类下的所有对象，竞争的是同一把锁 特点 ：对象重新获得锁资源的时候,会先清空本地工作内存.强制从主存中去拷贝已经更新的变量. 七、synchronized原理(悲观锁)每一个锁都对应一个monitor对象，在HotSpot虚拟机中它是由ObjectMonitor实现的（C++实现）。 八、synchronized四大特性 原子性 一个或者多个操作，在执行的过程中不会被任何因素打断，要么不执行，要么就执行全部 有些不是原子性的操作：i++、i+=2、i=i+1、double x = 3.0d、long x1 = 20L 可见性 原因:遇到synchronized之后,清空本地工作内存,重新从主存去拷贝最新的值 换句话说 ———-&gt; 多个线程访问同一个资源时,这个资源的状态,信息等同于其他线程都是可见的 有序性 在同一个时刻,只能由一个线程进入 可重入性 当一个线程申请到锁资源并且执行完毕之后[释放],仍然还有机会再去继续申请曾经申请过的锁资源. 九、Lock用法和synchronized的区别Lock的用法 lock是接口,synchronized它是一个关键字 lock锁是一个显示锁(手动申请锁,手动释放锁),synchronized隐式锁(自动申请/释放锁) lock手动申请锁**(对象锁)** lock是锁代码块 lock出现异常的时候,是不会主动释放资源的 Lock和synchronized有什么区别 实现层面不一样：synchronized 是 Java 关键字，在JVM层面实现加锁和释放锁。Lock 是一个接口，在代码层面实现加锁和释放锁 是否自动释放锁：synchronized 在线程代码执行完或出现异常时自动释放锁。Lock 不会自动释放锁，需要再 finally {} 代码块显式地中释放锁 是否一直等待：synchronized 会导致线程拿不到锁一直等待。Lock 可以设置尝试获取锁或者获取锁失败一定时间超时 获取锁成功是否可知：synchronized 无法得知是否获取锁成功。Lock 可以通过 tryLock 方法获得加锁是否成功 功能复杂性：synchronized 加锁可重入、不可中断、非公平。Lock 可重入、可中断、可公平和不公平、细分读写锁，提高效率 十、JMM内存模型 Java内存模型规定了所有的变量都存储在主内存中，包括实例变量、静态变量，出了局部变量和方法参数 每个线程都有自己的本地工作内存，保存了该线程用到的变量和主内存的副本拷贝 线程对变量的操作都在工作内存中进行，线程是不能直接读写主内存中的变量的 不同的线程之间无法访问对方的工作内存的变量，线程之间变量值的传递是通过主内存来完成的 十一、volatile和synchronizedvolatile 保证可见性 volatile不会造成阻塞 禁止指令重排 不能保证原子性 使用volatile来修饰实例变量 作用一：强制让程序遵守”缓存一致性”协议.如果主存中的变量一旦发生了改变.线程就会强制从主存中重新拷贝这个最新的数据到自己的本地工作内存中去 作用二：禁止指令重排 volatile 和 synchronized区别 volatile只能作用于变量，而synchronized可以作用于变量、方法和代码块 多线程访问volatile不会发生阻塞，而synchronized关键字可能发生阻塞 volatile能够保证数据的可见性，不能保证原子性，而synchronized关键字都可以保证 volatile可以禁止Jvm指令重排，而synchronized不能 volatile关键字主要解决的是多个线程之间的可见性，而synchronized关键字保证的是多个线程访问资源的同步性。 十二、什么时候工作内存中的改变会同步到主存中单线程 当前的单线程执行方法结束的时候 多线程 线程释放锁资源的时候 线程切换 PS一、线程的的生命周期 新建状态(瞬态)：当线程对象创建后，即进入新建状态。如：Thread t1 = new MyThread() 就绪状态：当线程对象调用start()方法（t1.start()），线程就进入就绪状态(处于就绪状态的线程，只是说明此线程已经做好了准备，随时等待cpu调度执行，并不是说执行了t.start()此线程立即就会执行) 运行状态：当cpu开始调度处于就绪状态的线程时，此时线程才得以真正执行，即进入到运行状态 死亡状态：线程执行完或者因异常退出了run()方法，该线程结束生命周期 阻塞状态：处于运行状态中的线程由于某种原因，暂时放弃对cpu的使用权，停止执行，此时进入阻塞状态(直到其进入到就绪状态，才有机会再次被cpu调用以进入到运行状态) 等待阻塞：运行状态中的线程执行wait()方法，使本线程进入到等待阻塞状态 同步阻塞：线程在获取synchronized同步锁失败（因为锁被其他线程占用），它会进入同步阻塞状态 其他阻塞：通过调用线程的sleep()或join()或发出了I/O请求时，线程会进入到阻塞状态。当sleep()状态超时时、join()等待线程终止或者超时、或者I/O处理完毕时，线程重新转入就绪状态.之前获取键盘输入 二、start和run方法的区别 start方法是线程内的方法，当线程调用start方法的时候，线程就会进入到就绪状态，随时等待CPU调度执行，并不是立即执行 run方法只是thread或者Runnable的一个普通方法，等到线程拿到CPU限权的时候，JVM虚拟机会自动调用run方法执行 三、wait和sleep区别 wait()释放锁，释放CPU，sleep()不释放锁，释放CPU wait()是Object的实例方法,sleep()是Thread的静态方法 wait()必须在synchronized同步代码块中，sleep()可以放在同步代码中也可以不放在同步代码块中 sleep()达到时间后，自动恢复可运行状态, wait()需要其他线程调用notify()、notifyAll()方法唤醒 四、yield线程的礼让 - 两个线程在执行,尽最大可能把cpu让给同等级的[1-10,越高越容易被执行],但是不一定能让出去 让出CPU调度，Thread类的方法，类似sleep 不能由用户指定暂停多长时间 ，并且yield()方法只能让同优先级的线程有执行权 yield()只是让线程重新回到可执行状态，所以执行yield()的线程有可能在进入到可执行状态后马上又被执行 yield方法只是一个建议，告诉线程调度器我的工作已经做的差不多了，可以让给同优先级的线程使用CPU了 五、join调用其他线程的join方法,表示调用join结束以后才会执行 一种特殊的wait，当前运行线程调用另一个线程的join方法 当前线程进入阻塞状态，直到另一个线程执行结束 注意该方法也需要捕捉异常 等待调用join方法的线程结束，当前线程才能继续执行 六、死锁死锁是什么 两个或两个以上的进程执行时，竞争同一个资源或者彼此通信而发生阻塞，在没有外力的情况下，无法推进，从而形成了死锁状态 死锁产生的条件 互斥条件：指进程对所分配到的资源进行排它性使用，即在同一时刻某资源只允许一个进程占用。如果此时还有其它进程请求资源，则请求者只能等待，直至占有资源的进程用完释放。 请求和保持条件：指进程至少保持一个资源，但又提出了新的资源请求，而该资源已被其它进程占有，此时请求进程阻塞，但是又对自己的资源保持不放。 不剥夺条件：指进程已获得的资源，在未使用完之前，不能被剥夺，只能在使用完时自己释放。 环路等待条件：指在发生死锁时，必然存在一个进程——资源的环形链，即进程集合{P0，P1，P2，···，Pn}中的P0正在等待一个P1占用的资源；P1正在等待P2占用的资源，……，Pn正在等待已被P0占用的资源。 PS 只要打破四个条件的一个,就可以防止死锁 死锁是不可避免,但是需要写程序的破坏四个条件中的一个 静态域容易产生死锁 手写死锁代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849public class DeadLockDemo extends Thread&#123; //临界资源 //每个对象对应一个监视器锁[monitor对象] public static Object oo1 = new Object(); public static Object oo2 = new Object();&#125;class D1 extends Thread&#123; private DeadLockDemo dd = new DeadLockDemo(); @Override public void run() &#123; synchronized (dd.oo1)&#123; //申请到了oo1对象的锁资源 System.out.println(&quot;======11======&quot;); try &#123; Thread.sleep(1000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; synchronized (dd.oo2)&#123; //申请到了oo1对象的锁资源 System.out.println(&quot;=======22======&quot;); &#125; &#125; &#125;&#125;class D2 extends Thread&#123; private DeadLockDemo dd = new DeadLockDemo(); @Override public void run() &#123; synchronized (dd.oo2)&#123; System.out.println(&quot;====33====&quot;); try &#123; Thread.sleep(1000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; synchronized (dd.oo1)&#123; System.out.println(&quot;=====44====&quot;); &#125; &#125; &#125;&#125;class TestDead&#123; public static void main(String[] args) &#123; Thread t1 = new D1(); Thread t2 = new D2(); t1.start(); t2.start(); &#125;&#125; 七、生产者消费者线程之间的通信问题 使用Object类中wait和notify方法 wait：Object类的方法(notify()、notifyAll())，必须放在循环体和同步代码块中，执行该方法的线程会释放锁 进入线程等待池中等待被再次唤醒(notify随机唤醒，notifyAll全部唤醒，线程结束自动唤醒)即放入锁池中竞争同步锁 手写代码[两种写法] 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108/** * 本类用于演示：线程之间的通信 - 生产者和消费者 */public class ThreadTongXinDemo &#123; public static void main(String[] args) &#123; //典型的不共享代码，共享资源 Box box = new Box(); Thread t1 = new ProductThread(box); Thread t2 = new CustomerThread(box); t1.setName(&quot;生产者&quot;); t2.setName(&quot;消费者&quot;); t1.start(); t2.start(); &#125;&#125;class Box&#123; private int content; /** * 假设的是要调用getter方法 - 消费了 - box中没有东西了 * 如果box 中有东西 - 刚生产完，flag为true * 如果bos 中没有东西 - 刚消费完，flag为false */ boolean flag; //标记 public synchronized int getContent() &#123; if (!flag)&#123; //首先保证不让消费者先消费 让他睡 try &#123; wait(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; flag = false; notifyAll(); return content; &#125; /** * 生产这线程去调用的 * 线程通信方面的方法wait，notify，notifyAll方法必须存在于循环体中的同步方法中. */ public synchronized void setContent(int content) &#123; if (flag)&#123; //生产者不睡，因为他要第一个生产(box中没东西) try &#123; /** * 一旦调用了wait方法之后，线程会释放锁，并且会自动进入到线程等待池中 * 进入到一个阻塞的状态 * 他自己是不会主动被唤醒的，必须由其他线程调用notify或者notifyAll才能够 * notify - 随机唤醒线程等待池中的一个线程 * notifyAll - 唤醒所有的等待的线程 */ wait(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; flag = true; notifyAll(); this.content = content; &#125;&#125;class ProductThread extends Thread&#123; private Box box; private int i = 0; public ProductThread(Box box)&#123; this.box = box; &#125; @Override public void run() &#123; while (true)&#123; System.out.println(Thread.currentThread().getName()+&quot;-&gt;放&quot;+(++i)+&quot;个&quot;); box.setContent(i); try &#123; Thread.sleep(1000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125;&#125;class CustomerThread extends Thread&#123; private Box box; public CustomerThread(Box box) &#123; this.box = box; &#125; @Override public void run() &#123; while (true)&#123; System.out.println(Thread.currentThread().getName()+&quot;-&gt;取&quot;+box.getContent()+&quot;个&quot;); try &#123; Thread.sleep(1000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125;&#125; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576public class ProducerAndCustomer &#123; private Lock lock = new ReentrantLock(); // 有几个线程就创建几个Condition private Condition producer = lock.newCondition();//生产者 private Condition consumer = lock.newCondition();//消费者 private int content; //盒子里的产品个数 // 生产方法 public void produce()&#123; while (true)&#123; try &#123; //对象锁 lock.lock(); // 生产者只有在盒子中产品数目等于0时进行生产 // 如果盒子里的数目不为0,那么让生产者进入阻塞状态 if(content!=0)&#123; producer.await(); &#125; // 否则进行产品的生产 content = (int) (Math.random()*10 + 1); System.out.println(&quot;生产者生产了&quot;+content+&quot;个产品&quot;); Thread.sleep(1000); // 唤醒消费者线程 consumer.signal(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; finally &#123; lock.unlock(); &#125; &#125; &#125; // 消费方法 public void consume()&#123; while (true)&#123; try &#123; //对象锁 lock.lock(); // 如果盒子里的数目小于等于0表示盒子空了,消费者不能再消费啦 if(content==0)&#123; consumer.await();//等待阻塞 &#125; // 消费 System.out.println(&quot;消费者消费了&quot;+content+&quot;个产品&quot;); content = 0; Thread.sleep(1000); // 唤醒生产者线程 producer.signal(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; finally &#123; lock.unlock(); &#125; &#125; &#125;&#125;class TestProducerAndCustomer&#123; public static void main(String[] args) &#123; ProducerAndCustomer pc = new ProducerAndCustomer(); //共享资源的方式 Thread t1 = new Thread(()-&gt;&#123; pc.produce(); &#125;); Thread t2 = new Thread(()-&gt;&#123; pc.consume(); &#125;); t1.setName(&quot;生产者&quot;); t2.setName(&quot;消费者&quot;); t1.start(); t2.start(); &#125;&#125; 手写打印abcABC123[理解] 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495public class LockTongxinDemo &#123; Lock lock = new ReentrantLock(); //有几个线程,就构建几个队列 private Condition c1 = lock.newCondition(); //给小写用 private Condition c2 = lock.newCondition(); //给大写用 private Condition c3 = lock.newCondition(); //给数字用 private int count = 0; //标记 //count = 0,打印小写字母的执行 //count = 1,打印大写字母的执行 //count = 2,打印数字的执行 //1. void await();//当前线程会进入到阻塞状态.必须要等其他线程唤醒的 //2. void signal();//哪个线程的Conition对象去调用signal()方法,哪个线程就会被唤醒 public void printLower()&#123; while (true)&#123; lock.lock(); if (count!=0)&#123; try &#123; c1.await(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; System.out.print(&quot;abc&quot;); System.out.println(); try &#123; Thread.sleep(1000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; count = 1; c2.signal(); lock.unlock(); &#125; &#125; public void printUpper()&#123; while (true)&#123; lock.lock(); if (count!=1)&#123; try &#123; c2.await(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; System.out.print(&quot;ABC&quot;); System.out.println(); try &#123; Thread.sleep(1000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; count = 2; c3.signal(); lock.unlock(); &#125; &#125; public void printNum()&#123; while (true)&#123; lock.lock(); if (count!=2)&#123; try &#123; c3.await(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; System.out.print(&quot;123&quot;); System.out.println(); try &#123; Thread.sleep(1000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; count = 0; c1.signal(); lock.unlock(); &#125; &#125; public static void main(String[] args) &#123; LockTongxinDemo Tx = new LockTongxinDemo(); Thread t1 = new Thread(()-&gt;Tx.printLower()); Thread t2 = new Thread(()-&gt;Tx.printUpper()); Thread t3 = new Thread(()-&gt;Tx.printNum()); t1.start(); t2.start(); t3.start(); &#125;&#125; 八、四大线程池线程池的返回值ExecutorService简介 ExecutorService是Java提供的用于管理线程池的类。该类的两个作用：控制线程数量和重用线程 Executors.newCacheThreadPool()：可缓存线程池，先查看池中有没有以前建立的线程，如果有，就直接使用。如果没有，就建一个新的线程加入池中，缓存型池子通常用于执行一些生存期很短的异步型任务 Executors.newFixedThreadPool(int n)：创建一个可重用固定个数的线程池，以共享的无界队列方式来运行这些线程。 Executors.newScheduledThreadPool(int n)：创建一个定长线程池，支持定时及周期性任务执行 Executors.newSingleThreadExecutor()：创建一个单线程化的线程池，它只会用唯一的工作线程来执行任务，保证所有任务按照指定顺序(FIFO, LIFO, 优先级)执行。 线程池的优点 降低资源的消耗 提高响应速度 对线程进行统一管理，便于调优 九、项目中有没有多线程的应用项目中如何处理高并发 - 多个线程执行update语句[悲观锁.乐观锁] 分布式环境下 - redis的分布式锁. 十、守护线程 GC - 运行在后台的 - 负责回收垃圾对象的. 核心:线程结束的时候不需要关心后台的守护线程是否也运行结束.线程是不会等后台的守护线程全部运行结束才结束. 当后台只有守护线程在执行的时候,就可以认为线程可以结束了. 十一、多线程的优缺点优点 多线程技术使程序的响应速度更快 可以设置各个任务的优先级，优化性能 可以随时停止任务 缺点 等候使用共享资源时，造成程序的运行速度变慢。 对线程进行管理，需要额外的 CPU开销 线程的死锁。即较长时间的等待或资源竞争以及死锁等多线程症状。","categories":[{"name":"面试+工作","slug":"面试-工作","permalink":"http://example.com/categories/%E9%9D%A2%E8%AF%95-%E5%B7%A5%E4%BD%9C/"}],"tags":[{"name":"最终冲刺","slug":"最终冲刺","permalink":"http://example.com/tags/%E6%9C%80%E7%BB%88%E5%86%B2%E5%88%BA/"}]},{"title":"最终冲刺_04","slug":"最终冲刺-04","date":"2021-11-06T06:35:29.000Z","updated":"2021-11-11T06:35:35.080Z","comments":true,"path":"2021/11/06/最终冲刺-04/","link":"","permalink":"http://example.com/2021/11/06/%E6%9C%80%E7%BB%88%E5%86%B2%E5%88%BA-04/","excerpt":"","text":"一、Java集合框架的JCF结构 1234567891011121314Collecation[I] - List[I] - 有序可重复 - ArrayList[C] - 动态数组 - LinkedList[C] - 链表 - Vector[C] - Set[I] - 无序不可重复 - HashSet[C] - SortedSet[I] - TreeSet[C] Map[I] - HashMap[C] - key-value的形式存储数据的,针对key是无序不可重复 - HashTable[C] - Properteis[C] - 属性文件在内存中的映射的对象 二、ArrayList特点，底层特点 有序可重复 底层数据结构是一个“动态增长” 的数组 查询效率高，增删效率低 如果不指定初始化容量，ArrayList默认初始容量为10，之后添加的元素超过容量默认会以1.5倍扩容。 线程不安全 优点：因为数组是一个有序的序列，所以它可以通过下标直接取值——查询效率高 缺点：增删效率低 三、ArrayList扩容机制 ArrayList集合底层默认的初始容量为10 当添加元素的时候，集合会进行判断：内部当前元素个数+1，去跟原数组长度相比较，如果大于原数组，触发扩容(1.5倍)，小于等于，添加元素 有一个特殊的场景：存在一次性添加多个元素，比如调用的是 addAll() 方法，一次性添加16个元素，集合进行判断：16跟原数组长度进行比较，16大于10，触发扩容机制(1.5倍—&gt;10*1.5=15)，发现15&lt;16，那么就让16是集合扩容之后的容量大小，如果添加的是14个元素，15就是容量大小 扩容之后，确定数组长度，调用copy方法，产生一个新的数组 四、ArrayList和Vector区别 Vector线程安全，ArrayList线程非安全 ArrayList扩容机制1.5倍，Vector扩容机制2倍 五、LinkedList特点，底层，如何进行查询 有序的序列 底层的数据结构双向链表，jdk6以及之前是双向循环链表 链表结构的特点:查询效率很低,每次都会从头节点开始遍历 增删效率高,只会涉及到相邻节点的移动 栈列 - 先进后出 队列 - 先进先出 六、ArrayList和LinkedList区别 ArrayList实现了基于动态数组的数据结构，LinkedList基于链表(双向)的数据结构 ArrayList查询效率高，LinkedList增删效率高 (理) 对于随机访问get和set，ArrayList绝对优于LinkedList，因为LinkedList要移动指针 (解) 对于新增和删除操作add和remove，LinedList比较占优势，因为ArrayList要移动数据 七、List和Set的区别两个接口都是继承自Collection，是常用来存放数据项的集合 区别： List有序可重复，Set无序不可重复 List可以通过下标来访问，Set不能 八、HashSet特点，底层原理，add方法特点 HashSet实现了set接口，底层是HashMap 存储的是对象，数据是无序不可重复复的 add方法——添加数据 把对象添加到容器之前，会根据对象调用hashCode方法，得到一个哈希值 通过这个哈希值直接定位元素的物理位置，如果没有被占用，直接存储，如果有数据，就产生了哈希碰撞或者哈希冲突 但这个时候还不能确定是同一个对象，继续调用对象的equals方法，如果返回true，说明是同一个对象，则拒绝添加 底层数据结构 散列表 桶数组 + 链表 + 红黑树 九、HashMap特点，底层原理，扩容机制，put方法过程特点 针对key无序不可重复 数据存储的形式为key-value 线程不安全 底层数据结构 JDK8之前——桶数组+链表 JDK8之后——桶数组+链表+红黑树 扩容机制 第一次若是桶数组为空则进行扩容，然后根据hash值计算数组下标，如果该下标对应的元素是空，则将元素直接插入到数组中。如果该下标对应的元素不为空，则判断key值是否相同，如果key值相同，则覆盖value，如果key值不同则需要判断当前是什么结构，如果是红黑树，则直接插入到红黑树。如果是链表，则需要遍历链表，遍历列表时如果发现相同的key则覆盖，如果没有则插入到链表尾部，再判断链表长度是否大于8，如果大于8要将链表转换为红黑树。 ​ 他先通过哈希值计算当前key的哈希值, 根据哈希值和桶数组的长度计算出当前key的下标, 判断下标是否有元素, 没有元素, 直接插入, 如果有元素, 则①判断key和哈希值是否相同, 如果相同, 将这个节点的value进行覆盖操作, 如果不相同, ②在判断是否为红黑树结构, 是就插入到红黑树里面. ③以上不满足只能为链表结构了, 如果为链表结构, 则循环遍历, 边判断key和哈希值是否有冲突, 边计算链表的个数是否达到树化的标准, 如果没有达到, 则往链表的尾节点插入数据. ​ 以上条件判断完, 数据放入到数组或者链表或者红黑树里面,计数器+1,然后判断+1的长度, 是否达到了负载因子(0.75)的阈值, 怎么计算阈值(比如: 初始化桶数组16个长度 * 0.75 = 12, 当+1的值大于12时, 就要告诉桶数组要扩容了), 扩容多少(他是按2^n次方扩容的, 初始化长度16, 扩一次乘以2 = 32, 所以这次扩容之后的长度为32). ​ 以上还有一个重要的操作, 链表树化, 树化是否为直接树化为红黑树, 答案是否定的: 他先进行判断 ​ ①桶数组是否为空或者 ​ ②桶数组的长度是否小于最小的扩容个数(64) ​ 如果满足以上条件的其中一个, 就代表桶数组要扩容, 而并不会直接把链表进行树化. 红黑树拓展: 一开始红黑树是由二叉查找树(二叉平衡树)延伸过来的, 什么是二叉查找树, 左子树节点的的值小于或等于根节点的值, 右子树节点的值大于或等于根节点的值, 所以每次查找某个数据的时候, 二分查找的算法, 从根节点开始找, 查找的数据大于根节点的往右子树找, 小于的往左子树找, 查找的最大次数为树的高度, 但是会有个问题, 当插入的数据导致树的节点大部分为右节点或者左节点的时候, 会导致查找的效率变低, 时间复杂度变为线性的, 所以为了解决这种情况, 诞生出了自平衡的二叉查找树(红黑树). 规则: ① 每一个节点要么都是红色, 要么都是黑色. ② 根节点为黑色 ③ 叶子节点为黑色节点(存放的都是NIL空节点) ④ 每个红色节点有两个黑色子节点 ⑤ 从给定节点到其后代子节点的每一条路径的都包含相同数量的黑色节点, 并且没有一条路径会是别的路径长度的两倍. 当有打破以上五个规则的其中一个的时候, 自平衡的红黑树会使用两种方式( 变色或者旋转 ), 从新维护这棵树. 变色的话就是将节点换成黑色或者红色, 会影响到其他节点的变色. 旋转的话, 分为左旋: 逆时针转动, 作为父节点向左移动,变为左孩纸, 右节点变为父节点. 扩容因子 比如说当前的容器容量是16，负载因子是0.75,16*0.75=12，也就是说，当容量达到了12的时候就会进行扩容操作。 他的作用很简单，相当于是一个扩容机制的阈值。当超过了这个阈值，就会触发扩容机制。HashMap源码已经为我们默认指定了负载因子是0.75。 负载因子过大，虽然空间利用率上去了，但是时间效率降低了。 负载因子太小，虽然时间效率提升了，但是空间利用率降低了。 基本上为什么是0.75的答案也就出来了，这是时间和空间的权衡。 负载因子是0.75的时候，空间利用率比较高，而且避免了相当多的Hash冲突，使得底层的链表或者是红黑树的高度比较低，提升了空间效率。 十、HashMap和HashSet的区别 HashSet的底层是HashMap HashMap实现了Map接口，HashSet实现了Set接口 HashMap存储键值对，HashSet存储对象 HashMap使用put方法添加元素，HashSet使用add方法添加元素 HashMap使用键对象来计算hashCode值，而HashSet使用成员对象来计算hashCode值，对于两个对象来说hashCode可能相同，所以用equals方法来判断对象的相等性。 HashMap比较快，因为是使用唯一的键来获取对象，HashSet较HashMap来说比较慢 十一、HashMap和HashTable的区别 HashMap线程非安全，HashTable线程安全，内部的方法基本都经过synchronized修饰。 HashMap的效率略高于HashTable HashMap允许将null作为一个key或者value，而HashTable不允许 HashMap的默认初始扩容大小为16，之后每次扩容容量为原来的2倍。HashTable的默认初始大小为11，之后每次扩容容量变为原来的2n+1 JDK8.x以后HashMap在解决哈希冲突时有了较大变化，当链表大于阈值（默认为8）时将链表转换为红黑树，HashTable没有这样的机制。 Hashtable 和 HashMap 采用的 hash/rehash 算法都大概一样，所以性能不会有很大的差异。 HashMap 把 Hashtable 的 contains 方法去掉了，改成 containsValue 和 containsKey。因为 contains 方法容易让人引起误解。 十二、HashSet和TreeSet的区别一、HashSet HashSet内部的数据结构是哈希表，是线程不安全的。 HashSet当中，保证集合中元素是唯一的方法。 通过对象的hashCode和equals方法来完成对象唯一性的判断。 假如，对象的hashCode值是一样的，那么就要用equals方法进行比较。 假如，结果是true，那么就要视作相同元素，不存。 假如，结果是false，那么就视为不同元素，存储。 注意了，假如，元素要存储到HashCode当中，那么就一定要覆盖hashCode方法以及equals方法。 二、TreeSet TreeSet能够对Set集合当中的元素进行排序，是线程不安全的。 TreeSet当中，判断元素唯一性的方法是依据比较方法的返回结果是否为0，假如是0，那么是相同的元素，不存，假如不是0，那么就是不同的元素，存储。 TreeSet对元素进行排序的方式： 1、元素自身具备比较功能，也就是自然排序，需要实现Comparable接口，并覆盖其compareTo方法。 2、元素自身不具备比较功能，那么就要实现Comparator接口，并覆盖其compare方法。 除此之外，还要注意了，LinkedHashSet是一种有序的Set集合。 也就是其元素的存入和输出的顺序是相同的。 简单了解一下 Set[I] - SortedSet[I] - TreeSet[C] - 底层是TreeMap[C] - 使map集合的key根据定制的规则来进行排序. Set - 无序不可重复的. TreeSet - 不可重复的,但是可以根据定制的排序规则来进行排序. 十三、Collection和Collections Collection 是一个集合接口。它提供了对集合进行基本操作的接口方法 Collections是针对集合类的一个帮助类，他提供一系列静态方法实现对各种集合的搜索、排序、线程安全等操作 十四、比较器接口[java.util.Comparator] 可比较接口[java.lang.Comparable] - 返回-1是降序还是升序.Comparable是排序接口，若一个类实现了Comparable接口，就意味着“该类支持排序”。而Comparator是比较器，我们若需要控制某个类的次序，可以建立一个“该类的比较器”来进行排序。 Comparable相当于“内部比较器”，而Comparator相当于“外部比较器”。 两种方法各有优劣， 用Comparable 简单， 只要实现Comparable 接口的对象直接就成为一个可以比较的对象，但是需要修改源代码。 用Comparator 的好处是不需要修改源代码， 而是另外实现一个比较器， 当某个自定义的对象需要作比较的时候，把比较器和对象一起传递过去就可以比大小了， 并且在Comparator 里面用户可以自己实现复杂的可以通用的逻辑，使其可以匹配一些比较简单的对象，那样就可以节省很多重复劳动了。 十五、Map两个迭代写法 - 手写12345678910//第一种方式 - 将map集合中所有的key全部取出来放入到一个Set集合中.//set集合 - 无序不可重复,map集合的key也是无序不可重复.Set&lt;Integer&gt; sets = maps.keySet();//遍历set集合Iterator&lt;Integer&gt; iter = sets.iterator();while(iter.hasNext())&#123; Integer key = iter.next(); String value = maps.get(key); System.out.println(key+&quot;:&quot;+value);&#125; 12345678910//第二种方式 - 将map集合中的每对key-value封装到了一个内置的Entry对象中//然后将每个entry对象放入到Set集合中Set&lt;Map.Entry&lt;Integer,String&gt;&gt; entries = maps.entrySet();Iterator&lt;Map.Entry&lt;Integer,String&gt;&gt; iter2 = entries.iterator();while(iter2.hasNext())&#123; Map.Entry&lt;Integer,String&gt; e = iter2.next(); Integer key = e.getKey(); String value = e.getValue(); System.out.println(key+&quot;-&gt;&quot;+value);&#125; 测试第一种 12345678910111213141516171819public static void main(String[] args) &#123; Map&lt;Integer,String&gt; maps = new HashMap&lt;&gt;(); maps.put(1,&quot;java&quot;); maps.put(2,&quot;python&quot;); maps.put(3,&quot;php&quot;); Set&lt;Integer&gt; set = map.keySet(); Iterator&lt;Integer&gt; iter = set.iterator(); while(iter.hasNext())&#123; int key = iter.next(); System.out.println(key + &quot; &quot; + map.get(key)); &#125;&#125;PS： //获取maps集合中的所有的value Collection&lt;String&gt; values = maps.values(); System.out.println(values); 十六、数组排重的两种写法第一种 123456789101112131415161718192021222324252627282930313233343536373839404142//根据下标进行删除public static int[] delByIndex(int[] arr,int index)&#123; //校验 if(null == arr || arr.length==0 || index&lt;0 || index&gt;arr.length-1) return arr; //1. 定义新的数组 int[] temp = new int[arr.length-1]; //因为根据指定下标删除 删除的个数为1 //2. 定义下标计数器 int pos = 0; for (int i = 0; i &lt; arr.length; i++) &#123; //遍历arr if (i != index)&#123; temp[pos++] = arr[i]; &#125; &#125; return temp;&#125;/** * 调用delByIndex * &#123;1,2,3,4&#125; * * 遍历到arr i从0开始 arr[i] * 和i后面的所有的值进行比较arr[j] * 如果arr[i] == arr[j] - delByIndex(arr,j); */public static int[] delDoubleElement2(int[] arr)&#123; if(null == arr || arr.length==0) return arr; for (int i = 0; i &lt; arr.length; i++) &#123; for (int j = i+1; j &lt;arr.length ; j++) &#123; if (arr[i] == arr[j])&#123; //删除j下标对应的数据 // arr = &#123;1,1,2,3,3,1,4,2,1&#125;; arr = delByIndex(arr,j); j--; //防止下标左移漏掉 &#125; &#125; &#125; return arr;&#125; 第二种 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586/** * 删除指定元素！！！ * * 数组的长度一旦确定了,就不能改变 - 删除-&quot;假的&quot; * * @param arr 原数组 * * @param target 需要删除的元素 * * @return 新的数组,一定不包含target值 */public static int[] delByTarget(int[] arr,int target)&#123; //确定一个新的数组的关键， - 数组的元素类型 / 数组的长度 int count = 0; //计数器 for (int i = 0; i &lt; arr.length; i++) &#123; //确定target的个数 if (arr[i] == target)&#123; count++; &#125; &#125; if (count == 0)&#123; //判断一下target是否存在 return new int[-1]; //无所谓返回什么 直接抛出错误信息即可 &#125; int[] arr1 = new int[arr.length-count]; //新数组 int index = 0; for (int i = 0; i &lt; arr.length; i++) &#123; //遍历原来的数组 if (arr[i] != target)&#123; arr1[index] = arr[i]; index ++; &#125; &#125; return arr1;&#125;/** * 去重！ * 引用和对象 * * arr -&gt; [1,2,1,2,3,3,4,2] * * temp -&gt; [0,0,0,0,0,0,0,0] * * 永远将arr[0]依次放入到temp[pos++] = arr[0] * temp -&gt; [1,2,3,4,0,0,0,0] * * 立即到arr中将所有的arr[0]这个数值全部删除 * int[] trr = delByTarget(arr,arr[0]);// * arr = trr; * //arr -&gt; [] * * //arr的长度为0 * * 核心的原则:不断改变arr的地址 * * arr = [] * @param arr * @return */public static int[] delDoubleElement(int[] arr)&#123; //判断数组的有效性 //java.lang.NullPointerException 空指针异常 - null.东西[/属性/方法 - 成员] if(null == arr || arr.length==0) return arr; //定义一个新的数组，长度和原来的数组一样 int[] temp = new int[arr.length]; //定义一个下标计数器 int pos=0; do&#123; //永远将arr[0]依次放入到temp[pos++] = arr[0] temp[pos++] = arr[0]; // 立即到arr中将所有的arr[0]这个数值全部删除 arr = delByTarget(arr,arr[0]); // 核心,包含的知识点,本质 //循环退出 if(arr.length==0) break; &#125;while(true); temp = Arrays.copyOf(temp,pos); return temp;&#125; 第三种 123456789101112131415161718192021222324252627282930public static int[] delDoubleElement3(int[] arr)&#123; if(null == arr || arr.length==0) return arr; boolean[] flag = new boolean[arr.length]; //全是 false Arrays.fill(flag,true); for (int i = 0; i &lt; flag.length; i++) &#123; // 【1,2,1,3,5,6,8,9】 for (int j = i+1; j &lt;flag.length ; j++) &#123; if (arr[j]==arr[i])&#123; flag[j]=false; &#125; &#125; &#125; int count = 0; for (int i = 0; i &lt; flag.length; i++) &#123; if (flag[i])&#123; count++; &#125; &#125; int[] temp = new int[count]; int pos = 0; //计数器 for (int i = 0; i &lt; arr.length; i++) &#123; if (flag[i])&#123; temp[pos++] = arr[i]; &#125; &#125; return temp;&#125;","categories":[{"name":"面试+工作","slug":"面试-工作","permalink":"http://example.com/categories/%E9%9D%A2%E8%AF%95-%E5%B7%A5%E4%BD%9C/"}],"tags":[{"name":"最终冲刺","slug":"最终冲刺","permalink":"http://example.com/tags/%E6%9C%80%E7%BB%88%E5%86%B2%E5%88%BA/"}]},{"title":"最终冲刺_03","slug":"最终冲刺-03","date":"2021-11-05T07:26:47.000Z","updated":"2021-11-05T13:54:10.595Z","comments":true,"path":"2021/11/05/最终冲刺-03/","link":"","permalink":"http://example.com/2021/11/05/%E6%9C%80%E7%BB%88%E5%86%B2%E5%88%BA-03/","excerpt":"","text":"一、String底层原理 String的底层有一个由final关键字修饰的char数组，value用于保存数据，一旦被赋值，内存地址无法修改 String类的一个最大特性是不可修改性 因此每次对字符串的操作实际上都会另外分配一个新的常量数组空间 5个String常用api indexOf() 返回指定字符串在该字符串出现的序列 startsWith() 判断该字符串是否以指定字符开始 endsWith() 判断该字符串是否以指定字符串结尾 concat() 将指定字符串连接在该字符串的结尾 length() 返回字符串的长度 subString 返回该字符串从索引开始 结束于字符串末尾 或者指定索引的一个子字符串 二、字符串的各种比较 new的话会在堆中存储一份数据,再到常量池中查看是否有此数据,没有的话就存储一份，有则引用 直接赋值,会直接查看常量池中是否有此数据,没有存储一份,有的话将该字符串的引用赋值给变量 1234567//它会在&quot;串池&quot;中创建一个&quot;abc&quot;字符串对象,然后将地址给了s1String s1 = &quot;abc&quot;;//&quot;串池&quot;中的特点:优先先到串池中查找是否已经存在&quot;abc&quot;对象,如果有直接返回地址给s2//否则才会继续创建新的字符串对象String s2 = &quot;abc&quot;;System.out.println(s1 == s2);//true 1234567//s1默认指向的是堆里面的字符串对象String s1 = new String(&quot;abc&quot;);String s2 = &quot;abc&quot;;System.out.println(s1 == s2); //false//intern()强制让s1指向串池的对象System.out.println(s1.intern() == s2); //true 1234567891011121314151617String s3 = &quot;b&quot;;String s4 = &quot;a&quot; + s3; //产生一个StringBuilder对象String s5 = &quot;a&quot; + &quot;b&quot;; //因为此处的&quot;a&quot;和&quot;b&quot;就是字符串常量 //jvm对待字符串常量的拼接 - &quot;a&quot;和&quot;b&quot;的拼接 //当成&quot;ab&quot;的整体,直接扔到常量池中.System.out.println(s4 == s5); //false//字符串使用final修饰final String s6 = &quot;b&quot;; //使用final关键字修饰的 可以看成一个字符串常量 而不是一个变量指向一个字符串//&quot;a&quot;+s6 =&gt; &quot;ab&quot;扔到常量池,没有产生新的对象. //一个变量指向字符串进行+拼接的时候 会调用底层的StringBuilder方法进行append来进行拼接String s7 = &quot;a&quot; + s6;System.out.println(s5 == s7); //true 三、String,StringBuilder和StringBuffer的区别 三者之间都是使用final修饰的,都是不可被继承的 不同点 2-1. String它是不可变的字符串,线程安全的.比较耗系统资源和内存的.性能是三个当中最低的. 2-2. StringBuffer可变的字符串 - 线程安全的.效率低于StringBuilder,但是高于String 2-3. StringBuilder可变的字符串 - 线程不安全的,效率是最高的. 四、算法题 删除指定字符串 1234567891011121314151617public static String delByStr(String oldStr,String target)&#123; //1. 递归出口 if(!oldStr.contains(target)) return oldStr; //2. oldStr中仍然包含target //找到target字符串在oldStr字符串中的下标位置. //bcbcabca -&gt; ca int startIndex = oldStr.indexOf(target); //返回target在oldStr中第一次出现的下标位置 int endIndex = startIndex+target.length(); //5 //String类型转换成StringBuilder类型 - delete(int start,int end);//[start,end) StringBuilder builder = new StringBuilder(oldStr); StringBuilder result = builder.delete(startIndex,endIndex); //bcbbca return delByStr(result.toString(),target);&#125; 找公串 12345678910111213141516171819202122232425262728public static String findCommonStr(String str1,String str2)&#123; //abcbcbcaaaffffff //fdfdffffffooobcbcbcqqq //定义一个变量 int len = 0; //定义StringBuilder对象,用来保存所有的最大长度的公串 StringBuilder builder = new StringBuilder(); for (int i = 0; i &lt; str1.length(); i++) &#123; for (int j = i+1; j &lt;=str1.length(); j++) &#123; //获取每个子串的各种组合 String subStr = str1.substring(i,j); //将每个子串的长度 int length = subStr.length(); if(str2.contains(subStr) &amp;&amp; length&gt;len)&#123; //清空builder builder.delete(0,builder.capacity()); builder.append(subStr+&quot; &quot;); len = length; &#125;else if(str2.contains(subStr) &amp;&amp; length==len)&#123; builder.append(subStr+&quot; &quot;); &#125; &#125; &#125; return builder.toString();&#125; 3.统计某个字母出现的个数 123456789101112131415161718192021222324252627282930313233public class CountStrDemo &#123; public static void main(String[] args) &#123; String str = &quot;ahfdfjdkfjsdafsed&quot;; count(str); &#125; private static void count(String str) &#123; Map&lt;Character,Integer&gt; map = new HashMap&lt;&gt;(); //char[] arr = str.toCharArray(); for (int i = 0; i &lt; str.length(); i++) &#123; if(map.containsKey(str.charAt(i)))&#123; Integer count = map.get(str.charAt(i)); map.put(str.charAt(i),count+1); &#125;else&#123; map.put(str.charAt(i),1); &#125; &#125; List&lt;Map.Entry&lt;Character,Integer&gt;&gt; sortList = new ArrayList&lt;&gt;(); //排序... Set&lt;Map.Entry&lt;Character,Integer&gt;&gt; set = map.entrySet(); Iterator&lt;Map.Entry&lt;Character,Integer&gt;&gt; iter = set.iterator(); while(iter.hasNext())&#123; sortList.add(iter.next()); &#125; sortList.sort((c1,c2)-&gt; c2.getValue() - c1.getValue()); for (Map.Entry&lt;Character, Integer&gt; e : sortList) &#123; System.out.println(e.getKey()+&quot;:&quot;+e.getValue()); &#125; &#125;&#125; 五、Integer底层的Cache[-128,127]Integer类内部有一个静态内部类,类中有缓冲区,提供了缓冲的数组,数组在静态代码块中进行预初始化,提前赋值了.范围[-128,127] 如果在[-128,127]之间,那么直接返回内部的缓冲数组中的数据,如果不在这个范围,返回一个新的Integer对象 六、Integer类型的各种比较 new出来的Integer在堆中，各自指向各自的数据，永远为false 1234Integer i = new Integer(100);Integer j = new Integer(100);System.out.print(i == j); //false Integer与基本数量类型相比较，包装类会被拆箱转换成int类型，永远为true 1234Integer i = new Integer(100);int j = 100；System.out.print(i == j); //true new出来的Integer在堆中，各自指向各自的数据，永远为false 1234Integer i = new Integer(100);Integer j = 100;System.out.print(i == j); //false Integer有一个缓冲数组，范围在-128~127，在范围内的数据比较为true，如果超出了这个范围就相当于是new出来的，在堆中，false 1234Integer i = 100;Integer j = 100;System.out.print(i == j); //true 超出范围false 1234Integer i = 128;Integer j = 128;System.out.print(i == j); //false 七、Integer和int的区别 Integer是int的包装类，int是基本数据类型 Integer的默认值为null，int的默认值为0 Integer支持泛型，int不支持 Integer对象的引用存储在栈中，对象的数据存储在堆中，int存储在栈中 Integer变量必须实例化后才能使用，int变量不需要 八、什么是解箱，什么是封箱？ 装箱：将基本类型—转换成—对应的包装类； 拆箱：将包装类型—转换成—基本数据类型； Java使用自动装箱和拆箱机制，节省了常用数值的内存开销和创建对象的开销，提高了效率 由编译器来完成，编译器会在编译期根据语法决定是否进行装箱和拆箱动作。 九、记五个运行时和非运行时异常名称运行时异常 ClassCastException 类转换异常 IllegalArgumentException 非法参数异常 IndexOutOfBoundsException 下标越界异常 NullPointerException 空指针异常 java.util.NoSuchElementException - 不存在此元素 java.lang.ArithmeticException - 计算异常 - 分母为0 非运行时异常 java.io.IOExcetion - IO流异常 java.sql.SQLException - SQL异常 java.text.ParseException - 解析失败异常 - 字符串的模板和pattern不匹配 InterruptedException - 中断异常 - Thread.sleep(1000); java.lang.CloneNotSupportedException - 不允许被clone.","categories":[{"name":"面试+工作","slug":"面试-工作","permalink":"http://example.com/categories/%E9%9D%A2%E8%AF%95-%E5%B7%A5%E4%BD%9C/"}],"tags":[{"name":"最终冲刺","slug":"最终冲刺","permalink":"http://example.com/tags/%E6%9C%80%E7%BB%88%E5%86%B2%E5%88%BA/"}]},{"title":"最终冲刺_02","slug":"最终冲刺-02","date":"2021-11-04T00:31:45.000Z","updated":"2021-11-11T01:22:39.413Z","comments":true,"path":"2021/11/04/最终冲刺-02/","link":"","permalink":"http://example.com/2021/11/04/%E6%9C%80%E7%BB%88%E5%86%B2%E5%88%BA-02/","excerpt":"","text":"一、封装、继承、多态(定义、好处)？ 封装 定义：隐藏对象的属性和实现细节，对外仅仅提供公共访问的方式。 好处：变化隔离、提高重用性、安全性 继承 定义：子类继承父类的行为和特征，使得子类对象具有父类的实例域和方法，或子类从父类继承方法，使得子类具有父类相同的行为 好处： 提高了代码的复用性。 让类与类之间产生了关系，提供了另一个特征多态的前提。 缺点：增加耦合 多态 定义：父类引用或者接口的引用指向自己子类的对象。 好处：提高了程序的扩展性。 修饰符 访问修饰符 - 决定了这个成员可以在哪里能够被访问. 所有包 子类[可以不同,同包] 同包 本类 public 公共的,公开的 √ √ √ √ protected 受保护的 × √ √ √ 默认的 × × √ √ private 私有的 × × × √ 安全级别:private&gt;默认的&gt;protected&gt;public 可见区域:public&gt;protected&gt;默认的&gt;private 构造方法的作用 对象的创建就是通过构造方法来完成，其功能主要是完成对象的初始化。 二、抽象和接口？相同点 抽象类和接口都属于抽象的数据类型，都不能被实例化，只能被其他类继承和实现. 抽象类和接口都可以包含抽象方法. 实现接口或继承抽象类的普通子类都必须实现所有抽象方法,但是如果子类是抽象的,则可以选择实现或不实现. 不同点 抽象类是abstract关键字，接口是interface关键字 抽象类中允许有构造方法，而接口不允许 抽象类可以包含所有方法，而接口中只能包含抽象方法、静态方法、默认方法 一个子类最多只能继承一个抽象类，而一个实现类可以同时实现多个接口 抽象类中可以包含初始化块，而接口中不可以（ 初始化块就是{ } ） 接口的好处 自定义标准(契约) 三、final、finally和finalize的区别？——只能说是毫无关系final final修饰的局部变量或者属性，一旦被赋值，不可改变 final修饰的方法不可被重写 final修饰的类不可被继承 finally 常常搭配try…catch使用，try块中无论是否出现异常，finally块中的代码都会执行 一般用于资源的释放和关闭 finalize Object类中的方法，和GC相关 Java中允许使用finalize()方法在垃圾收集器将对象从内存中清除出去之前调用，去做必要的清理工作 这个方法是由垃圾收集器在销毁对象时调用的，通过重写finalize()方法可以整理系统资源或者执行其他清除工作 四、重载和重写的区别？ 两者都是实现多态的方式，区别在于重载实现的是编译时的多态性，重写实现的是运行时的多态性 重载发生在一个类中，同名的方法如果有不同的参数列表则视为重载(参数类型不同，参数个数不同，或者二者都不同) 重写： 在继承关系中 方法名必须一样 参数列表必须高度保持一致 子类重写的方法的访问修饰符和返回值类型可以小于或者等于父类的那个方法 重写有一个特殊的场景——子类重写之后的方法的修饰符、返回类型、方法名、参数列表和父类高度保持一致——重构 五、static关键字 —— 练习题static修饰的成员是在JVM加载类的时候就会被立刻分配空间以及初始化,这个过程只有一次,并且内存中的实例也只有一份 非静态的成员是在每次创建对象的时候才会分配空间以及初始化 执行顺序 父类静态变量 父类静态代码块 子类静态变量 子类静态代码块 父类普通变量 父类普通代码块 父类构造函数 子类普通变量 子类普通代码块 子类构造函数 六、类加载器(哪三个,各自作用,本身过程:线程安全) 启动类加载器Bootstrap ClassLoader- 主要负责加载系统的核心类 扩展类加载器Extension ClassLoader - 主要用于加载\\lib\\ext中的java类,这些类会支持系统的运行 应用类加载器Application ClassLoader - 主要加载用户类,即加载用户类路径(ClassPath)上指定的类库,一般都是自己写的代码 类加载过程是线程安全的 七、hashcode和equals？为什么？总结： 先通过hashcode方法得到一个哈希值，通过哈希值直接定位元素应该存储的物理位置，位置上如果没有元素则存放，如果有，再比较对象的equals方法。 从而大大减少equals方法调用，提高比较效率 （1） 为什么要重写equals方法（理解一下） Java中的集合（Collection）有两类，一类是List，再有一类是Set。 前者集合内的元素可以重复；后者元素不可重复。 那么我们怎么判断两个元素是否重复呢？ 这就是Object.equals方法了。 通常想查找一个集合中是否包含某个对象，就是逐一取出每个元素与要查找的元素进行比较， 当发现某个元素与要查找的对象进行equals方法比较的结果相等时，则停止继续查找并返回肯定的信息，否则返回否定的信息。 如果一个集合中有很多元素譬如成千上万的元素，并且没有包含要查找的对象时， 则意味着你的程序需要从该集合中取出成千上万个元素进行逐一比较才能得到结论， 于是，有人就发明了一种【【哈希算法来提高从集合中查找元素的效率】】，这种方式 将集合分成若干个存储区域，每个对象可以计算出一个哈希码，可以将哈希码分组， 每组分别对应某个存储区域，根据一个对象的哈希码就可以确定该对象应该存储的那个区域. （2） 为什么要重写hashCode方法（理解一下） hashCode方法返回的就是根据对象的内存地址换算出的一个值。这样一来，当集合要添加新的元素时， ​ 先调用这个元素的hashCode方法，就一下子能定位到它应该放置的物理位置上。 ​ 如果这个位置上没有元素，它就可以直接存储在这个位置上，不用再进行任何比较了； ​ 如果这个位置上已经有元素了，就调用它的equals方法与新元素进行比较，相同的话就不存了， ​ 不相同就散列其它的地址。这样一来实际调用equals方法的次数就大大降低了，几乎只需要一两次 八、==和equals的区别？ ==基本类型使用，比较的是基本类型的数值 equals对象类型使用，如果某个类没有重写equals方法，那么调用equals方法的时候，仍然使用到的是==比较，如果重写了equals方法，就看equals提供的哪些属性一致的时候，才返回true 九、值传递和引用传递 值传递 - 实参传递给形参的值，实参和形参再内存上是两个独立的变量，对形参的修改不会影响实参的值 引用传递 - 实参传递给形参的是堆内存上引用的地址，形参和实参在内存上指向的是同一地址，对形参的改变会影响实参 十、单例(饿汉式、懒汉式、双重检测锁)——双重检测锁重要饿汉式：多线程安全，创建对象时进行初始化 1234567891011121314public class Singleton &#123; //2. 初始化一个变量，该变量就是该类的唯一实例[对象] private static Singleton instance = new Singleton(); //1. 私有化构造 private Singleton()&#123; System.out.println(&quot;私有化构造&quot;); &#125; //3. 提供一个公开的、静态的、方法来返回这个类的唯一属性 public static Singleton getInstance()&#123; return instance; &#125;&#125; 懒汉式：多线程不安全，需要时进行初始化 123456789101112131415public class Singleton &#123; private static Singleton instance ; private Singleton()&#123; &#125; public static Singleton getInstance()&#123; if (instance == null)&#123; instance = new Singleton(); &#125; return instance; &#125;&#125; 双重检测锁：多线程安全 123456789101112131415161718public class Singleton &#123; private static Singleton instance; private Singleton&#123; &#125; public static Singleton getInstance()&#123; if(instance == null)&#123; synchronized(Singleton.class)&#123; if(instance == null)&#123; instance = new Singleton(); &#125; &#125; &#125; return instance; &#125;&#125; 十一、简单工厂模式一个工厂决定了创建某种产品的实例，它完成了对象的创建和对象的使用分离 优点：简单粗暴，通过一个含参的工厂方法，就可以创建一个实例对象 缺点： 当增加工厂的产品的时候，会导致工厂负担过大，代码繁多 增加新产品，违背开闭原则，只能修改工厂来实现 1234567891011121314151617181920212223public class ProductFactory &#123; public static final int QQ = 1; public static final int WX = 2; //根据传入的参数来返回某个具体的产品 //多态的应用 - 面向接口的编程 //3.方法的返回值类型写成接口，方法的执行结果可以是这个接口的任意一个实现类 public static Sender getInstance(int type)&#123; Sender sender = null; switch (type)&#123; case 1: sender = new QQSender(); break; case 2: sender = new WXSender(); break; default: System.out.println(&quot;参数不合法！&quot;); break; &#125; return sender; &#125;&#125;","categories":[{"name":"面试+工作","slug":"面试-工作","permalink":"http://example.com/categories/%E9%9D%A2%E8%AF%95-%E5%B7%A5%E4%BD%9C/"}],"tags":[{"name":"最终冲刺","slug":"最终冲刺","permalink":"http://example.com/tags/%E6%9C%80%E7%BB%88%E5%86%B2%E5%88%BA/"}]},{"title":"最终冲刺_01","slug":"最终冲刺-01","date":"2021-11-03T00:58:29.000Z","updated":"2021-11-03T13:15:35.346Z","comments":true,"path":"2021/11/03/最终冲刺-01/","link":"","permalink":"http://example.com/2021/11/03/%E6%9C%80%E7%BB%88%E5%86%B2%E5%88%BA-01/","excerpt":"","text":"一、冒泡、选择、快排 —— 时间复杂度 排序方法 平均时间 最好时间 最坏时间 桶排序(不稳定) O(n) O(n) O(n) 基数排序(稳定) O(n) O(n) O(n) 归并排序(稳定) O(nlogn) O(nlogn) O(nlogn) 快速排序(不稳定) O(nlogn) O(nlogn) O(n^2) 堆排序(不稳定) O(nlogn) O(nlogn) O(nlogn) 希尔排序(不稳定) O(n^1.25) 冒泡排序(稳定) O(n^2) O(n) O(n^2) 选择排序(不稳定) O(n^2) O(n^2) O(n^2) 直接插入排序(稳定) O(n^2) O(n) O(n^2) 123456789101112131415//冒泡排序算法 -- 升序for(int i = 0; i &lt; arr.length-1; i++)&#123; //最外层确定循环次数 for(int j = 0; j &lt; j-1-i; j++)&#123; if(arr[j] &gt; arr[j+1])&#123; //相邻元素两两比较，每轮之后确定一个最值 int temp = arr[j]; //元素交换 arr[j] = arr[j+1]; arr[j+1] = temp; &#125; &#125;&#125;时间复杂度： 最好时间：O(n) 最坏时间：O(n²) 平均时间：O(n²) 123456789101112131415//选择排序算法 -- 升序for(int i = 0; i &lt; arr.length; i++)&#123; for(int j = i + 1; j &lt; arr.length; j++)&#123; if(arr[i] &gt; arr[j])&#123; arr[i] = arr[i] ^ arr[j]; arr[j] = arr[i] ^ arr[j]; arr[i] = arr[i] ^ arr[j]; &#125; &#125;&#125;时间复杂度： 最好时间：O(n²) 最坏时间：O(n²) 平均时间：O(n²) 1234567891011121314151617181920212223242526272829303132333435//快速排序算法 -- 升序public static void main(String[] args) &#123; int[] arr = new int[]&#123;2,6,4,6,2,5,8,9,7,1&#125;; quickSort(arr,0,arr.length-1); System.out.println(Arrays.toString(arr)); &#125;public static void quickSort(int[] arr,int start,int end)&#123; if (start&lt;end)&#123; int i = getIndex(arr,start,end); quickSort(arr,0,i-1); quickSort(arr,i+1,end); &#125;&#125;public static int getIndex(int[] arr ,int start,int end)&#123; int x = arr[start]; //挖坑 用第一个为 基准数 while (start&lt;end)&#123; while (start &lt; end &amp;&amp; x &lt; arr[end])&#123; //从后往前 基准数跟后面的数相比较 如果后面的大 继续循环 反之到② end--; &#125; if (start&lt;end)&#123; //②把比基准数还要小的 放到第一个位置 (第一个位置已经拿出来了 位置可想为空) arr[start] = arr[end]; start++; &#125; while (start &lt; end &amp;&amp; x &gt; arr[start])&#123; //从前往后 基准数跟前面的数进行比较 如果前面的小 继续循环 反之到③ start++; &#125; if (start&lt;end)&#123; //③把比基准数大的 放到后面 arr[end] = arr[start]; end--; &#125; &#125; arr[start] = x; return start;&#125; 二、JVM、JRE、JDKJVM(Java Virtual Machine): Java虚拟机是一个可以执行Java字节码的虚拟机进程 Java源文件被编译成能被Java虚拟机执行的字节码文件 用于保证Java的跨平台的特性 JRE(Java Runtime Environment): Java运行时环境 包括JVM+java的核心类库 JDK(Java Development Kit): Java开发工具包，针对开发者使用，包括JRE+开发工具 可以让开发者开发、编译、执行Java应用程序 三、斐波那契、阶乘、杨辉三角（递归、循环算法——for）12345678910111213141516171819202122232425//斐波那契//1 1 2 3 5 8 13 21 34 55 ...public static int fei(int n)&#123; //递归算法 可以直接用来求第几个 if(n == 1 || n == 2) return 1; return fei(n-1) + fei(n-2); //n=4 //fei(3)+fei(2) //fei(2) + fei(1) + fei(2)=3&#125;public static int fei(int n)&#123; //for算法 if(n == 1 || n == 2) return 1; int head = 1; int tail = 1; int total = 0; for(int i = 3; i &lt;= n; i++)&#123; total = head + tail; tail = head; head = total; &#125; return total;&#125; 12345678910111213//阶乘public static int jie(int n)&#123; //递归算法 if(n == 1) return 1; return n * jie(n - 1);&#125;public static int jie(int n)&#123; //for算法 int sum = 1; for(int i = 2; i &lt;= n; i++) sum *= i; return sum;&#125; 123456789101112131415//杨辉三角public static void printYang(int x)&#123; //递归算法 for (int i = 0; i &lt; x; i++) &#123; for (int j = 0; j &lt;= i ; j++) &#123; System.out.print(yang(i,j)+&quot;\\t&quot;); &#125; System.out.println(); &#125;&#125;public static int yang(int x,int y)&#123; if(y==0 || x==y) return 1; return yang(x-1,y-1) + yang(x-1,y);&#125; 四、 short s1 = 1; s1 = s1 + 1;有错吗? short s1 = 1; s1 += 1;有错吗? 对于short s1 = 1; s1 = s1 + 1;由于1是int类型，因此s1+1运算结果也是int 型，需要强制转换类型才能赋值给short型。 而short s1 = 1; s1 += 1;可以正确编译，因为s1+= 1;相当于s1 = (short)(s1 + 1);其中有隐含的强制类型转换。 五、 char型变量中能不能存储一个中文汉字?为什么? char型变量是用来存储Unicode编码的字符的，unicode编码字符集中包含了汉字，所以，char型变量中可以存储汉字。 不过，如果某个特殊的汉字没有被包含在unicode编码字符集中，那么，这个char型变量中就不能存储这个特殊汉字。 补充说明：unicode编码占用两个字节，所以，char类型的变量也是占用两个字节。 备注：后面一部分回答虽然不是在正面回答题目，但是，为了展现自己的学识和表现自己对问题理解的透彻深入，可以回答一些相关的知识，做到知无不言，言无不尽。 六、Switch case中（）中变量的数据类型？ 在Java 5以前，Switch语句中支持的变量有byte、short、int、char，枚举。 从Java 7开始，Switch语句中可以支持字符串（String）类型————(同时case标签必须为字符串常量或字面量) 七、Math中的ceil()、floor()、round()方法？ 函数 概念 ceil() 返回大于等于( &gt;= )给定参数的的最小整数，类型为双精度浮点型。 floor() 返回小于等于（&lt;=）给定参数的最大整数 。 round() 它表示四舍五入，算法为 Math.floor(x+0.5)，即将原来的数字加上 0.5 后再向下取整。所以，Math.round(11.5) 的结果为12，Math.round(-11.5) 的结果为-11。 八、&lt;&lt;、&gt;&gt;、&gt;&gt;&gt; 的运算&lt;&lt;运算符 ’&lt;&lt;’表示左移移，不分正负数，低位补0 1234567891011121314151617181920212223242526正数：比如运算’16&lt;&lt;2’的结果 首先你要将16转换为二进制数 16的二进制原码为：0001 0000 16的二进制反码为：0001 0000 16的二进制补码为：0001 0000 整数的反码、补码和原码一致！ 16&lt;&lt;2就是将16的二进制补码左移两位，低位补0，那么得到： 左移两位后补码为：0100 0000 将得到的补码转换为十进制，那么16&lt;&lt;2的结果为64 负数：比如运算’-16&lt;&lt;2’的结果 首先你要将-16转换为二进制数 -16的二进制原码为：1001 0000 -16的二进制反码为：1110 1111 //反码为0-&gt;1 1-&gt;0 首字母1代表负0代表正 -16的二进制补码为：1111 0000 //反码加1操作 -&gt; 补码 -16&lt;&lt;2就是将16的二进制补码左移两位，低位补0，那么得到： 左移两位后的补码为：1100 0000 左移两位后的反码为：1011 1111 左移两位后的原码为：1100 0000 将得到的原码转换为十进制，那么-16&lt;&lt;2的结果为-64 &gt;&gt;运算符 ’&gt;&gt;’表示右移，如果该数为正，则高位补0，若为负数，则高位补1 1234567891011121314151617181920212223242526正数：比如运算’16&gt;&gt;2’的结果 首先你要将16转换为二进制数 16的二进制原码为：0001 0000 16的二进制反码为：0001 0000 16的二进制补码为：0001 0000 16&gt;&gt;2就是将16的二进制补码右移两位，高位补0，那么得到： 右移两位后补码为：0000 0100 将得到的补码转换为十进制，那么16&gt;&gt;2的结果为4 负数：比如运算’-16&gt;&gt;2’的结果 首先你要将-16转换为二进制数 -16的二进制原码为：1001 0000 -16的二进制反码为：1110 1111 //反码为0-&gt;1 1-&gt;0 首字母1代表负0代表正 -16的二进制补码为：1111 0000 //反码加1操作 -&gt; 补码 -16&gt;&gt;2就是将16的二进制补码右移两位，高位补1，那么得到： 右移两位后的补码为：1111 1100 右移两位后的反码为：1111 1011 右移两位后的原码为：1000 0100 将得到的原码转换为十进制，那么-16&gt;&gt;2的结果为-4 123456&lt;&lt; 或者 &gt;&gt; 正数的情况下： 直接进行二进制移动即可。 -&gt; 得到的就是运算过的结果 &gt;&gt;2 就是 0001 0000 &gt;&gt; 0000 0100 &lt;&lt;2 就是 0001 0000 &lt;&lt; 0100 0000 &gt;&gt;&gt;运算符 ‘&gt;&gt;&gt;’表示无符号右移，也叫逻辑右移，即若该数为正，则高位补0，而若该数为负数，则右移后高位同样补0 12345678910111213141516正数：比如运算’16&gt;&gt;&gt;2’，它的运算过程同等于’16&gt;&gt;2’ 方法参考上面’16&gt;&gt;2’的正数运算。 负数：比如运算’-16&gt;&gt;&gt;2’的结果 首先你要将-16转换为二进制数(32位) -16的二进制原码为：10000000 00000000 00000000 00010000 -16的二进制反码为：11111111 11111111 11111111 11101111 -16的二进制补码为：11111111 11111111 11111111 11110000 -16&gt;&gt;&gt;2就是将16的二进制补码右移两位，高位补0，那么得到： 右移两位后的补码为：00111111 11111111 11111111 11111100 转换为十进制，那么-16&gt;&gt;&gt;2的结果为1073741820","categories":[{"name":"面试+工作","slug":"面试-工作","permalink":"http://example.com/categories/%E9%9D%A2%E8%AF%95-%E5%B7%A5%E4%BD%9C/"}],"tags":[{"name":"最终冲刺","slug":"最终冲刺","permalink":"http://example.com/tags/%E6%9C%80%E7%BB%88%E5%86%B2%E5%88%BA/"}]},{"title":"spring_IOC_DI","slug":"spring-IOC-DI","date":"2021-09-22T12:19:43.000Z","updated":"2021-09-23T10:35:20.713Z","comments":true,"path":"2021/09/22/spring-IOC-DI/","link":"","permalink":"http://example.com/2021/09/22/spring-IOC-DI/","excerpt":"","text":"IOC：控制反转 - 权利的反转 正转：在应用程序中，由对象自己主动的去寻找依赖的对象的方式 反转：IOC容器[spring容器]控制了对象的创建，控制了对象的创建以及外部资源的注入 对象只能被动的接收依赖的对象，spring容器来负责进行依赖对象的注入 好处 - 解耦合各个组件 IOC侧重于对象的创建交给spring容器管理 DI：依赖注入 即组件以一些预先定义好的方法，来接收容器的资源注入 组件之间依赖关系是由容器在运行期间决定 提升组件重用的频率 应用程序[bean]依赖于spring容器 DI侧重于Spring容器在创建对象的时候，动态的给对象依赖注入需要的组件 IOC和DI的区别： IOC控制反转，把对象的创建交给Spring容器进行管理 DI依赖注入，向类里面的属性设置值 关系：依赖注入不能单独存在，需要在IOC的基础之上完成操作 IoC：控制反转，指将对象的创建权，反转到spring容器。 DI：依赖注入，指在创建对象的过程中，将对象依赖的属性通过配置进行注入。 DI的实现依赖于IoC，先有控制反转才有依赖注入 id：唯一标识，通过它获取配置的实现类。class：配置实现类","categories":[{"name":"IOC和DI(依赖注入)","slug":"IOC和DI-依赖注入","permalink":"http://example.com/categories/IOC%E5%92%8CDI-%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5/"}],"tags":[{"name":"Spring","slug":"Spring","permalink":"http://example.com/tags/Spring/"}]},{"title":"Mysql_视图和limit_06","slug":"Mysql-视图和limit-06","date":"2021-08-30T13:11:53.000Z","updated":"2021-08-30T13:13:22.202Z","comments":true,"path":"2021/08/30/Mysql-视图和limit-06/","link":"","permalink":"http://example.com/2021/08/30/Mysql-%E8%A7%86%E5%9B%BE%E5%92%8Climit-06/","excerpt":"","text":"limit语句 应用场景就是 - 网页中的数据[肯定是mysql中的]肯定是要进行分页的. 123-- 获取表中前m行的数据.-- limit mmysql&gt; select * from s_emp limit 3; 123456-- limit m,n-- m代表的是行下标,从0开始-- n代表的是显示的条数-- 从第3行开始,显示5条mysql&gt; select * from s_emp limit 2,5; 分页的公式 场景: 对于用户而言,点击多少页,比如选择1页,认为是第一页. pageNow - 当前页. pageSize - 每页显示条数 1limit (pageNow-1)*pageSize,pageSize sql优化的部分 limit m,n m - 偏移量 n-显示的条数 如果偏移量比较大,limit语句的查询性能就会低下. limit优化常见的两种场景 假设stu表中name列没有添加索引.但是name是从业角度考虑它应该是唯一的. 1234567select * from stu where name=&#x27;tom&#x27;;-- 肯定会进行全表扫描的. - 数据量 - 导致查询效率低下explain select * from stu where name=&#x27;tom&#x27;;-- 已经确认name列值肯定是唯一的 - 避免全表扫描select * from stu where name=&#x27;tom&#x27; limit 1; 前提条件是id主键列是自增且连续,由于limit m,n随着m[偏移量]增加,导致查询效率低下 1234select * from s_emp limit 10000,2;优化select * from s_emp where id&gt;10000 limit 2; 视图 视图 - “虚拟表”,类似于原表的”镜像”,之前是怎么操作table的,怎么操作视图view 优势: 保证数据的安全性. 比如某张表中的隐秘数据比较多,不希望程序员看到你这个原表.比如emp(id,name,salary,birthday). 隐秘数据比如有salary,birthday.为了保障数据的安全性.db[数据库管理员]可以为emp创建视图出来 1234create view emp_view as select id,name from emp;接下来程序员的操作,直接对视图进行操作了[select,insert,update,delete] - &gt; 对原表也会产生影响.但是删除视图,是不会删除原表的.但是删除原表,视图肯定是不存在的. 封装一些比较繁琐的关联查询,在以后再次用到的时候.可以直接查询视图. 简化我们查询数据 简单分类 简单视图 - 视图来自于单张表的查询 复杂视图 - 视图来自于关联查询[多张表] 创建视图1create view 视图名 as select语句; 12为student表创建一个简单视图create view stu_view as select * from student; 删除视图1drop view 视图名; 操作视图 视图的查询 - DQL 1select * from stu_view; 修改原表,看是否对视图造成影响 - 会 1234update student set sname=&#x27;admin&#x27; where id=1;select * from stu_view;| 1 | admin | 1990-01-01 00:00:00 | 男 | 能不能对简单视图进行dml操作 - 可以 对视图的dml操作同样也会对原表产生影响 1update stu_view set sname=&#x27;success&#x27; where id=1; 复杂视图 复杂视图代表整个视图的来源是关联表的查询 - 就是用来被查询的. 1234567-- 查询区域名以及这个区域上的员工的first_namedrop view region_view;create view region_viewas select r.name,e.first_name from s_region r join s_dept d on d.region_id = r.idjoin s_emp e on e.dept_id = d.id; 1select * from region_view; 它和简单视图的一个区别在于,复杂视图是不能够执行DML操作的 12delete from region_view where name = &#x27;North America&#x27;;ERROR 1395 (HY000): Can not delete from join view &#x27;j03s.region_view&#x27; with check option 123456789101112131415161718192021222324252627282930drop view stu_view;create view stu_viewas select id,sname from student where id=13;select * from stu_view;-- 更新视图 - 更新的是视图来源的那条sql的where中的条件列update stu_view set id=100 where id=13;-- 视图没有了 - 原表中已经没有了 - 视图的更新会同步给原表[对原表产生了影响了]mysql&gt; select * from stu_view;Empty set (0.00 sec)-- 不允许视图去更新自己来源的那条sql中的where条件列.drop view stu_view;create view stu_viewas select id,sname from student where id=11 with check option;mysql&gt; select * from stu_view;+------+--------+| id | sname |+------+--------+| 11 | 李四 |+------+--------+-- 检测with check option的效果 - 更新视图的时候,是不允许更新id列update stu_view set id=900 where id=11;ERROR 1369 (HY000): CHECK OPTION failed &#x27;j03s.stu_view&#x27; 总结面试题 DB,DBA,DBS,DBMS,RDBMS delete和truncate和drop区别 123456delete - DMLtruncate - DDL-- 清空表truncate 表名;drop - ddl - 删除表 数据库优化 - sql优化 悲观锁和乐观锁 innodb和myisam区别 索引底层原理[innodb和myisam] - b+树 聚簇索引和非聚簇索引[辅助索引] 事务的隔离级别 脏读,不可重复读,可重复读**,幻读** DQL查询语句 - 项目 存储过程和函数的区别 视图的优势 三大范式概念 SQL按照功能分类[DCL,DTL,DML,DQL,DDL]","categories":[{"name":"数据库","slug":"数据库","permalink":"http://example.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"}],"tags":[{"name":"mysql","slug":"mysql","permalink":"http://example.com/tags/mysql/"}]},{"title":"Mysql_视图函数存储过程_05","slug":"Mysql-视图函数存储过程-05","date":"2021-08-30T13:09:23.000Z","updated":"2021-08-30T13:13:46.289Z","comments":true,"path":"2021/08/30/Mysql-视图函数存储过程-05/","link":"","permalink":"http://example.com/2021/08/30/Mysql-%E8%A7%86%E5%9B%BE%E5%87%BD%E6%95%B0%E5%AD%98%E5%82%A8%E8%BF%87%E7%A8%8B-05/","excerpt":"","text":"函数function 了解即可 - 开发中肯定用不到. 单行函数 - 字符串函数,数字函数,日期函数 多行函数(组函数) 实际上数据库是可以进行编程的. 如果使用的是mysql8.x,需要设置一下才能允许自定义函数 12341. 在my.ini文件下添加：log-bin-trust-function-creators=1 需要重启db服务器2. 在mysql客户端[终端] - set global log_bin_trust_function_creators=TRUE; 语法函数语法 - 创建 注意点: 1. 函数体中肯定有return语句 2. 只要遇到varchar类型,必须要指定参数的长度 12345678910111213-- mysql中默认的结束符号使用的是;-- 修改了默认的结束符号位$$-- 函数体中肯定会出现分号delimiter $$-- 创建函数create function 函数名([变量 数据类型(长度)]) returns 返回数据类型begin -- 函数体 return 结果;end $$delimiter ; 删除函数 12-- 删除函数drop function 函数名; 练习1 - 自定义函数 传入俩个整数,返回俩个整数的相加的结果 12345678drop function adds;delimiter //create function adds(a int,b int) returns intbegin return a + b;end //delimiter ; 调用函数 1select adds(10,30); 练习2 - 自定义函数 日期格式化 xxxx年xx月xx日 12345678910111213drop function my_date;delimiter //create function my_date(dt date) returns varchar(20)begin return date_format(dt,&#x27;%Y年%m月%d日&#x27;);end //delimiter ;-- 调用select my_date(now());select my_date(&#x27;2010-09-09&#x27;); 练习3 - while..do…end while 感受循环语句(while .. do. .. end while)以及局部变量(declare)以及变量如何重新设置(set) 1~x之间的总和 1234567891011121314151617181920drop function x_add;delimiter //create function x_add(x int) returns intbegin -- 定义俩个局部变量 declare i int default 1; declare sums int default 0; -- 循环 while i&lt;=x do -- sums加 set sums = sums+i; -- i自增 set i = i + 1; end while; return sums;end //delimiter ;select x_add(100); 练习4 - if…end if 分支语句 1~x之间的偶数奇数进行相加 1234567891011121314151617drop function ji_add;delimiter //create function ji_add(x int) returns intbegin declare i int default 1; declare sums int default 0; while i&lt;=x do if i%2!=0 then set sums = sums+i; end if; set i = i + 1; end while; return sums;end //delimiter ;select ji_add(100); 练习4 - 全局变量 1~x之间的数字之后,但是不包括5的倍数 123456789101112131415161718192021222324252627drop function jis_add;delimiter //create function jis_add(x int) returns intbegin -- 定义一个局部变量 declare i int default 1; -- 定义一个全局变量 - mysql能够识别到的符号@ - @变量名 - 全局变量 set @sums = 0; -- 类似于java中的continue语句 + 代码块命名 -- success是一个循环语句标签名称 - 随便命名的 success:while i&lt;=x do if i%5=0 then set i = i + 1; -- 下面的代码不执行 -- 继续迭代success的循环 - continue - 继续下一轮循环,忽略本轮的循环 iterate success; end if; set @sums = @sums + i; set i = i + 1; end while; return @sums;end //delimiter ;select jis_add(100);-- 全局变量 - 函数体外部是可以访问得到的select @sums; 存储过程procedure 安装好mysql环境之后,实际上就是在本地中安装好了mysql-server - mysql的服务器端以及mysql-client - mysql的客户端 mysql-server - 右击计算机 - 管理 - 服务 - 服务和应用程序 - 右边👉 - Mysql服务 mysql-client - mysql自带的一个客户端.市面上还有很多第三方的客户端[可视化效果不错] - navicat[收费的],idea 一条sql语句的执行的流程. mysql&gt; select * from s_emp; ①当输入sql完毕之后,敲下enter键之后,客户端检测一下sql的语法是否规范.如果不规范,直接报错. ②如果sql语法是规范的,客户端会负责将这条合法的sql语法发送到mysql-server - mysql服务器端 ③mysql-server接受到来自于客户端的sql之后.mysql-server会对这条sql进行编译和解析 ④mysql-server会将解析的结果返回给mysql-client端[sql语句的执行结果] 总结: sql语句 - 语法检测 - 发送到mysql-server - 编译,解析,返回给mysql-client,将这次sql执行的结果保存 作用 为了完成一些特定的功能,提前讲sql预编译好,存储在mysql-server端系统的执行计划表中.第一次去调用存储过程的时候 会对sql进行预编译并且进行保存.第二次再调用的时候,省去了sql语句的编译的过程. 存储过程可以做到标准的组件编程[封装sql语句] 语法12345678910-- 删除存储过程drop procedure 存储过程名;-- 创建存储过程delimiter //create procedure 存储过程名([in|out] [参数列表])begin -- 过程体end //delimiter ; 体验123456789101112131415161718192021222324252627-- 把s_emp表中的员工的平均薪资的sql预编译好放在mysql-server端-- select avg(salary) from s_emp;-- 该条sql经常会被频繁调用/或者该条sql写法比较复杂.-- 考虑把这条sql封装到 - 存储过程drop procedure sal_pro;delimiter //create procedure sal_pro()begin -- 封装sql语句 select avg(salary) from s_emp;end //delimiter ;-- 预编译sql语句 - 创建存储过程的时候-- mysql-server会对这个存储过程中的sql语句进行编译,解析,将sql语句的编译的结果进行保存.-- 后续的每次调用的过程中.应该不会再对这条sql语句进行编译了.-- 使用call关键字来调用,不需要编译-- 第一次调用,call sal_pro();-- 第二次调用-- mysql-server不需要对这个存储过程中的sql语句再去进行编译了[省略了],直接返回之前保存的结果.call sal_pro(); 输入和输出 in out inout in输入 创建存储过程的时候,参数列表.确认这个参数到底是用来接受参数的,还是用来返回存储过程的结果的. 12345678910111213141516171819drop procedure in_pro;delimiter //create procedure in_pro(in a int)begin -- System.out.println(a); select a; -- 对a重新赋值 set a = 10; select a;end //delimiter ;-- 调用-- 直接传入一个字面量call in_pro(20);-- 测试一下使用全局变量进行传参set @i = 20;call in_pro(@i); out输出 如果参数是使用out来修饰的,它是不能够用来保存接受到的数据的 123456789101112131415161718192021222324252627282930drop procedure out_pro;delimiter //create procedure out_pro(out a int)begin -- a是用out修饰的,所以为null select a; -- a是out - 存储过程返回出去的数据 set a = 10;end //delimiter ;-- 报错,如果参数是out修饰的,那么是不能够直接传入一个字面量的-- call out_pro(100);-- 如果是out修饰的,调用存储过程,只能传入一个全局变量set @i=100;call out_pro(@i);+------+| a |+------+| NULL |+------+里面的a是没有绑定到你的100 - 原因就是因为a是使用out修饰的.不能接受参数select @i;+------+| @i |+------+| 10 |+------+ 练习 - 封装单个结果集 根据员工的id来返回员工的名称,薪资 - sql语句 - 封装 1234567891011121314drop procedure emp_pro;delimiter //create procedure emp_pro(in eid int(7),out fname varchar(25),out sal float(11,2))begin select first_name into fname from s_emp where id=eid; select salary into sal from s_emp where id = eid;end //delimiter ; -- 如果参数是out修饰的,必须只能传入全局变量[作用就是来保存存储过程一些执行结果的值]call emp_pro(1,@fname,@sal); select @fname;select @sal; 第二种写法 - 针对的是单个结果集的写法 12345678910111213drop procedure emp_pro;delimiter //create procedure emp_pro(in eid int(7),out fname varchar(25),out sal float(11,2))begin select first_name,salary into fname,sal from s_emp where id=eid;end //delimiter ; -- 如果参数是out修饰的,必须只能传入全局变量[作用就是来保存存储过程一些执行结果的值]call emp_pro(1,@fname,@sal); select @fname;select @sal; 练习 - 封装的是多行结果集 找出大于某个id的first_name和salary - 结果可能是多行的 现在已经被弃用的游标 - 性能很低下. 需要定义第三方表来存储我们的多行结果集 12345671. 根据具体的查询的业务来构建第三方表 业务中最终查询出来的数据正好都在s_emp表中. -- 仅仅保留结构,但是不保留结果 create table s_emp_pro select first_name,salary from s_emp where 1=2; 2. 比如分组统计,查询出来的数据不在某个表中存在 - 一定要根据具体的查询出来的数据 - 手动构建一张表 1234567891011drop procedure emp_pro;delimiter //create procedure emp_pro(in eid int(7))begin -- insert into 表名 select 语句; insert into s_emp_pro(first_name,salary) select first_name,salary from s_emp where id &gt;= eid;end //delimiter ; -- 如果参数是out修饰的,必须只能传入全局变量[作用就是来保存存储过程一些执行结果的值]call emp_pro(20); 练习 - 带事务1234567891011121314151617181920212223242526272829-- 转账功能,同时成功,同时失败.drop procedure transfer_pro;delimiter //create procedure transfer_pro(in sid int(7),in tid int(7),in money double(7,2),in st int(7))begin -- 定义一个局部变量 - 展示信息 declare msg varchar(20) default &#x27;0&#x27;; -- 手动开启一个事务 start transaction; update account set balance = balance-money where id = sid; -- 模拟一个异常 if st=1 then set msg = &#x27;sorry,转账失败了!&#x27;; rollback; else update account set balance = balance+money where id = tid; -- 手动提交一个事务 set msg = &#x27;good,转账成功了!&#x27;; commit; end if; select msg;end //delimiter ;-- st=1,进入到异常块的.call transfer_pro(1,2,1000.0,1);-- st=2,正常执行转账的业务功能call transfer_pro(1,2,1000.0,2); 语句使用条件分支语句 if .. then .. elseif .. then ..elseif.. then … else.. end if; 1234567891011121314151617drop procedure if_pro;delimiter //create procedure if_pro(in a int)begin declare msg varchar(20) default &#x27;&#x27;; if a&gt;=90 then set msg = &#x27;优秀&#x27;; elseif a&gt;=80 then set msg = &#x27;良好&#x27;; else set msg = &#x27;及格&#x27;; end if; select msg;end //delimiter ;call if_pro(85); case .. when .. then..else… end case 123456789101112131415161718drop procedure case_pro;delimiter //create procedure case_pro(in a int)begin declare msg varchar(20) default &#x27;&#x27;; case a when 1 then set msg=&#x27;1&#x27;; when 2 then set msg = &#x27;2&#x27;; else set msg = &#x27;3&#x27;; end case; select msg;end //delimiter ; call case_pro(2); 循环语句 while .. do .. end while 12345678910111213141516171819drop procedure while_pro;delimiter //create procedure while_pro(in x int,out result int)begin declare i int default 1; declare sums int default 0; while i&lt;=x do set sums = sums + i; set i = i+1; end while; -- result修饰成out =return result set result = sums;end //delimiter ; -- out修饰的,只能传入全局变量call while_pro(100,@result); select @result; loop … end loop 类似于while(true) 123456789101112131415161718192021-- 求1~x结束drop procedure loop_pro;delimiter //create procedure loop_pro(in x int,out result int)begin declare i int default 1; set result=0; success:loop if i&gt;x then -- 打破循环 -- iterate success; -- conintue leave success; end if; set result = result + i; set i = i + 1; end loop;end //delimiter ;call loop_pro(100,@result);select @result; repeat .. until .. end repeat 类似于java-&gt; do..while 12345678910111213drop procedure repeat_pro;delimiter //create procedure repeat_pro(in x int)begin repeat set x = x + 1; select x; until x&gt;0 end repeat;end //delimiter ; call repeat_pro(-1); 总结函数和存储过程的区别 定义函数的时候,必须指定returns 返回类型.定义存储过程的时候不需要使用returns 返回类型 函数体中必须要有return语句+返回结果,但是存储过程可以没有return语句 函数的调用用select关键字,存储过程调用使用call关键字 存储过程更加侧重于封装以及预编译sql语句,提高sql语句的复用性. 存储过程中是使用in来接受参数,out来返回结果. 触发器 在mysql中,当我们执行一些操作的时候[比如dml操作 - 触发器能够触发的事件],一旦事件被触发,就会执行一段程序 触发器的本质上就是一个特殊的存储过程 分类 after触发器 - 在触发条件之后执行 before触发器 - 在触发条件之前执行 语法1234567891011-- 删除触发器drop trigger 触发器名称;delimiter //create trigger 触发器名称触发时机(after,before) 触发事件(insert,delete,update) on 触发器事件所在的表名for each row-- 触发器事件程序begin end //delimiter ; 体验 删除account表中的任意一条数据的时候[触发事件],并且把这条数据放入到备份表中acc_copy 12-- 创建备份表create table acc_copy select * from account where 1=2; 12345678910111213drop trigger acc_tri;delimiter //create trigger acc_triafter delete on accountfor each rowbegin -- old.列名 - 刚刚删除的那条数据 insert into acc_copy values(old.id,old.name,old.balance);end //delimiter ; -- 触发器是遇到触发的事件才会执行的.不是我们手动去调用的.delete from account where id=1; mysql&gt; select * from account; +—-+——+———-+ | id | name | balance | +—-+——+———-+ | 2 | tom | 10000.00 | | 3 | jack | 9000.00 | | 4 | ss | 9000.00 | | 5 | ss2 | 9000.00 | +—-+——+———-+ 4 rows in set (0.00 sec) mysql&gt; select * from acc_copy; +----+-------+---------+ | id | name | balance | +----+-------+---------+ | 1 | admin | 8000.00 | +----+-------+---------+ 1 row in set (0.00 sec) 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758592. 如果表和表之间存在约束关系,比如1:N,无论是在drop或者delete的时候.必须要先删除多的一方,然后再删除一的一方 必须先把一的一方的所有子记录全部删除完毕,才能删除一的一方 ~~~mysql drop table tri_cus; drop table tri_ord; create table tri_cus( id int(7) primary key, name varchar(20) ); insert into tri_cus values(1,&#x27;admin&#x27;); insert into tri_cus values(2,&#x27;tom&#x27;); create table tri_ord( id int(7) primary key, ord_no varchar(20), cus_id int(7), foreign key(cus_id) references tri_cus(id) ); insert into tri_ord values(1,&#x27;1001&#x27;,1); insert into tri_ord values(2,&#x27;1002&#x27;,1); insert into tri_ord values(3,&#x27;1003&#x27;,2); -- 外键约束存在的原因 mysql&gt; delete from tri_cus where id=1; ERROR 1451 (23000): Cannot delete or update a parent row: a foreign key constraint fails (`j03s`.`tri_ord`, CONSTRAINT `tri_ord_ibfk_1` FOREIGN KEY (`cus_id`) REFERENCES `tri_cus` (`id`)) -- 删除客户之前,应该先删除订单 drop trigger cus_tri; delimiter // create trigger cus_tri before delete on tri_cus for each row begin -- 先去删除这个客户的子记录 delete from tri_ord where cus_id=old.id; end // delimiter ; mysql&gt; delete from tri_cus where id=1; mysql&gt; select * from tri_cus; +----+------+ | id | name | +----+------+ | 2 | tom | +----+------+ 1 row in set (0.00 sec) mysql&gt; select * from tri_ord; +----+--------+--------+ | id | ord_no | cus_id | +----+--------+--------+ | 3 | 1003 | 2 | +----+--------+--------+ 1 row in set (0.00 sec) oracle数据库中还会多一个自检约束[自定义检测],check约束 但是Mysql中是不存在check约束. 123456789101112131415161718192021222324252627282930313233-- oracle - 使用check约束create table ckt( id int(7) primary key, age int(1) check(age&gt;0 and age&lt;100))-- 插入数据的时候,age插入的值只能在check约束自定义的规则之内,否则插入失败. -- 面试题 - mysql中如何实现oracle数据库中的check自检约束的功能.-- 在执行insert的时候,对某些数据进行进一步的校验 - 触发器create table ckt( id int(7) primary key, age int(1)); drop trigger ckt_tri;delimiter //create trigger ckt_tribefore insert on cktfor each rowbegin -- 对新插入的数据进行一个校验 -- old.列还是使用new.old列 - 看该列在表中有没有. if new.age&lt;18 then signal sqlstate &#x27;HY000&#x27; set message_text=&#x27;age不合法&#x27;; end if;end //delimiter ; insert into ckt values(1,20); insert into ckt values(2,17);mysql&gt; insert into ckt values(2,17);ERROR 1644 (HY000): age不合法 数据库优化 分表/分库 主从复制 sql优化操作 select查询列不要出现 * 1234尽量还是select 具体的列名称,select * 效率低于select 具体的列 - &quot;争议&quot;为了数据的安全. 不鼓励使用order by语句 1234mysql中的order by性能是及其低下,业务中如果遇到排序.建议是先把数据取出来放入到java内存中 - 集合中.再通过java代码的集合排序的各种方式来进行对数据的排序. 查询唯一的非索引列的值的时候,配合limit 1语句,避免全表扫描. 索引优化 sql优化 - 至少背10条 MySQL如何执行区分大小写的字符串比较？ 1select * from s_emp where binary first_name = &#x27;Carmen&#x27;; 应尽量避免在 where 子句中使用!=或&lt;&gt;操作符，否则将引擎进行全表扫描。 对查询进行优化，应尽量避免全表扫描，首先应考虑在where及order by涉及的列上建立索引。 应尽量避免在where子句中对字段进行not null值判断，否则将导致引擎放弃使用索引而进行全表扫描 尽量避免在where子句中使用or来连接条件，否则将导致引擎放弃使用索引而进行全表扫描，如： ​ select id from t where num=10 or num=20​ 可以这样查询：​ select id from t where num=10​ union​ select id from t where num=20 下面的查询也将导致全表扫描：(不能前置百分号) select id from t where name like ‘c%’;//走索引. not in也要慎用，否则会导致全表扫描，如： 12对于连续的数值，能用between就不要用in了：select id from t where num between 1 and 3 尽量避免在where子句中对字段进行表达式操作，这将导致引擎放弃使用索引而进行全表扫描。如：select id from t where num/2=100 12应改为:select id from t where num=100*2 应尽量避免在where子句中对字段进行函数操作，这将导致引擎放弃使用索引而进行全表扫描。如： 不要在where子句中的“=”左边进行函数、算术运算或其他表达式运算，否则系统将可能无法正确使用索引。 在使用索引字段作为条件时，如果该索引是复合索引，那么必须使用到该索引中的第一个字段作为条件时才能保证系统使用该索引，否则该索引将不会被使用，并且应尽可能的让字段顺序与索引顺序相一致。 遵循最左原则. 很多时候用exists代替in[查询性能很低]是一个好的选择： ​ select num from a where num in(select num from b)​ 用下面的语句替换：​ select num from a where exists(select 1 from b where num=a.num) 并不是所有索引对查询都有效，SQL是根据表中数据来进行查询优化的，当索引列有大量数据重复时，SQL查询可能不会去利用索引，如一表中有字段sex，male、female几乎各一半，那么即使在sex上建了索引也对查询效率起不了作用 - 索引有效 - 数据控制30%; 索引并不是越多越好，索引固然可以提高相应的 select 的效率，但同时也降低了 insert及update的效率，因为insert或update时有可能会重建索引，所以怎样建索引需要慎重考虑，视具体情况而定。一个表的索引数最好不要超过6个，若太多则应考虑一些不常使用到的列上建的索引是否有 必要。 应尽可能的避免更新 clustered [聚簇]索引数据列，因为clustered索引数据列的顺序就是表记录的物理存储顺序，一旦该列值改变将导致整个表记录的顺序的调整，会耗费相当大的资源。若应用系统需要频繁更新clustered索引数据列，那么需要考虑是否应将该索引建为clustered索引。 尽量使用数字型字段，若只含数值信息的字段尽量不要设计为字符型，这会降低查询和连接的性能，并会增加存储开销。这是因为引擎在处理查询和连接时会逐个比较字符串中每一个字符，而对于数字型而言只需要比较一次就够了。 尽可能的使用varchar/nvarchar代替char/nchar，因为首先变长字段存储空间小，可以节省存储空间，其次对于查询来说，在一个相对较小的字段内搜索效率显然要高些。 任何地方都不要使用select * from t，用具体的字段列表代替“*”，不要返回用不到的任何字段。 避免频繁创建和删除临时表，以减少系统表资源的消耗。 1临时表和表变量 - 推荐表变量来代替临时表的用法. 临时表并不是不可使用，适当地使用它们可以使某些例程更有效，例如，当需要重复引用大型表或常用表中的某个数据集时。但是，对于一次性事件，最好使用导出表。 在新建临时表时，如果一次性插入数据量很大，那么可以使用select into代替create table，避免造成大量log，以提高速度；如果数据量不大，为了缓和系统表的资源，应先create table，然后insert。 如果使用到了临时表，在存储过程的最后务必将所有的临时表显式删除，先truncate table，然后drop table，这样可以避免系统表的较长时间锁定。 尽量避免使用游标，因为游标的效率较差，如果游标操作的数据超过1万行，那么就应该考虑改写。 尽量避免大事务操作，提高系统并发能力。","categories":[{"name":"数据库","slug":"数据库","permalink":"http://example.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"}],"tags":[{"name":"mysql","slug":"mysql","permalink":"http://example.com/tags/mysql/"}]},{"title":"Mysql_课堂_索引专题_B+树_04","slug":"Mysql-课堂-索引专题-B+树-04","date":"2021-08-30T13:05:08.000Z","updated":"2021-08-30T13:21:00.409Z","comments":true,"path":"2021/08/30/Mysql-课堂-索引专题-B+树-04/","link":"","permalink":"http://example.com/2021/08/30/Mysql-%E8%AF%BE%E5%A0%82-%E7%B4%A2%E5%BC%95%E4%B8%93%E9%A2%98-B+%E6%A0%91-04/","excerpt":"","text":"索引底层原理 解释底层的索引的数据结构 - b+树 B+树 InnoDB 存储引擎中的 B+ 树索引。要介绍 B+ 树索引，就不得不提二叉查找树， 平衡二叉树和 B 树这三种数据结构。B+ 树就是从他们仨演化来的。 索引文件和数据文件 - innodb中 - 合二为一的 - 只有1个文件 索引文件和数据文件 - myisam中 - 分开独立的 - 俩个文件 二叉树 节点(每个圆圈圈)中存储了键（key - 主键索引列）和数据（data - 每一个行记录）。键对应 user 表中的 id，数据对应 user 表中的行数据。 二叉查找树的特点就是任何节点的左子节点的键值都小于当前节点的键值，右子节点的键值都大于当前节点的键值。顶端的节点我们称为根节点，没有子节点的节点我们称之为叶节点。 如果我们需要查找 id=12 的用户信息，利用我们创建的二叉查找树索引，查找流程如下： id=12先和根节点[只有一个]key=10,发现id=12&gt;id=10 - 顺利向着根节点的右边去匹配 id=12和非叶节点id=13的进行匹配,顺利执行id=13的左边 id=12和id=12比较 - 两者是相同的.由于每个节点除了保存key还保存了value[行记录 - 行真实的行数据] 直接将这个节点的value直接取出来了. 总结 - 总共匹配了3次就可以顺利找到我们的数据. 如果没有创建二叉树索引.查找id=12,必然会进行全表扫描.从表的第一行向下找.最好的状态也得找6次 平衡二叉树二叉树带来的弊端 二叉查找树的特点就是任何节点的左子节点的键值都小于当前节点的键值，右子节点的键值都大于当前节点的键值 二叉树在极端的场景下有可能成为一个链表的结构[链表的查询效率很低很低的.] 查找id=12,”链表结构”,只能从链表的头节点开始查找,最佳状态也得寻找找了5次. AVL为了解决这个问题[防止二叉树变成了链表结构导致查询效率依然低下]，我们需要保证二叉查找树一直保持平衡，就需要用到平衡二叉树. 平衡二叉树又称 AVL 树，在满足二叉查找树特性的基础上，要求每个节点的左右子树的高度差不能超过 1。 下面是平衡二叉树和非平衡二叉树的对比： 只要找到任何一个节点的左右子树高度差的绝对值大于1 - 非平衡二叉树 123节点45 - 左子树高度 = 左边的子节点的个数 = 2 - 右子树高度 = 右边没有节点 = 0 - |高度差|=2&gt;1 B树 平衡二叉树暴露出来了一些缺点: 每个节点仅仅保存一个key-value键值对[每个节点可保存的键值对数据太少了].每次进行查询的时候,实际上都是需要从磁盘中读取数据的. 那我们每查找一次数据就需要从磁盘中读取一个节点，也就是我们说的一个磁盘块 由于每个节点可保存的数据不多,仅仅保存了一个key-value.在查找数据的过程中,它就不断去和磁盘进行IO交互. 导致平衡二叉树的节点比较多.也就导致了平衡二叉树的高度比较高 - 导致比较的次数比较多 - 频繁和IO进行交互 - 查询效率低下. 为了解决平衡二叉树的高度太高问题.B树登场了. B树特点 根节点[第一页] - 永驻内存. 每个节点可以保存多个key-value - 导致子节点也会增多.B树又矮又胖. 没有子节点的节点 - 叶节点,有子节点的节点 - 非叶节点 B树的m阶 - m值就是看它最大的子节点的个数 - 3 , 下面的图代表的就是3阶b树. 如果有10亿条数据,只需要和磁盘进行交互2次.把磁盘块中的一页数据[16kb]全部加载到内存中. 页page的概念 - 那我们每查找一次数据就需要从磁盘中读取一个节点，也就是我们说的一个磁盘块 读取的单位是 - 页 - 1页的磁盘块的数据大小是16kb,每个节点可以更多的key-value 页与也之间是一个链表的结构 查找id=28的数据 - 磁盘交互了3次 ①id=28到第一页中进行匹配,发现id=28在17和35之间,获取p2指针.p2指向到页3 ②定位到页3,发现id=28在26~30之间,继续拿到p2指针,p2指向的是页8 ③定位到页8,顺利匹配查找到id=28这条数据 B+树 是Innodb和myisam存储引擎中索引底层的数据结构 - B+树 B树中每个节点中不仅仅存储key[索引列值,主键列值],还存储了数据.因为数据库中的页的大小是固定的[Innodb默认是16kb], 导致每个节点的存储资源有点浪费了. B+树和B树的重要区别就是 B+树中非叶节点,仅仅保存了key值[索引列,主键列值],没有保存数据.每个非叶节点可以保存更多的key. B+树中索引的所有的数据都放在了叶子节点中,而且是按照顺序排列的. 12345678910111213141516171819202122232425262728-- 演示一下顺序drop table tb;create table tb( -- 主键索引列 id int(7) primary key, name varchar(29));insert into tb values(1,&#x27;admin&#x27;);insert into tb values(3,&#x27;tom&#x27;); mysql&gt; select * from tb;+----+-------+| id | name |+----+-------+| 1 | admin || 3 | tom |+----+-------+ -- 再插入一条数据,但是id=2,介于1,3之间insert into tb values(2,&#x27;jack&#x27;);-- 出来的效果居然是排好序的.实际上是插入的时候,自动根据主键列索引排序后插入到合适的位置.+----+-------+| id | name |+----+-------+| 1 | admin || 2 | jack || 3 | tom |+----+-------+ **页与页之间是双向链表结构,**叶节点中的每个数据节点单向链表 下面这个图展示的是Innodb中的索引的结构.并不是Myisam中索引的结构 以下图示本质上就是聚簇索引的方式 - key - 主键列 聚簇索引和非聚簇索引在上节介绍 B+ 树索引的时候，我们提到了图中的索引其实是聚集索引的实现方式。 那什么是聚集索引呢？在 MySQL 中，B+ 树索引按照存储方式的不同分为聚集索引和非聚集索引。 这里我们着重介绍 InnoDB 中的聚集索引和非聚集索引： 聚集索引（聚簇索引）：以 InnoDB 作为存储引擎的表，表中的数据都会有一个主键，即使你不创建主键，系统也会帮你创建一个隐式的主键。 这是因为 InnoDB 是把数据存放在 B+ 树中的，而 B+ 树的键值就是主键，在 B+ 树的叶子节点中，存储了表中所有的数据。 这种以主键作为 B+ 树索引的键值而构建的 B+ 树索引，我们称之为聚集索引。 非聚集索引（非聚簇索引）：以主键以外的列值作为键值构建的 B+ 树索引，我们称之为非聚集索引。 非聚集索引与聚集索引的区别在于非聚集索引的叶子节点不存储表中的数据，而是存储该列对应的主键，想要查找数据我们还需要根据主键再去聚集索引中进行查找，这个再根据聚集索引查找数据的过程，我们称为回表。 聚簇索引存储和查找 12345select * from xx where id&gt;=18 and id&lt;41;-- 聚簇索引的查找方式 - 根据主键列id列进行查找的流程1. 先从页1中看id的区间,定位到p2-&gt;页32. 定位到页3,定位到p1-&gt;页8[叶节点-单向链表 - 查找必须从头节点开始找]3. 依次按照链表的顺序一致找到id开始&lt;41的这个节点.满足条件的叶节点中的数据全部查出来 [叶节点中保存了真实的数据] 非聚簇索引存储和查找 B+树的结构 表结构:id age name id - 主键列 - 默认是聚簇索引列 - 主键列 name - 非聚簇索引列 - 索引列 - 辅助索引 非聚簇索引 - 非主键列索引 - name列创建了索引 - 辅助索引. 结构: 根节点 - 一页数据 - 非聚簇索引列值 - name 非叶节点 - 非聚簇索引列值 页节点存储的东西 - name索引列以及该列对应的主键列值. 它和聚簇索引最大的区别是页节点中没有存储最终的数据.而是存储的是键值对x-y x就是非聚簇索引列值,y是对应的主键列值. 非聚簇索引的查找方式: 1select * from xxx where name=&#x27;Bob&#x27;; 按照B+树的查找流程 - 确认name=’Bob’的具体位置 由于非聚簇索引的结构中叶节点仅仅保存了name-主键列值 先根据name=’Bob’这个条件找到对应的主键列值id=15 要进行”回表操作” 继续拿着主键列id=15到索引的结构中继续查找一次 - “一次回表查找”. id也是聚簇索引 - B+树的结构 - 叶子节点中存储的就是数据. 根据聚簇索引列的查找方式 - id=15的叶节点 - 拿到里面的数据 非聚簇索引列查找一定会回表????? 未必 - 因为非叶节点中存储的就是索引列值. 查询**: select name from xx where name=’Blob’;** 不需要回表了.这条语句查询的结果name已经在非聚簇索引的非叶节点中保存了. 回表 根据一个非聚簇索引列查找 - 优先先到非聚簇索引的B+树中找到该列对应的主键列值[聚簇索引列值] 再拿着这个聚簇索引列的值再去到聚簇索引列的B+树中再查找一次 myisam中的索引特点 innodb中索引和数据合并到一个文件中 myisam中索引和数据是单独的俩个文件,分别是索引文件和数据文件. myisam中采用的是”非聚集的方式” 无论是聚簇索引还是非聚簇索引,查找方式是一样. 采用的也是B+树的结构**.只是叶节点中存储的是索引的列值以及该对应的行记录的地址.** 需要再根据行记录地址到表中进行定位[回表] 123456主键列 - key是不允许重复的非主键列 - key是允许重复的.select * from xxx where id=5;1. 先到B+树找到找到id=5对应的节点 - 取出里面的行记录的物理地址0x6a2. 回表 - 直接根据行记录的物理地址直接定位到具体的一行.","categories":[{"name":"数据库","slug":"数据库","permalink":"http://example.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"}],"tags":[{"name":"mysql","slug":"mysql","permalink":"http://example.com/tags/mysql/"}]},{"title":"Mysql_专题篇_索引基础_04","slug":"Mysql-专题篇-索引基础-04","date":"2021-08-30T12:51:35.000Z","updated":"2021-08-30T13:14:08.949Z","comments":true,"path":"2021/08/30/Mysql-专题篇-索引基础-04/","link":"","permalink":"http://example.com/2021/08/30/Mysql-%E4%B8%93%E9%A2%98%E7%AF%87-%E7%B4%A2%E5%BC%95%E5%9F%BA%E7%A1%80-04/","excerpt":"","text":"数据字典 用户表 - 自定义的表 - 存储用户的数据 系统表 - 数据字典 - 存储的是用户表的元信息. 用户表仅仅可能只是系统表中的一个字段存在着而已. 类似于java.lang.Class,所有的类都是属于Class的对象 - 类是用来描述对象.我们是可以通过Class对象的API来获取类的信息. Class用来描述类的类. demo tbl_comment 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849use information_schema;show tables;发现里面有一个系统表 - TABLE_CONSTRAINTS - 数据字典 - 保存的是所有的表的约束信息.desc table_constraints;+--------------------+--------------+------+-----+---------+-------+| Field | Type | Null | Key | Default | Extra |+--------------------+--------------+------+-----+---------+-------+| CONSTRAINT_CATALOG | varchar(512) | NO | | | || CONSTRAINT_SCHEMA | varchar(64) | NO | | | || CONSTRAINT_NAME | varchar(64) | NO | | | || TABLE_SCHEMA | varchar(64) | NO | | | || TABLE_NAME | varchar(64) | NO | | | || CONSTRAINT_TYPE | varchar(64) | NO | | | |+--------------------+--------------+------+-----+---------+-------+6 rows in set (0.01 sec)table_name,constraint_name,constraint_type表名 约束名称 约束类型--1. 查什么--2. 到哪里查-- 查看tbl_comment表中以上三个字段mysql&gt; select table_name,constraint_name,constraint_type from table_constraints where table_name=&#x27;tbl_comment&#x27;;+-------------+-------------------------+-----------------+| table_name | constraint_name | constraint_type |+-------------+-------------------------+-----------------+| tbl_comment | PRIMARY | PRIMARY KEY || tbl_comment | tbl_comment_id_fk | FOREIGN KEY || tbl_comment | tbl_comment_user_id_fk | FOREIGN KEY || tbl_comment | tbl_comment_video_id_fk | FOREIGN KEY |+-------------+-------------------------+-----------------+-- 查看tbl_comment表中的列的名称[COLUMN_NAME],列的数据类型[COLUMN_TYPE]mysql&gt; select column_name,column_type from columns where table_name=&#x27;tbl_comment&#x27;;+-------------+-------------+| column_name | column_type |+-------------+-------------+| id | int(7) || user_id | int(7) || video_id | int(7) || content | varchar(50) || comment_id | int(7) |+-------------+-------------+5 rows in set (0.00 sec) 索引基础篇简介:mysql中不同的存储引擎的索引的实现方式是不同的. 索引最大的好处就是会提高查询效率,但是索引也是占内存空间,索引也是需要进行维护[更新 - 消耗时间]的.并不是索引建立的越多越好. **5.7及其以后默认的存储引擎就是innodb,**之前默认采用的是myisam myisam和innodb有何区别 innodb支持事务,myisam不支持事务 [DTL命令是不支持的] myisam支持全文索引.但是innodb不支持全文索引. innode可以支持到行锁.myisam支持到表锁. 行锁的性能高于表锁. innodb支持b+树索引 - 笔试索引的底层原理 = B+树相关 innodb支持外键约束的. 索引的底层 - 见高级篇 MyISAM 有单独的索引文件的,索引过多 - 索引文件变大(占空间的) 叶子节点中保存的是索引+物理行地址的 索引的本质:键值对(索引列值,物理行地址) 先判断查询是否走了索引,先查询索引文件,找到物理行地址 再由地址直接定位到数据表. 索引是单独的文件 InnoDB 索引文件不是一个单独的文件,它和数据文件是合二为一的. 索引和数据-&gt;数据文件中 -&gt; 聚簇索引 索引算法 B+Tree(索引数据结构) 聚簇索引 - mysql会自动选择主键列作为聚簇索引列 非叶节点 - 聚簇索引列的值 叶节点 - 聚簇索引列值以及真实的数据. 非聚簇索引 非叶节点 - 非聚簇索引列的值 叶节点 - 键值对(非聚簇索引列的值,主键值) 优缺点 好处:加快了查询速度(select ) 坏处:降低了增,删,改的速度(update/delete/insert),增大了表的文件大小(索引文件甚至可能比数据文件还大) 索引类型 普通索引(index)：仅仅是加快了查询速度 1234给非唯一,非主键的列添加的索引.比如表中的某列字段经常被用来搜索,比如emailcreate index 索引名 on 表名(列名);-- 删除alter table 表名 drop index 索引名; 唯一索引(unique)：行上的值不能重复 1如果创建列的时候,给该列添加了唯一约束unique.那么这个列默认就是唯一索引. 主键索引(primary key)：不能重复 123456如果某列是主键列,那么该列默认就是索引列.-- 删除主键索引.索引索引自动创建的.索引名是系统自动分配的,特殊的名称PRIMARYalter table 表名 drop primary key;-- show index from 表名;-- 查看数据字典 - 保存了所有表的索引信息. 全文索引(fulltext):仅可用于 MyISAM 表，针对较大的数据，生成全文索引很耗时空间。 组合索引[覆盖索引]：为了更多的提高mysql效率可建立组合索引，遵循”最左前缀“原则。 123俩列作为一个整体 - 实际上是构成了一个索引.where province = ? and city = ? create index pro_city_index on xx(province,city); 索引语法创建索引总览1234CREATE TABLE table_name( [col_name data type] [unique|fulltext][index|key] [index_name](col_name[length]) [asc|desc]) unique|fulltext为可选参数，分别表示唯一索引、全文索引 index和key为同义词，两者作用相同，用来指定创建索引 col_name为需要创建索引的字段列，该列必须从数据表中该定义的多个列中选择 index_name指定索引的名称，为可选参数，如果不指定，默认col_name为索引值 length为可选参数，表示索引的长度，只有字符串类型的字段才能指定索引长度 asc或desc指定升序或降序的索引值存储 索引使用方式 查看某张表上的所有索引 show index from tableName [\\G,如果是在cmd窗口，可以换行]; 建立索引 CREATE INDEX 索引名 ON 表名(列值) 删除索引 - alter table 表名 drop index 索引名; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273drop table index_test;create table index_test( id int(7) primary key, a int(7), b int(7), c varchar(20), d varchar(20));insert into index_test values(1,100,10,&#x27;aaa&#x27;,&#x27;A&#x27;);insert into index_test values(2,300,30,&#x27;aba&#x27;,&#x27;BB&#x27;);insert into index_test values(3,200,20,&#x27;caa&#x27;,&#x27;CC&#x27;);insert into index_test values(4,100,10,&#x27;daa&#x27;,&#x27;DD&#x27;);insert into index_test values(5,500,50,&#x27;aad&#x27;,&#x27;FF&#x27;);-- 默认主键列就是属于索引列 - 主键索引mysql&gt; show index from index_test \\G;*************************** 1. row *************************** Table: index_test Non_unique: 0 Key_name: PRIMARY Seq_in_index: 1 Column_name: id Collation: A Cardinality: 5 Sub_part: NULL Packed: NULL Null: Index_type: BTREE Comment: Index_comment: 1 row in set (0.00 sec)-- 给a列单独创建一个索引 - 普通索引 - 非聚簇索引create index index_test_a on index_test(a);-- 删除普通索引alter table index_test drop index index_test_a;-- 创建一个组合索引 - 非聚簇索引-- 非聚簇索引 - 非主键列索引-- 聚簇索引 - 主键列索引-- a,b当成一个整体来处理 - 实际上仍然是只有一个索引create index index_test_a_b on index_test(a,b);-- 给定一个索引的长度key_len,列的数据类型应该是字符串类型create index index_test on index_test(c(1));比如c列是学生的名称王三王静静王老二王八犊子王静二王静三-- 给某列创建索引的目的就是为了提高根据该列进行查询的效率-- 索引长度是1,区分度不够.假设的是姓王的比较多.-- 并没有提高多少查询效率-- 目录页 -&gt; 王 -&gt; 2页到10页select * from student where c=&#x27;王静%&#x27;;-- 长度为2-- 目录页-- 王三 - 2页-- 王静 - 4页~5页-- 王老,王八....-- create index index_test on index_test(c(2));-- 前俩个select * from student where c=&#x27;王静%&#x27;;-- 如果很多位重复,如何处理.....-- 自己了解... alter table 表名 add primary key(列名) –不要加索引名，因为主键只有一个 删除非主键索引 alter table 表名 drop index 索引名； 1mysql&gt; 删除主键索引： alter table 表名 drop primary key; 查看查询是否使用到了索引1mysql&gt;explain select语句; 组合索引(5)复合索引 1create index 索引名 on 表(列1,列2,列n); 索引失效情况 面试题 - 数据库如何进行优化 - 谈到如何解决索引失效. 索引type从优到差：System–&gt;**const–&gt;eq_ref–&gt;ref–&gt;ref_or_null–&gt;index_merge–&gt;unique_subquery–&gt;index_subquery–&gt;**range–&gt;index–&gt;all(全表扫描的意思) 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162drop table index_test;create table index_test( id int(7) primary key, a int(7), b int(7), c varchar(20), d varchar(20));insert into index_test values(1,100,10,&#x27;aaa&#x27;,&#x27;A&#x27;);insert into index_test values(2,300,30,&#x27;aba&#x27;,&#x27;BB&#x27;);insert into index_test values(3,200,20,&#x27;caa&#x27;,&#x27;CC&#x27;);insert into index_test values(4,100,10,&#x27;daa&#x27;,&#x27;DD&#x27;);insert into index_test values(5,500,50,&#x27;aad&#x27;,&#x27;FF&#x27;);-- 复合索引create index index_test_abc on index_test(a,b,c);-- 测试explain - 测试查询是否使用到了索引.-- 测试主键索引mysql&gt; explain select * from index_test where id = 4;+----+-------------+------------+------------+-------+---------------+---------+---------+-------+------+----------+-------+| id | select_type | table | partitions | type | possible_keys | key | key_len | ref | rows | filtered | Extra |+----+-------------+------------+------------+-------+---------------+---------+---------+-------+------+----------+-------+| 1 | SIMPLE | index_test | NULL | const | PRIMARY | PRIMARY | 4 | const | 1 | 100.00 | NULL |+----+-------------+------------+------------+-------+---------------+---------+---------+-------+------+----------+-------+主要就是观察type=&#x27;const&#x27;;所谓创建索引 - 索引高级篇.索引文件采取一个数据结构[b+树]用来专门存放索引.为何根据索引查找比较快 - 先查索引[先查目录] - 进行定位到行的操作 - myisam中.myisam中索引文件和数据文件.独立存储的,也是分开的存储.1. 数据文件[磁盘上的]也就是所谓的表文件.加载到mysql内存中[select]. 表里面的每一行在内存中也有一个内存地址.2. 索引文件存储的是索引列的值以及该索引列对应的行记录的内存地址. 索引列 内存地址 1 0x7a 2 0x7b 3 0x7c 4 0x7d 5 0x7e myisam索引 - 键值对索引[键 - 索引列值,值 - 行记录的内存地址] 键值对存储在B+树中. select * from index_test where id = 4; 1. 根据id=4先到索引文件中去查找了[消耗时间的] 2. 找到id=4对应的行记录地址[唯一的映射关系] 3. 直接根据行记录地址定位到具体的一行,不需要在数据文件中进行一个全表扫描了.-- 测试非索引列的查询 dmysql&gt; explain select * from index_test where d = &#x27;DD&#x27;;+----+-------------+------------+------------+------+---------------+------+---------+------+------+----------+-------------+| id | select_type | table | partitions | type | possible_keys | key | key_len | ref | rows | filtered | Extra |+----+-------------+------------+------------+------+---------------+------+---------+------+------+----------+-------------+| 1 | SIMPLE | index_test | NULL | ALL | NULL | NULL | NULL | NULL | 5 | 20.00 | Using where |+----+-------------+------------+------------+------+---------------+------+---------+------+------+----------+-------------+1 row in set, 1 warning (0.00 sec)Type=&#x27;all&#x27; , 全表扫描 , 没有用到索引或者索引失效 , 从表里面的第一行一直扫描到最后一行 - 查询性能肯定是低下的. 遵循最左原则简介:针对的是复合索引 - 查询语句where最左边的列一定要和创建复合索引的第一个列保持一致. 复合索引(a,b,c) - 必须要连续. 12345678910111213141516171819202122232425262728293031323334-- 创建复合索引的第一个列acreate index index_test_abc on index_test(a,b,c);-- a,b,c都是生效的-100 | 10 | daaexplain select * from index_test where a=100 and b=10 and c=&#x27;daa&#x27;;-- key_len 是73,三个索引都走了.-- 比如b失效的场景,c也是失效explain select * from index_test where b=10;//不走索引explain select * from index_test where c=&#x27;daa&#x27;;//不走索引-- 不生效 - mysql5.7以后对where语句进行了优化.-- oracle中where语句如果跟了多个条件,执行顺序 - 从右到左-- mysql中where语句条件默认是从左到右的.-- mysql低版本中where c=&#x27;daa&#x27; and a=100;//不会走索引的-- mysql5.7优化,优化成where a=100 and c=&#x27;add&#x27;;//才会走索引.-- a走了索引,c没有索引 - 特殊的场景 - 底层优化了.explain select * from index_test where c=&#x27;daa&#x27; and a=100;-- key_len = 5-- a列索引生效explain select * from index_test where a = 100;-- key_len = 5-- a,b生效explain select * from index_test where a=100 and b=10;-- key_len = 10-- 如果仅仅是根据a列查询,key_len是5,但是此时key_len是10.说明a,b索引都生效.-- a列是走了索引,但是c列没有走索引-- 必须要连续.这个是时候a和c是不连续的,中间跳过了b.所以只有a是生效的,但是c是不生效的.explain select * from index_test where a=100 and c=&#x27;daa&#x27;;-- key_len=5 范围之后索引列也会失效12345-- a列和b列是走了索引的,但是c列没有走索引.因为c列是范围之后的判断mysql&gt;explain select * from index_test where a=100 and b&gt;10 and c=&#x27;daa&#x27;;-- 如果三个索引都生效 - key_len=73-- 如果只有a,b走索引 - key_len=10 √ 模糊查询123456789101112like &#x27;%&#x27;出现在末尾,仍然a,b,c都是走索引-- key_len = 73 - a,b,c都是走了索引的mysql&gt; explain select * from index_test where a=100 and b=10 and c like &#x27;d%&#x27;;-- like &#x27;%&#x27;如果出现在开始,不走索引的-- 只有a,b是走了索引的,c是没有走索引的-- key_len = 10 mysql&gt;explain select * from index_test where a=100 and b=10 and c like&#x27;%d&#x27;;-- 只有a,b是走了索引的,c是没有走索引的-- key_len=10mysql&gt;explain select * from index_test where a=100 and b=10 and c like&#x27;%d%&#x27;; 索引列使用函数12345678910索引列套在函数中使用,将会导致索引失效-- 进行了ALL全表扫描mysql&gt; explain select * from index_test where abs(id)=1;+----+-------------+------------+------------+------+---------------+------+---------+------+------+----------+-------------+| id | select_type | table | partitions | type | possible_keys | key | key_len | ref | rows | filtered | Extra |+----+-------------+------------+------------+------+---------------+------+---------+------+------+----------+-------------+| 1 | SIMPLE | index_test | NULL | ALL | NULL | NULL | NULL | NULL | 5 | 100.00 | Using where |+----+-------------+------------+------------+------+---------------+------+---------+------+------+----------+-------------+ 索引列参加了计算1234-- 导致索引列失效mysql&gt; explain select * from index_test where id+1=2;mysql&gt; explain select * from index_test where id = 2 - 1; 索引列参加运算符12345678910111213141516171819202122232425262728-- 给员工表的提成率列添加一个索引-普通索引create index s_emp_cp on s_emp(commission_pct);-- is null(没有走索引)和is not null(走索引)-- is null - type=&#x27;ALL&#x27;mysql&gt;explain select first_name,commission_pct from s_emp where commission_pct is null;+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-------------+| id | select_type | table | partitions | type | possible_keys | key | key_len | ref | rows | filtered | Extra |+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-------------+| 1 | SIMPLE | s_emp | NULL | ALL | s_emp_cp | NULL | NULL | NULL | 25 | 80.00 | Using where |+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-------------+-- is not null type=&#x27;range&#x27; - 走了索引的.mysql&gt; explain select first_name,commission_pct from s_emp where commission_pct is not null;+----+-------------+-------+------------+-------+---------------+----------+---------+------+------+----------+-----------------------+| id | select_type | table | partitions | type | possible_keys | key | key_len | ref | rows | filtered | Extra |+----+-------------+-------+------------+-------+---------------+----------+---------+------+------+----------+-----------------------+| 1 | SIMPLE | s_emp | NULL | range | s_emp_cp | s_emp_cp | 5 | NULL | 5 | 100.00 | Using index condition |+----+-------------+-------+------------+-------+---------------+----------+---------+------+------+----------+-----------------------+-- in(走索引 - range) not in(不走索引 - ALL)mysql&gt; explain select * from index_test where id in(1,2,3);mysql&gt; explain select * from index_test where id not in(1,2,3);-- 能用关联解决的,尽量不要使用not-- 找出没有选择任何一门课程的学生的信息 利用索引列查询出来的数据超过整张表的30%. 当数据量达到百万级别. 索引对应的重复的数据太多也是不适合创建索引的. city=’苏州’ 建立索引的策略 a. 索引不是越多越好的 因为索引也是需要占内容,也是需要到索引文件中去匹配索引的 - 需要消耗时间的. 更新数据的同时,我们更新索引数据. 主键列和唯一性列 √ 不经常发生改变的[在update列数据的数据的时候,也会更新索引文件] √ 满足以上2个条件,经常作为查询条件的列 √ 重复值太多的列 × null值太多的列 × 查询效率 数据库读写分离. 分表分库 - 水平分割和垂直分割 使用专门的搜索引擎 - es - elasticsearch/solr 避免使用索引查询导致索引失效 - 规避问题.","categories":[{"name":"数据库","slug":"数据库","permalink":"http://example.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"}],"tags":[{"name":"mysql","slug":"mysql","permalink":"http://example.com/tags/mysql/"}]},{"title":"Mysql_专题篇_索引高级_04","slug":"Mysql-专题篇-索引高级-04","date":"2021-08-30T12:51:20.000Z","updated":"2021-08-30T13:14:02.884Z","comments":true,"path":"2021/08/30/Mysql-专题篇-索引高级-04/","link":"","permalink":"http://example.com/2021/08/30/Mysql-%E4%B8%93%E9%A2%98%E7%AF%87-%E7%B4%A2%E5%BC%95%E9%AB%98%E7%BA%A7-04/","excerpt":"","text":"MySql索引B+树🌲 InnoDB 存储引擎中的 B+ 树索引。要介绍 B+ 树索引，就不得不提二叉查找树， 平衡二叉树和 B 树这三种数据结构。B+ 树就是从他们仨演化来的。 索引文件和数据文件 - innodb中 - 合二为一的. 索引文件和数据文件 - myisam中 - 分开独立的. 二叉树查找 从图中可以看到，我们为 user 表（用户信息表）建立了一个二叉查找树的索引。 图中的圆为二叉查找树的节点，节点中存储了键（key）和数据（data）。键对应 user 表中的 id，数据对应 user 表中的行数据。 二叉查找树的特点就是任何节点的左子节点的键值都小于当前节点的键值，右子节点的键值都大于当前节点的键值。顶端的节点我们称为根节点，没有子节点的节点我们称之为叶节点。 二叉树查找流程: 如果我们需要查找 id=12 的用户信息，利用我们创建的二叉查找树索引，查找流程如下： 将根节点作为当前节点，把 12 与当前节点的键值 10 比较，12 大于 10，接下来我们把当前节点&gt;的右子节点作为当前节点。 继续把 12 和当前节点的键值 13 比较，发现 12 小于 13，把当前节点的左子节点作为当前节点。 把 12 和当前节点的键值 12 对比，12 等于 12，满足条件，我们从当前节点中取出 data，即 id=12，name=xm。 利用二叉查找树我们只需要 3 次即可找到匹配的数据。如果在表中一条条的查找的话，我们需要 6 次才能找到。 平衡二叉树上面我们讲解了利用二叉查找树可以快速的找到数据。但是，如果上面的二叉查找树是这样的构造： 这个时候可以看到我们的二叉查找树变成了一个链表。如果我们需要查找 id=17 的用户信息，我们需要查找 7 次，也就相当于全表扫描了。 导致这个现象的原因其实是二叉查找树变得不平衡了，也就是高度太高了，从而导致查找效率的不稳定。 为了解决这个问题，我们需要保证二叉查找树一直保持平衡，就需要用到平衡二叉树了。 平衡二叉树又称 AVL 树，在满足二叉查找树特性的基础上，要求每个节点的左右子树的高度差不能超过 1。 下面是平衡二叉树和非平衡二叉树的对比： 左边二叉树的节点45左子树高度2，右子树高度0，左右子树高度差为2-0=2 在图二右边的AVL树上： 节点50的左子树高度为3，右子树高度为2，BF= 3-2 = 1； 节点45的左子树高度为2，右子树高度为1，BF= 2-1 = 1； 节点46的左子树高度为0，右子树高度为0，BF= 0-0 = 0； 节点65的左子树高度为0，右子树高度为1，BF= 0-1 = -1； 对于平衡二叉树，BF的取值范围为[-1,1]。如果发现某个节点的BF值不在此范围，则需要对树进行调整。 B树🌲因为内存的易失性。一般情况下，我们都会选择将 user 表中的数据和索引存储在磁盘这种外围设备中。 但是和内存相比，从磁盘中读取数据的速度会慢上百倍千倍甚至万倍，所以，我们应当尽量减少从磁盘中读取数据的次数。另外，从磁盘中读取数据时，都是按照磁盘块来读取的，并不是一条一条的读。 如果我们能把尽量多的数据放进磁盘块中，那一次磁盘读取操作就会读取更多数据，那我们查找数据的时间也会大幅度降低。如果我们用树这种数据结构作为索引的数据结构，那我们每查找一次数据就需要从磁盘中读取一个节点，也就是我们说的一个磁盘块。我们都知道平衡二叉树可是每个节点只存储一个键值和数据的。那说明什么？说明每个磁盘块仅仅存储一个键值和数据！那如果我们要存储海量的数据呢？ 可以想象到二叉树的节点将会非常多，高度也会极其高，我们查找数据时也会进行很多次磁盘 IO，我们查找数据的效率将会极低！ 为了解决平衡二叉树的这个弊端，我们应该寻找一种单个节点可以存储多个键值和数据的平衡树。也就是我们接下来要说的 B 树 B 树（Balance Tree）即为平衡树的意思，下图即是一棵 B 树 图中的 p 节点为指向子节点的指针，二叉查找树和平衡二叉树其实也有，因为图的美观性，被省略了。 图中的每个节点称为页，页就是我们上面说的磁盘块，在 MySQL 中数据读取的基本单位都是页，所以我们这里叫做页更符合 MySQL 中索引的底层数据结构。 从上图可以看出，B 树相对于平衡二叉树，每个节点存储了更多的键值（key）和数据（data），并且每个节点拥有更多的子节点，子节点的个数一般称为阶，上述图中的 B 树为 3 阶 B 树，高度也会很低。 基于这个特性，B 树查找数据读取磁盘的次数将会很少，数据的查找效率也会比平衡二叉树高很多。 假如我们要查找 id=28 的用户信息，那么我们在上图 B 树中查找的流程如下： 先找到根节点也就是页 1，判断 28 在键值 17 和 35 之间，那么我们根据页 1 中的指针 p2 找到页 3。 将 28 和页 3 中的键值相比较，28 在 26 和 30 之间，我们根据页 3 中的指针 p2 找到页 8。 将 28 和页 8 中的键值相比较，发现有匹配的键值 28，键值 28 对应的用户信息为（28，bv）。 B+树🌲B+ 树是对 B 树的进一步优化。让我们先来看下 B+ 树的结构图： B+ 树和 B 树有什么不同: B+ 树非叶子节点上是不存储数据的，仅存储键值，而 B 树节点中不仅存储键值，也会存储数据。 之所以这么做是因为在数据库中页的大小是固定的，InnoDB 中页的默认大小是 16KB。 如果不存储数据，那么就会存储更多的键值，相应的树的阶数（节点的子节点树）就会更大，树就会更矮更胖，如此一来我们查找数据进行磁盘的 IO 次数又会再次减少，数据查询的效率也会更快。 一般根节点是常驻内存的，所以一般我们查找 10 亿数据，只需要 2 次磁盘 IO。 因为 B+ 树索引的所有数据均存储在叶子节点，而且数据是按照顺序排列的。 那么 B+ 树使得范围查找，排序查找，分组查找以及去重查找变得异常简单。而 B 树因为数据分散在各个节点，要实现这一点是很不容易的。有心的读者可能还发现上图 B+ 树中各个页之间是通过双向链表连接的，叶子节点中的数据是通过单向链表连接的。其实上面的 B 树我们也可以对各个节点加上链表。这些不是它们之前的区别，是因为在 MySQL 的 InnoDB 存储引擎中，索引就是这样存储的。 也就是说上图中的 B+ 树索引就是 InnoDB 中 B+ 树索引真正的实现方式，准确的说应该是聚集索引（聚集索引和非聚集索引下面会讲到）。通过上图可以看到，在 InnoDB 中，我们通过数据页之间通过双向链表连接以及叶子节点中数据之间通过单向链表连接的方式可以找到表中所有的数据。 MyISAM 中的 B+ 树索引实现与 InnoDB 中的略有不同。在 MyISAM 中，B+ 树索引的叶子节点并不存储数据，而是存储数据的文件地址。 聚簇索引和非聚簇索引在上节介绍 B+ 树索引的时候，我们提到了图中的索引其实是聚集索引的实现方式。 那什么是聚集索引呢？在 MySQL 中，B+ 树索引按照存储方式的不同分为聚集索引和非聚集索引。 这里我们着重介绍 InnoDB 中的聚集索引和非聚集索引： 聚集索引（聚簇索引）：以 InnoDB 作为存储引擎的表，表中的数据都会有一个主键，即使你不创建主键，系统也会帮你创建一个隐式的主键。 这是因为 InnoDB 是把数据存放在 B+ 树中的，而 B+ 树的键值就是主键，在 B+ 树的叶子节点中，存储了表中所有的数据。 这种以主键作为 B+ 树索引的键值而构建的 B+ 树索引，我们称之为聚集索引。 非聚集索引（非聚簇索引）：以主键以外的列值作为键值构建的 B+ 树索引，我们称之为非聚集索引。 非聚集索引与聚集索引的区别在于非聚集索引的叶子节点不存储表中的数据，而是存储该列对应的主键，想要查找数据我们还需要根据主键再去聚集索引中进行查找，这个再根据聚集索引查找数据的过程，我们称为回表。 聚簇索引查找流程 select * from user where id&gt;=18 and id &lt;40 其中 id 为主键，具体的查找过程如下： ①一般根节点都是常驻内存的，也就是说页 1 已经在内存中了，此时不需要到磁盘中读取数据，直接从内存中读取即可。 从内存中读取到页 1，要查找这个 id&gt;=18 and id &lt;40 或者范围值，我们首先需要找到 id=18 的键值。 从页 1 中我们可以找到键值 18，此时我们需要根据指针 p2，定位到页 3。 ②要从页 3 中查找数据，我们就需要拿着 p2 指针去磁盘中进行读取页 3。 从磁盘中读取页 3 后将页 3 放入内存中，然后进行查找，我们可以找到键值 18，然后再拿到页 3 中的指针 p1，定位到页 8。 ③同样的页 8 页不在内存中，我们需要再去磁盘中将页 8 读取到内存中。 将页 8 读取到内存中后。因为页中的数据是链表进行连接的，而且键值是按照顺序存放的，此时可以根据二分查找法定位到键值 18。 此时因为已经到数据页了，此时我们已经找到一条满足条件的数据了，就是键值 18 对应的数据。 因为是范围查找，而且此时所有的数据又都存在叶子节点，并且是有序排列的，那么我们就可以对页 8 中的键值依次进行遍历查找并匹配满足条件的数据。 我们可以一直找到键值为 22 的数据，然后页 8 中就没有数据了，此时我们需要拿着页 8 中的 p 指针去读取页 9 中的数据。 ④因为页 9 不在内存中，就又会加载页 9 到内存中，并通过和页 8 中一样的方式进行数据的查找，直到将页 12 加载到内存中，发现 41 大于 40，此时不满足条件。那么查找到此终止。 最终我们找到满足条件的所有数据，总共 12 条记录： (18,kl), (19,kl), (22,hj), (24,io), (25,vg) , (29,jk), (31,jk) , (33,rt) , (34,ty) , (35,yu) , (37,rt) , (39,rt) 。 下面看下具体的查找流程图: 非聚集索引查找数据 在叶子节点中，不再存储所有的数据了，存储的是键值和主键. 总结聚簇和非聚簇select * from xxx where name =”Jim”; name是非关键列,但是name同时也是索引列 - 非聚簇索引. 非叶节点 - 索引列对应的值. 叶节点 - 键值对(name索引值 - 主键值) 从图一中可以通过非聚簇索引列的值 -&gt; 确定到该索引列值对应的主键值id. 根据图一找到的主键id,然后进行一次回表操作.再继续按照聚簇索引的搜索方式来确定到具体的行记录 MyISAM - 索引***索引文件和数据文件是分开的.***B+树结构. 在 MyISAM 中，聚集索引和非聚集索引的叶子节点都会存储数据的文件地址。","categories":[{"name":"数据库","slug":"数据库","permalink":"http://example.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"}],"tags":[{"name":"mysql","slug":"mysql","permalink":"http://example.com/tags/mysql/"}]},{"title":"Mysql_DTL_数据库事务_03","slug":"Mysql-DTL-数据库事务-03","date":"2021-08-30T12:42:49.000Z","updated":"2021-08-30T12:49:06.100Z","comments":true,"path":"2021/08/30/Mysql-DTL-数据库事务-03/","link":"","permalink":"http://example.com/2021/08/30/Mysql-DTL-%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BA%8B%E5%8A%A1-03/","excerpt":"","text":"DTL Data Transaction Language - 数据事务语言 commit,begin,start transction,savepoint,rollback 事务 只要使用客户端连接到mysql-server[mysql服务器],就会自动打开一个事务 在MYSQL中,所有的DML(insert,update,delete)操作在执行之后都会有一个commit操作[隐式的] commit - 提交事务 在ORACLE中,所有的DML(insert,update,delete)操作之后,如果没有手动commit,那么在另外一个事务中是读不到最新的更新数据的. DTL,数据事务语言 事务的定义: 就是指一组相关的SQL操作,我们所有的操作都是处在事务中的. 执行业务的基本单位是 - 不是sql,而是事务. 1234567891011121314151617181920212223242526java 代码 - 转账 public void transfer(int srcid,int targetid,double money)&#123; //设置不要自动提交模式 conn.setAutoCommit(false); Transaction tx = conn.beginTransaction();//开启一个事务 try&#123; //事务保证原子性 - 要么同时成功,要么同时失败. String sql = &quot;update xx set balance = balance-&quot;+money+&quot;where id=&quot;+srcid; //TODO... 执行sql,默认会自动提交事务的 -commit; //一旦是手动提交事务,那么上面的update操作仅仅是内存中的操作.尚未提交到db中. //其他代码... 出现了异常 , 手动提交 - 进入到catch String sql2 = &quot;update xx set balance = balance+&quot;+money+&quot;where id=&quot;+targetid; //TODO ... 执行sql默认会自动提交事务的 -commit; tx.commit(); &#125;catch (Exception e)&#123; //.. tx.rollback();//进行一个事务的回滚操作. &#125; &#125; 控制事务 - 就是控制事务的边界(事务的开始(begin) - 事务的结束(commit,rollback)) 一个事务的结束,代表着下一个事务的开始. 注意: 在数据库中**,执行业务的基本单位是事务,不是以某一条SQL** 数据库在默认情况下,事务都是打开的,也就是说它是一直 处在事务中的,一个事务的结束,代表着下一个事务的开启 执行commit或者rollback指令时,会结束当前事务 [已经提交的事务将不能够被回滚 - 已经不处于同一个事务中了,而事务与事务之间是隔离的] 作用:用来保证数据的平稳性和可预测性. 事务的四大特性(ACID): - 笔试 Atomicity,原子性,事务是不可再分割的,要么同时成功,要么同时失败. 转账业务(账户+money,账户-money - 一组sql - 至于一个事务当中,并且要保证原子性.) Consistency,一致性,事务一旦结束,内存中的数据和数据库中的数据是保持一致的 example：A用户和B用户进行转账1000元，A账户减少1000和B账户增加1000的sql语句必须全部执行成功，不存在一半成功，一半失败。但是无论如何执行，两个账户金额的改变加起来一定1000元，这就是一致性(数据的完整性)。 Isolation,隔离性,事务之间互不干扰,一多个用户并发访问数据库，比如同时操作一张表。数据库为每一个用户开启事务。每个事务相互独立，互不干扰。 Durability,持久性,事务一旦提交,则内存中的数据持久化[保存,序列化]到数据库中,永久保存 [涉及到数据库的备份和恢复的一些技术,冷备份,热备份…] DB - sqlData数据文件以及log目录[日志文件 - 记录了用户的sql操作] 事务控制语句DTL - 事务控制语言. BEGIN或START TRANSACTION；显式地开启一个事务； COMMIT；也可以使用COMMIT WORK，不过二者是等价的。COMMIT会提交事务，并使已对数据库进行的所有修改成为永久性的； ROLLBACK；有可以使用ROLLBACK WORK，不过二者是等价的。回滚会结束用户的事务，并撤销正在进行的所有未提交的修改； SAVEPOINT identifier；SAVEPOINT允许在事务中创建一个保存点，一个事务中可以有多个SAVEPOINT； RELEASE SAVEPOINT identifier；删除一个事务的保存点，当没有指定的保存点时，执行该语句会抛出一个异常； ROLLBACK TO identifier；把事务回滚到标记点； SET TRANSACTION；用来设置事务的隔离级别。InnoDB存储引擎提供事务的隔离级别有READ UNCOMMITTED、READ COMMITTED、REPEATABLE READ和SERIALIZABLE。 rollback - demo - 回滚所有 前提 - 设置成手动提交事务 注意:1. 如果没有设置事务点 - rollabck撤销所有的dml操作的 注意的是rollback只能撤销/回滚尚未提交的事务.如果一个事务已经提交了,那么是回滚不了的 设置事务点 命令 - savepoint 事务点名称; rollback to 事务点名称. 效果就是会撤销到设置事务点下方的dml操作.事务点之前的dml操作将不会撤销 MYSQL 事务处理主要有两种方法自动开始事务 当我们mysql客户端连接到mysql服务器 - 自动开启 当执行完sql语句之后,自动会commit[事务的提交 - 意味着当前事务已经结束] 一个事务的结束意味着下一个事务的开始. commit/rollback - 结束事务. 手动开启事务 执行dml操作之后,就不会自动提交事务[commit],需要手动commit 用 BEGIN, ROLLBACK, COMMIT来实现 1-1. BEGIN 开始一个事务 1-2. start transaction - 手动开始一个事务 ROLLBACK 事务回滚 COMMIT 事务确认 demo01 A事务 - 执行了delete操作,但是还没有commit. 但是在A事务当中,查询的时候,是可以查询到delete的效果的 mysql&gt;begin; 但是在另外一个事务B中,是看不到A事务中尚未提交的数据的[仍然是可以看到id=2这条数据的] 对A事务进行一个commit操作 12mysql&gt; commit;Query OK, 0 rows affected (0.01 sec) 对于B事务来讲,分俩种情况.第一种情况是B一开始的事务还未提交,看到的效果是 12345678mysql&gt; select * from video_copy;+----+--------------+-------+---------------------+-------------+| id | title | likes | create_time | tbl_user_id |+----+--------------+-------+---------------------+-------------+| 1 | java无敌 | 200 | 2021-08-19 13:38:38 | 1 || 2 | python不错 | 200 | 2021-08-19 13:39:45 | 1 |+----+--------------+-------+---------------------+-------------+2 rows in set (0.00 sec) B事务提交,也结束了当前的事务,自动开启一个新的事务,在新的事务中重新再查一次,可以看到A事务提交的结果了. 12345678910mysql&gt; commit;Query OK, 0 rows affected (0.00 sec)mysql&gt; select * from video_copy;+----+------------+-------+---------------------+-------------+| id | title | likes | create_time | tbl_user_id |+----+------------+-------+---------------------+-------------+| 1 | java无敌 | 200 | 2021-08-19 13:38:38 | 1 |+----+------------+-------+---------------------+-------------+1 row in set (0.00 sec) 直接用 SET 来改变 MySQL 的自动提交模式: 2-1. SET AUTOCOMMIT=0 禁止自动提交 2-2. SET AUTOCOMMIT=1 开启自动提交 注意:设置成禁止自动提交的操作的话,这个操作仅仅是针对当前的会话窗口有效. 多事务的并发处理机制原因:多个事务同时操作一个表中的同一行数据(争抢临界资源),如果这些操作是.修改操作的话,就会产生并发问题,如果不处理,则会造成数据不一致的情况. 数据库可能产生的并发问题包括: 脏读 简介:一个事务读取到了另外一个事务中尚未提交的数据. 是指一个事务正在访问数据,并且对这个数据进行修改,而这种修改还没有提交到数据库中,而另一个事务也访问了这个数据,并且使用了这个数据解决方法:一个事务在修改数据时,该数据不能被其他事务访问 1&gt;&gt;所有的数据库都是拒绝脏读 - &quot;会读到脏数据&quot;. 不可重复读 是指一个事务多次读取同一条记录,如果此时另一个事务也访问并且修改了该数据,则就会出现多次读取出现数据不一致的情况,原来的数据变成了不可重复读取的数据解决方法:只有在修改事务完全提交过后才可以读取到数据 幻读 是指一个事务修改表中的多行记录[比如查询也是可以的],但是此时另一个事务对该表格进行了插入数据的操作,则第一个事务会发现表格中会出现没有被修改的行就像发生了幻觉一样解决方法:在一个事务提交数据之前,其他事务不能添加数据 不可重复读的重点是修改，同样的条件，你读取过的数据，再次读取出来发现值不一样了幻读的重点在于新增或者删除 事务隔离级别 READ UNCOMMITTED 这是事务最低的隔离级别，它允许另外一个事务可以看到这个事务未提交的数据。解决第一类丢失更新的问题，但是会出现脏读、不可重复读. READ COMMITTED 保证一个事务修改的数据提交后才能被另外一个事务读取，即另外一个事务不能读取该事务未提交的数据。解决第一类丢失更新和脏读的问题，但会出现不可重复读. REPEATABLE READ 简介:mysql默认的事务的隔离级别. 保证一个事务相同条件下前后两次获取的数据是一致的解决第一类丢失更新，脏读、不可重复读. SERIALIZABLE - 串行化 事务被处理为顺序执行。解决所有问题 - 有点类似于锁表. 性能及其低下. 提醒：Mysql默认的事务隔离级别为repeatable_read 12mysql&gt;set session transaction isolation level read uncommitted;mysql&gt;select @@tx_isolation; 总结 事务隔离级别 脏读 不可重复读 幻读 读未提交(read uncommitted) √ √ √ 读已提交-(read committed) - 不可重复读 × √ √ 可重复读(repeatable read) × × √ 串行化(serializable) × × × 事务的演示准备工作1234567drop table account;create table account( id int(7) primary key, name varchar(20), balance double(7,2));insert into account values(1,&#x27;admin&#x27;,1000.00),(2,&#x27;tom&#x27;,2000.00); 脏读 设置事务的隔离级别READ UNCOMMITTED - 一个事务才可以读取到另外一个事务尚未提交的数据. 1set session transaction isolation level read uncommitted; ​ 总结-一旦事务设置成了读未提交的隔离级别.产生脏读以及不可重复读的效果 ​ 不可重复读 - 在同一个事务中,多次读取到的数据不一样 READ COMMITTED set session transaction isolation level read committed; 一个事务只能读取到另外一个事务中已经提交的数据 不会出现脏读了.但是仍然会出现不可重复读[一定是在同一个事务中多次读取到的结果是不一样的]. REPEATABLE READ 可重复读 - 在同一个事务中,多次读取到的数据是一样的[不关心其他事务做了什么] - mysql的默认的隔离级别 set session transaction isolation level repeatable read; SERIALIZABLE 最高的隔离级别 - 效率最低的 - 类似于锁表 set session transaction isolation level serializable; A事务在查看表的时候.其他事务是不能对这张表进行任何的DML[insert,update,delete]操作 . 不可重复读和幻读区别 set session transaction isolation level READ COMMITTED 读已提交 - 才可能产生不可重复读. 不可重复读 针对”update” 右边的窗口 - A事务,左边的窗口是 - B事务 A事务在查看某张表[查看一次①]的同时.B事务同时在对这张表进行update操作.并且B事务手动提交了事务 这个时候A事务在当前事务中[自己的事务还未提交]再次查看这张表.多次读取出现不一样的数据 - 不可重复读. 幻读 针对”insert和delete” 左边的窗口 - A事务,右边的窗口 - B事务 A事务在更新某张表的时候/或者查看这张表,B事务同时正在对这张表进行insert操作.并且B事务手动提交了事务 这个时候A事务继续查看这张表[确认一下自己的更新动作是否完成],这个时候发现表中**”居然好像还有未被更新的数据”**, 该条数据实际上是B事务已经插入进去的 - 对于A事务就好像产生了幻觉一样. 总结 事务的四大特性[ACID] DTL命令 解释四个隔离级别,默认的隔离级别是可重复读 脏读,不可重复读,幻读.","categories":[{"name":"数据库","slug":"数据库","permalink":"http://example.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"}],"tags":[{"name":"mysql","slug":"mysql","permalink":"http://example.com/tags/mysql/"}]},{"title":"Mysql_DDL_DML_02","slug":"Mysql-DDL-DML-02","date":"2021-08-30T12:30:01.000Z","updated":"2021-08-30T12:41:55.660Z","comments":true,"path":"2021/08/30/Mysql-DDL-DML-02/","link":"","permalink":"http://example.com/2021/08/30/Mysql-DDL-DML-02/","excerpt":"","text":"DDL DDL[Data Definition Language] - 数据定义语言 涉及到的sql命令如下: create命令 - 创建 创建表(table),视图(view),用户(user),函数(function),存储过程(procedure),数据库[database],约束(constraints) 以上构建的都是属于数据库DB的对象/单位 - DB的基本单位是table drop命令 - 删除 删除表(table),视图(view),用户(user),函数(function),存储过程(procedure),数据库[database],约束[constraints] 但是不能够删除表中具体行记录,是由delete命令 alter命令 - 修改 - 了解即可 修改列名,列的类型,修改约束.列的类型 - 使用情况很少 rename to - 修改表名 comment - 创建列的时候加上注释 truncate - 清空整张表 ORM思想 Obejct-Relational-Mapping - 对象关系映射 需要用到OO思想[第一步找出对象,分析对象的属性,分析对象的功能.考虑对象之间的关系]来进行实体类的设计 - 数据库的设计. 掌握目标 - 看到实体类-表结构.看到表结构-实体类. 映射规则: 实体名 - 表名 对象标识(id) - 主键(id) -primary key - [特点,非空且唯一] 普通属性 - 普通列[推荐俩者的名称保持一致.需要注意的是如果列是多个名称[匈牙利] - 小驼峰] 对象之间的关系 - 外键(foreign key) - 表与表之间是通过外键来进行关联[进行关联查询的基础] 通常情况下某张表的外键是指向另外一张表的主键的. 对象之间的关系 分析一个”小米商城”,利用OO思想,找出业务中的关键对象 登录,注册 - “用户User对象” - (id,phone,password,login_time,login_ip) 个人中心 - 其中有一块是用来负责展示用户的详情UserInfo 产品 产品详情 购物车 - id,商品id,商品名称,商品单价,num,小计算,总价,备注 订单 - 一个用户拥有多个订单,一个订单只能属于一个用户 产品分类表 1:N N:N 1:1 User和UserInfo: 一个用户匹配一个用户详情,一个用户详情仅属于一个用户 强调的是平等性 - 表设计中,外键可以出现在任何一方表中. 原则 - 能用单向关联解决的业务就不要使用双向关联. java实体类 12345678910111213141516171819202122232425现阶段的思想 - 实体类中没有外键的概念.-- 关系具有方向性-- 单向关联 - 关系的维护仅仅在其中一方存在.-- 根据第一表进行设计public class User&#123; private Integer id; private String phone; private String password; //一个用户拥有一个用户详情对象 private UserInfo userInfo; //现阶段 - 千万不要写成 - 对象里面是没有外键的概念的 //private Integer user_info_id;&#125;public class UserInfo&#123; private Integer id; private String header; private Gender sex;&#125; – 单向关联 - 第二张表 public class User{ private Integer id; private String phone; private String password; } public class UserInfo{ private Integer id; private String header; private Gender sex; private User user; } – ORM思想的精髓 - 如何进行映射以及为什么需要这种思想??? 未来的操作 - java代码去连接db - 查询user表中所有的数据 -&gt; List 取出每一行数据 - 创建一个user对象[数据在内存中的载体.对象特殊类型的数组] //db中的每一行数据 - java代码来进行获取 List users = new ArrayList&lt;&gt;(); 循环体中{ //jdbc代码 Integer id = rs.getInt(1); String phone = rs.getString(2); String passwrod = rs.getString(3); //使用对象来封装每一行数据 User user = new User(id,phone,password); users.add(user); } //未来学习了前端 - 后台list集合中的数据显示到网页上. – 双向关联 - 彼此之间相互维护 public class User{ private Integer id; private String phone; private String password; private UserInfo userInfo; } public class UserInfo{ private Integer id; private String header; private Gender sex; private User user; } 1232. 表设计 ![](Mysql-DDL-DML-02/onetoone01.png) ​ 1:N 一个用户对象和购物车对象 一个用户可以拥有多个购物车对象,但是一个购物车对象只能属于一个用户. 外键是存储在多的一方 实体类 1234567891011121314151617181920212223242526272829303132333435363738394041-- 单向关联01public class User&#123;//普通属性//一个用户拥有多个购物车private Set&lt;Cart&gt; carts;&#125;public class Cart&#123;//...&#125;-- 单向关联02public class User&#123;//普通属性&#125;public class Cart&#123;//...//一个购物车只能属于一个用户private User user;&#125;-- 双向关联public class User&#123;//普通属性//一个用户拥有多个购物车private Set&lt;Cart&gt; carts;&#125;public class Cart&#123;//...private User user;&#125; 表结构 User表 id phone password 1 110 123 2 114 123 3 115 123 购物车Cart表 2 2 mi02 1 1 1 mi01 1 3 3 mi03 2 4 4 mi04 2 id product_id product_name user_id 5 5 mi05 2 N:N 需要拆分成俩个一对多 一个学生可以选择多门课程, 一门课程可以被多个学生去选择. 比如:客户表,商品表,购买表 一个客户拥有多个商品 一个商品可以被多个用户购买. customer表 id cname 1 admin 2 tom product表 id pname price 1 mac 100000 2 xiaomi 8000 3 huawei 8000 4 联想 7000 需要建立第三方表,来确定customer表和product表的关系 . N:N-&gt;拆分成俩个1:N purcase表 - 购买表 采用的是联合主键[组合主键] 主键-primary key - 非空且唯一.作用:用来确定唯一元组[行] 所谓的”俩个1:n” - customer表和purcase表以及product表和purcase表 一个客户拥有多条购买记录[1:N] 一个产品拥有多条被购买记录[1:N] 主键列未必是单列[常见的id列] , N:N场景可以采取联合主键,主键列由俩列共同组成**(customer_id,product_id)** 外键列通常情况是引入另外一张表的主键列.在该表中.外键列有2列 分别是customer_id 引用了customer表中的id列 product_id引用了product表中的id列 customer_id product_id 1 1 1 2 2 1 2 3 2 4 另一种情况关于主键的选择.第三方表[用来维护关系的表],开发的时候,还是推荐给这张自己一个单独的主键列 id customer_id product_id 1 1 1 2 1 2 3 2 1 4 2 3 5 2 4 自关联 当前表中的外键列自关联到了自己表中的主键列 s_emp id first_name manager_id[上司id] 1 Carmen 2 Mark 1 3 tom 1 4 admin 2 5 jack 2 分析评论业务 以”抖音” User - Viedo 关注评论功能.一个用户可以评论多个视频.一个视频可以被多个用户进行评论 - N:N User表 id phone password username 1 110 123 吴签 2 114 123 霍针 3 115 123 孙岩 Viedo表 一个用户可以发布多个视频,但是一个视频只能由一个用户去发布 id 视频标题 视频点赞量 user_id 1 吴签 100万+ 2 2 霍针 100万+ 1 3 杨晓轩 10+ 3 4 孙岩 10+ 3 5 闫昊 10+ 3 评论表 - 重点 体现出谁评论了哪个视频即可.comment 外键列是可以为空的 id=5的人并不是直接对视频进行评论的 - 属于第二层评论,他是对id=1的这个人进行评论的 若comment_id为null,说明这个人是直接对视频进行评论的,属于业务的第一级评论 id 视频id user_id 评论内容 comment_pid 1 1 3 很羡慕 2 1 4 渣男 3 1 5 渣男 4 2 1 彼此彼此 5 2 5 你还是人么?你这样认为 1 除了评论还有回复…. 第一层 - 属于评论表的数据 第二层 - 对第一级的评论继续评论 第三层 - 对第二层及其以后的评论/回复 - 叫做回复. 回复表 一条评论可以引起多个回复 - reply id comment_id content replay_id user_id 1 5 难道你不羡慕吗 1 2 5 我羡慕 1 2 结构: 一条视频发出来id=5的视频 user_id=3: 很羡慕 ​ user_id=5:你还是人么?你这样认为 ​ user_id=1回复了user_id=5:难道你不羡慕吗 ​ user_id=2回复了user_id=1:我羡慕 表设计-三大范式 表设计一定尽可能去遵守三大方式.作用:指导db的设计更加合理化,避免数据的冗余. 笔试题中简答题. 1NF(第一范式):保证列的原子性.列不可再分割. 1234567891011s_emp(id,name);但是发现外国的name比较特殊.发现name列是可再分割的.不符合1NF.需要对name进行切割s_emp(id,first_name,last_name);address只需要包含省市区school(id,name,address);1 苏州大学 江苏省苏州市工业园区2 常州大学 江苏省常州市武进区3 苏州科技学院 江苏省苏州市高新区school(id,name,province,city,area); 2NF(第二范式):基于1NF,不存在非关键列部分依赖于关键列.非关键列要全部依赖于关键列 关键列 - 主键列;非关键列 - 非主键列 12345678910111213141516171819202122-- student,course表 - 所有的信息合并到一张表了.--1. student信息以及course信息都会存在数据的冗余性-- 如何确定主键列[单列,组合形式] - 能够确定唯一的一条行记录 - sid,cid-- db设计中,并不是表的数量或者列的数量越少越好的 - 满足三大范式-- 关键列(sid,cid),非关键列(sname,cname)-- ①(sid,cid) -&gt; 唯一确定 sname 实际上如果关键列中的部分列sid就可以确定了sname的值 sname只需要由关键列(sid,cid)中的部分列[也就是sid列]就可以确定了. 存在了非关键列sname部分依赖于关键列,违背了2NF-- ②(sid,cid) -&gt; 唯一确定 cnamestudent_course(sid,sname,cid,cname)sid sname cid cname1 tom 1 java1 tom 2 python2 admin 1 java2 admin 3 jack为了满足2NFstudent(sid,sname);//学生表 sid-&gt;snamecourse(cid,cname);//课程表 cid-&gt;cnamesc(sid,cid,score);//选课表 (sid,cid)-&gt; score 3NF(第三范式):基于2NF.不存在非关键列传递依赖于关键列.所有的非关键列要直接依赖于关键列 12345678910111213141516171819202122student(id,sname,uno,uname,address)1 tom x1001 苏州大学 江苏省2 jack x1002 社会大学 东北省3 james x1001 苏州大学 江苏省关键列只有id列①关键列id可以直接确定一个唯一的uno的②uno又可以直接确定唯一的一个uname③给定一个学生的id,也是可以确定一个唯一的unameid -&gt; uno -&gt; uname =&gt; id -&gt; unameuname是间接被id确定下来的-uname是间接依赖[通过一个uno传递依赖]于关建列id.违背了3NF,存在了非关键列传递依赖于关键列.所有的非关键列要直接依赖于关键列 - 所有的非关键列应该是直接被关键列来确定的.修改 - 拆分student(id,sname,uid);//uid就是大学的idid -&gt; uid(引用university表中的id列)university(id,uno,uname,adress)uid-&gt;uname 建表1234567891011CREATE TABLE 表名( 列名 数据类型[(长度)], 列2 数据类型[(长度)], ... ... 列 数据类型[(n)])ENGINE=InnoDB DEFAULT CHARSET=utf8;-- mysql5.7及其以上可以省略了ENGINE=InnoDB DEFAULT CHARSET=utf8;-- 前提是my.ini文件配置好了-- 指定我们的数据的存储引擎InnoDB,表编码是utf8 数据类型 列的数据类型就是用来限制你将来插入数据到该列的限制.该列是什么类型,就需要插入什么类型的数据 数字相关的 a. 整数 - int和bigint b. 小数 - float,double[使用最多],decimal 笔试题中:TINYINT(1个字节)或者smallint(2个字节) 字符串相关的 - mysql中字符串是用单引号表示的 a. char(n) - 固定长度 - 0-255 bytes[ascill] b. varchar(n) - 可变长度 - 0-65535 bytes[unicode的范围] c. text - 长文本数据 笔试题中:mysql中char和varchar的区别 1234567数字5代表的是该列可以存储的字符串的个数.不是代表字节数char(5) - 定长字符的意思是即时该列仅仅保存一个字母&#x27;a&#x27;,那么在内存中,char的实际消耗的长度就是5个 - &quot;浪费&quot; 对char类型的列的读写操作效率高于varcharvarchar(5) - 可变长度[最大可保存的字符串的长度],实际存储了一个字母&#x27;a&#x27;.实际也就只消耗了一个1长度 - &quot;节约了内存&quot; - 按需分配.因此,开发中尽可能字符串使用varchar,而不使用char. 日期 a. date -&gt; 即使保存的是年月日时分秒,查询出来的也仅仅只会显示到年月日 b. datetime-&gt;年月日时分秒.即使保存的数据仅仅是年月日.但是查询出来的时候,可以显示年月日时分秒 建表demo1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253drop table tbl_product;create table tbl_product( id int(3), name varchar(20), create_time date, price double(10,2));-- 分析括号中的参数-- int(3)-并不会影响该列可插入数据的一个范围.范围仍然是int型的范围-- 为了看出来int(3),修改一下建表语句-- int(13)想要看出来效果,这个列一定要加上zerofill,不足位数的用0填充create table tbl_product( id int(13) zerofill, name varchar(20), create_time date, price double(7,2));mysql&gt; insert into tbl_product values(1234,&#x27;tom&#x27;,now(),123.45);mysql&gt; select * from tbl_product;+---------------+------+-------------+--------+| id | name | create_time | price |+---------------+------+-------------+--------+| 0000000001234 | tom | 2021-08-19 | 123.45 |+---------------+------+-------------+--------+总结:int(n)此处的n不会影响插入到该列的数据的大小.那么n是配合zerofill来进行的.查询的时候,不足n位的数字全部用0填充.-- 修改表结构-测试varchar(n)中的n - 个数create table tbl_product( id int(7), name varchar(2), create_time date, price double(10,2));-- 如果varchar(n)设置成了2,但是插入了&#x27;tom&#x27;,报错-- ERROR 1406 (22001): Data too long for column &#x27;name&#x27; at row 1mysql&gt; insert into tbl_product values(1,&#x27;tom&#x27;,now(),123.45);-- 总结:varchar(n) - 中的n是代表的是字符的个数[一个汉字就是代表一个]-- double(m,n)-- m代表的是总长度,n代表的是精度 - double(7,2)create table tbl_product( id int(7), name varchar(20), create_time date, price double(7,1));mysql&gt; insert into tbl_product values(2,&#x27;admin&#x27;,&#x27;2021-10-01&#x27;,123456.56789);-- double(7,2) -&gt; 7就是总的长度,2代表的精度[四舍五入] - 123456.56789 -- 插入失败了 - Out of range value for column &#x27;price&#x27; at row 1-- 插入失败的原因是123456.57 -&gt; 这个结果已经超过了总的长度7了.-- 修改double(7,1) -&gt; 123456.56789 -&gt; 123456.6 -&gt; 仍然没有超过7这个总的长度的. - 可以被插入进去的 1234567891011mysql&gt; show tables;mysql&gt; desc tables;-- 查看建表语句mysql&gt; show create table tbl_product CREATE TABLE `tbl_product` ( `id` int(7) DEFAULT NULL, `name` varchar(20) DEFAULT NULL, `create_time` date DEFAULT NULL, `price` double(3,2) DEFAULT NULL ) ENGINE=InnoDB DEFAULT CHARSET=utf8 删除表 在不考虑有外键因素的情况下,可以直接删除表的 1DROP TABLE 表名; 约束constraint 作用:在插入到表中列的数据进行进一步的限制 约束类型 主键约束[primary key] - 非空且唯一.用来确定唯一的一行记录 - pk 非空约束[not null] - 非空 - 该列不能为null.必须插入值或者给定一个默认值 - nn 唯一约束[unique] - 唯一性 - nq 外键约束[foreign key] - 表与表之间的关系是通过外键来进行维护的.外键列一般是对应某张表的主键列.可以允许为null - fk 列级添加 优点:比较简单,缺点:不能给约束取名字 语法: 1234567CREATE TABLE 表名(列名 数据类型[(长度)] [约束类型1],列2 数据类型[(长度)] [约束类型2],......列 数据类型[(n)])ENGINE=InnoDB DEFAULT CHARSET=utf8; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849drop table tbl_product;create table tbl_product( id int(7) primary key comment &#x27;产品的id&#x27;,-- 给某列增加俩个约束,用空格隔开name varchar(20) not null unique comment &#x27;产品的名称&#x27;,-- 如果该列没有插入数据,则使用default给定的默认值create_date date not null default now(),-- 非空price double(7,2) not null);-- 死记住-- 如果上面的create_date使用的是date,给定默认值的时候,是不能直接使用now()函数的.如果想要给定默认值是now(),那么这个列必须是datetime-- 修改date类型列的默认值drop table tbl_product;create table tbl_product( id int(7) primary key comment &#x27;产品的id&#x27;,-- 给某列增加俩个约束,用空格隔开name varchar(20) not null unique comment &#x27;产品的名称&#x27;,-- 如果该列没有插入数据,则使用default给定的默认值create_date date not null default &#x27;2019-01-01&#x27;,-- 非空price double(7,2) not null);-- 演示primary keyinsert into tbl_product(id,name,price) values(1,&#x27;tom&#x27;,123.567);mysql&gt; select * from tbl_product;+----+------+-------------+--------+| id | name | create_date | price |+----+------+-------------+--------+| 1 | tom | 2019-01-01 | 123.57 |+----+------+-------------+--------+-- 继续插入一个id也是1的值insert into tbl_product(id,name,price) values(1,&#x27;admin&#x27;,123.567);ERROR 1062 (23000): Duplicate entry &#x27;1&#x27; for key &#x27;PRIMARY&#x27;-- 违背了primary key主键约束的规则 - 重复了.-- not null-- 没有给price插入值,但是该列存在一个not null非空约束insert into tbl_product(id,name) values (2,&#x27;tom&#x27;);-- ERROR 1364 (HY000): Field &#x27;price&#x27; doesn&#x27;t have a default value-- unique 唯一性,表中已经存在了一行记录是tominsert into tbl_product(id,name,price) values(2,&#x27;tom&#x27;,12.3);-- name字段/列值重复了.ERROR 1062 (23000): Duplicate entry &#x27;tom&#x27; for key &#x27;name&#x27; 表级添加 优势可以给约束命名,记住列级添加是不支持给列取名称的 not null非空约束以及default仅仅是支持列级添加的方式 12345678CREATE TABLE 表名(列名 数据类型[(长度)],列2 数据类型[(长度)],......列 数据类型[(n)],[constraint 约束名称] 约束类型(列))ENGINE=InnoDB DEFAULT CHARSET=utf8; 123456789101112131415161718192021222324drop table tbl_product;create table tbl_product( id int(7) comment &#x27;产品的id&#x27;,-- 给某列增加俩个约束,用空格隔开name varchar(20) not null comment &#x27;产品的名称&#x27;,-- 如果该列没有插入数据,则使用default给定的默认值create_date date not null default &#x27;2019-01-01&#x27;,-- 非空price double(7,2) not null,-- 给列添加约束-- 约束命名 - 表名_列名_约束类型缩写constraint tbl_product_id_pk primary key(id),constraint tbl_product_name_uq unique(name));insert into tbl_product values(1,&#x27;tom&#x27;,now(),1223.3);-- 让name违背了unique约束insert into tbl_product values(2,&#x27;tom&#x27;,now(),14.56);-- for key &#x27;约束名称&#x27;,如果采用的是列添加.系统会默认给定一个约束名称[就是列的名称]-- 默认的约束名=&#x27;name&#x27;和给定的约束名称&#x27;tbl_product_name_uq&#x27;-- 自定义的约束名称 - 精确定位错误的位置ERROR 1062 (23000): Duplicate entry &#x27;tom&#x27; for key &#x27;tbl_product_name_uq&#x27; 外键约束 foreign key - 简称fk.用来确定表之间的关系的.外键通常是是在多的一方. 1:N或者1:1 1234567891011121314151617181920212223242526272829303132drop table tbl_user;create table tbl_user( id int(7) primary key, username varchar(20) not null unique);insert into tbl_user values(1,&#x27;tom&#x27;);insert into tbl_user values(2,&#x27;admin&#x27;);drop table tbl_video;create table tbl_video( id int(7) primary key, title varchar(20), likes int(7), create_time datetime default now(), -- 外键列命名方式 表名_另外一张表的引用列名[主键列] -- 外键列的数据类型和长度和你引用的地方保持一致 tbl_user_id int(7), -- 表级添加 constraint tbl_video_table_user_id_fk foreign key(tbl_user_id) references tbl_user(id));-- 一旦创建了约束,插入数据的时候需要注意的是.-- 外键列是允许为空的.insert into tbl_video values(1,&#x27;学好myql&#x27;,100,now(),1);insert into tbl_video values(2,&#x27;学好java&#x27;,100,now(),1);insert into tbl_video values(3,&#x27;学习jdbc&#x27;,100,now(),2);-- 注意.既然已经定义了外键的约束.那么插入数据的时候,引用的外键列的值在另外一张表中一定要有行记录的-- tbl_user表中是不存在id=3的行记录的insert into tbl_video values(3,&#x27;mysql太简单了&#x27;,100,now(),3);-- 报错ERROR 1452 (23000): Cannot add or update a child row: a foreign key constraint fails (`j03s`.`tbl_video`, CONSTRAINT `tbl_video_table_user_id_fk` FOREIGN KEY (`tbl_user_id`) REFERENCES `tbl_user` (`id`)) N:N 123456789101112131415161718192021222324252627282930313233-- 评论表-- 一个用户可以对多个视频进行评论-- 一个视频可以被多个用户进行评论-- 拆分成俩个1:N-- 组合主键 + 列级添加drop table tbl_comment;create table tbl_comment( -- 组合主键 - 分别给俩个列都去定义了主键列 - 抛出错误ERROR 1068 (42000): Multiple primary key defined -- 认为这张表中存在俩个主键,这是不允许的. user_id int(7) references tbl_user(id), video_id int(7) references tbl_video(id), content varchar(50), -- 组合主键的正确定义方式 constraint tbl_comemnt_pk primary key(user_id,video_id), -- 外键的列级添加方式 comment_id int(7) references tbl_comemnt(id));-- 评论表拥有独立的主键id + 外键约束(表级添加方式)drop table tbl_comment;create table tbl_comment( id int(7) primary key, user_id int(7), video_id int(7), content varchar(50), comment_id int(7), constraint tbl_comment_user_id_fk foreign key(user_id) references tbl_user(id), constraint tbl_comment_video_id_fk foreign key(video_id) references tbl_video(id), constraint tbl_comment_id_fk foreign key(comment_id) references tbl_comment(id));insert into tbl_comment(id,user_id,video_id,content) values(1,1,1,&#x27;好的,我会学会mysql的&#x27;);insert into tbl_comment values(2,2,1,&#x27;好的,我会学会mysql的&#x27;,1); 建表补充 由一张表来构建另外一张表 保留原表的表结构+数据 1create table 表名 select语句; 123drop table video_copy;-- 保留原表中的所有的列的数据create table video_copy select * from tbl_video; 12drop table video_copy;create table video_copy select id,title from tbl_video; 保留原表的表结构 + 但是不需要原表的数据 12drop table video_copy;create table video_copy select id,title from tbl_video where 1=2; DML操作 insert 插入数据 delete 删除数据 update 更新数据 插入语句 语法一:给表中所有的列添加数据 插入的列值要和建表语句中列顺序以及列的类型以及列的约束高度保持一致. 1INSERT INTO 表名 VALUES(列值1,列值2,列值3,..,列值N) 语法二:给表中的指定列插入数据 1INSERT INTO 表名(列名1,列名2) VALUES(列值1,列值2); insert+select insert into 表名 select 语句; 把查询结果的数据插入到该表中 1234567-- 统计视频的被评论的用户量,并且保存到另外一张表中 video_id,comment_numdrop table comment_aly;create table comment_aly( video_id int(7),comment_num int(7));insert into comment_aly select video_id,count(user_id) from tbl_comment group by video_id; auto_increment mysql中的主键的生成策略 - 自增长策略 - auto_increment[默认的是从1开始,步长为1] oracle中的主键的生成策略 - 自增长 - sequence 应用场景:以后插入的时候[除非是模拟数据],id肯定是后台自动生成 - 唯一性. 123456789101112131415161718drop table comment_aly;create table comment_aly(id int(7) primary key auto_increment, video_id int(7),comment_num int(7));insert into comment_aly(video_id,comment_num) select video_id,count(user_id) from tbl_comment group by video_id;-- mysql中提供了一个函数last_insert()-- 查看最后一个id的插入的数据mysql&gt; select last_insert_id();-- 还希望模拟数据的时候接着使用这个自增长-- 修改自增长的初始值.mysql&gt; alter table comment_aly auto_increment=6;-- 比如数据就是自己插入进去的insert into comment_aly(video_id,comment_num) values(1,3); 补充 hive+hbase[分布式数据库] - 大数据 数据分析业务 数据的获取 1-1. 爬数据 - 爬虫 - 大公司都有反爬技术[前端的js算法是公开的.万一被破解了.需要重新制定算法] 爬虫工程师 = 低级的[网站没有反爬技术]和高级的[反爬] 12345678910验证发展历程 - 为了阻止程序模拟用户进行登录的过程.1. 早期是没有验证码 - 模拟用户登录的程序不断去尝试登录的过程. - 网站可能卡死2. 简单的文字或者数字框/弹出框 1+1=? 1+2=?3. 图片验证码 - 图像处理技术-识别出图像中的文字的 图片中文字尽可能做得非常非常非常模糊,颠倒 - 程序识别不出来.4. 手机验证/滑动块 - 区分程序在操作还是人操作 1-2. 日志文件 - 比如后台会记录用户的行为轨迹 - 透露出用户的爱好. 数据的清洗 日志文件/爬过来的数据 [字段比较多的.需要在有业务经验的基础之上]需要对若干个字段进行进一步的筛选工作. 把关心的和业务相关的字段清洗出来. 数据的分析 找出某个分类的共性的特征.比如代码好的-睡眠时间长,敲代码时间比较长等… 数据的挖掘 金融行业,房地产行业 根据数据分析的结果来预判下一次的结果 - 建模 理想状态中 -&gt; y = ax + b; 现实状态中,不可能得到一个100%的模型的 - 最优模型-最优的解-模型的准确率 x值,y值 -&gt; y=ax+b x y -&gt; z 8h 3h - &gt; good 8.5h 3.5h -&gt; good 1h 30min -&gt; error … … … … x和y与z之间的关系 未来接触到了新生,8.8h,10h -&gt; 可能是good[概率高于error] delete语句 清空表 - delete语句不带where 123delete from 表名;delete from video_copy; 带条件的删除 - 删除1条,不删除,删除多条 1234delete from 表名 where语句;-- 删除video_copy表中id=2的行记录delete from video_copy where id=2; update语句 更新的整张表的数据 - 不带where语句 123456789101112语法:-- 更新所有的行的单列update 表名 set 列名=新的列值;-- 更新所有的行的多列.update 表名 set 列1=新的列值1,列2=新的列值2,列n=新的列值n;-- 比如更新video_copy表中的likesupdate video_copy set likes=likes*1.1;-- 比如更新video_copy表中的likes和titleupdate video_copy set likes=200,title=&#x27;java无敌&#x27;; 更新指定条件的行记录 - where语句 12更新id=2的titleupdate video_copy set title=&#x27;python不错&#x27; where id=2; 总结约束注意点 列添加了约束,需要注意的地方有哪些 先删除多的一方表,再删除的一的一方的表 删除行记录的时候,需要先把这个行记录在其他表中被引用的行记录要全部删除之后,才能删除自己. 创建表的时候,应该先创建一的一方,然后创建多的一方 删除表123456789101112131415161718192021222324252627282930313233343536373839404142434445-- 删除表不是随意删除的 - 前提是创建了外键约束-- 先删除多的一方表,再删除的一的一方的表drop table tbl_comment;drop table tbl_user;drop table tbl_video;-- 用户表create table tbl_user( id int(7) primary key, username varchar(20) not null unique);insert into tbl_user values(1,&#x27;tom&#x27;);insert into tbl_user values(2,&#x27;admin&#x27;);-- 视频表create table tbl_video( id int(7) primary key, title varchar(20), likes int(7), create_time datetime default now(), -- 外键列命名方式 表名_另外一张表的引用列名[主键列] -- 外键列的数据类型和长度和你引用的地方保持一致 tbl_user_id int(7), -- 表级添加 constraint tbl_video_table_user_id_fk foreign key(tbl_user_id) references tbl_user(id));-- 一旦创建了约束,插入数据的时候需要注意的是.-- 外键列是允许为空的.insert into tbl_video values(1,&#x27;学好myql&#x27;,100,now(),1);insert into tbl_video values(2,&#x27;学好java&#x27;,100,now(),1);insert into tbl_video values(3,&#x27;学习jdbc&#x27;,100,now(),2);-- 评论表create table tbl_comment( id int(7) primary key, user_id int(7), video_id int(7), content varchar(50), comment_id int(7), constraint tbl_comment_user_id_fk foreign key(user_id) references tbl_user(id), constraint tbl_comment_video_id_fk foreign key(video_id) references tbl_video(id), constraint tbl_comment_id_fk foreign key(comment_id) references tbl_comment(id));insert into tbl_comment(id,user_id,video_id,content) values(1,1,1,&#x27;好的,我会学会mysql的&#x27;);insert into tbl_comment values(2,2,1,&#x27;好的,我会学会mysql的&#x27;,1); 分析删除表的顺序 12345678910-- 如果删除的是tbl_user或者tbl_video都会报错-- 报错的原因就是由外键约束存在导致的mysql&gt; drop table tbl_user;ERROR 1217 (23000): Cannot delete or update a parent row: a foreign key constraint failsmysql&gt; drop table tbl_video;ERROR 1217 (23000): Cannot delete or update a parent row: a foreign key constraint fails-- 应该要先删除子记录[外键所在的表中的记录],然后再删除父记录 - 先删除多的一方表,再删除的一的一方的表-- 多的一方的外键引用的是一的一方的主键. 删除行记录1234567891011121314151617-- id=2的用户是在tbl_comment中存在一条行记录的,它是被引用了.mysql&gt; delete from tbl_user where id=2;ERROR 1451 (23000): Cannot delete or update a parent row: a foreign key constraint fails (`j03s`.`tbl_comment`, CONSTRAINT `tbl_comment_user_id_fk` FOREIGN KEY (`user_id`) REFERENCES `tbl_user` (`id`))-- id=2的所有的评论的全部删除[删除子记录],然后再去删除id=2的用户mysql&gt; delete from tbl_comment where user_id=2;-- 然后才能去删除id=2的用户,已经把用户id=2这个用户的所有的评论全部删除了mysql&gt; delete from tbl_user where id=2;ERROR 1451 (23000): Cannot delete or update a parent row: a foreign key constraint fails (`j03s`.`tbl_video`, CONSTRAINT `tbl_video_table_user_id_fk` FOREIGN KEY (`tbl_user_id`) REFERENCES `tbl_user` (`id`))id=2的用户又发布了一条视频,它也在tbl_video表中被引用了.mysql&gt; delete from tbl_video where tbl_user_id=2;-- 等把id=2的用户的所有评论信息以及发布的视频全部删除完毕之后,才可以删除自己mysql&gt; delete from tbl_user where id=2; 约束的缺点 外键约束 - 保证数据的完整性和一致性.缺点 - 表之间的关系越强烈[手动创建了约束条件] - 表之间的耦合越高. 在下周DB设计 - 不要手动创建约束 - 弱化表之间的关系 - “表的关系 - 心中” 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960驰星CRM系统 - 学生信息,项目经理信息-- 假设一个项目经理可以教多个学生-- dev_id是外键列student(id,sname,school,dev_id);1 杨晓轩 文正养老学院 22 闫昊 八一农垦 13 刘静 八一农垦 2dev(id,dev_name,age);1 success 182 james 453 小强 19如果建表的时候create table student( //...foreign key(dv_id) references dev(id););-- 导致的后果,不能随意删除项目经理.项目经理只要有学生信息.就不能删除项目经理.-- 现实生活中 - success上台了,james开除了...mysql&gt; delete from dev where id=2;//删除失败了.因为james在student表中有子记录-- 要想删除james,需要删除他所有的学生.实际的业务 - 肯定不允许我去删除&quot;宝贵的学生信息&quot;-- 目标 - 1. 成功删除项目经理-- 2. 知道学生曾经是哪个老师带过的.-- 因此,在建表的时候,其实是允许数据的冗余性的.drop table t_student;drop table dev;create table dev( id int(7) primary key auto_increment,dev_name varchar(20),age int(3));insert into dev values(1,&#x27;success&#x27;,18);insert into dev values(2,&#x27;james&#x27;,45);create table t_student( id int(7) primary key auto_increment,sname varchar(20),school varchar(20),-- 此处没有进行约束的添加 - &quot;关系在心中即可&quot;dev_id int(7),-- 数据的冗余 - 防止项目经理的记录被删除dev_name varchar(20));insert into t_student values(1,&#x27;杨晓轩&#x27;,&#x27;文正养老学院&#x27;,2,&#x27;james&#x27;);insert into t_student values(2,&#x27;闫昊&#x27;,&#x27;八一农垦&#x27;,1,&#x27;success&#x27;);insert into t_student values(3,&#x27;刘静&#x27;,&#x27;八一农垦&#x27;,1,&#x27;success&#x27;);-- 虽然没有给dev_id列创建约束,业务分析可以确定该列就是用来&quot;维护俩表之间的关系的&quot;-- 查询学生的姓名以及项目经理的姓名以及年龄mysql&gt; select s.sname,d.dev_name,d.age from t_student s join dev d on s.dev_id=d.id;-- 开除james,没有约束,可以直接删除mysql&gt; delete from dev where id=2; 物理删除和逻辑删除 物理删除就是真正意义上的delete语句 逻辑删除 - 建议 - 比较安全. 因为数据是不能随意删除的.数据是需要后台进行数据分析的.用户的端的删除大部分都是逻辑删除. 实际上就是每张表都会增加逻辑列. 1234567891011121314151617drop table xx_del;create table xx_del( id int(7) primary key, name varchar(20), status int(7));insert into xx_del values(1,&#x27;tom&#x27;,0);insert into xx_del values(2,&#x27;admin&#x27;,0);-- 首页 - 加载xx_del表中所有的信息-- 查询逻辑列 - 把status=0的行记录全部加载List&lt;XX&gt; list = &quot;select * from xx_del where status=0&quot;;-- 删除按钮 - 删除 - 实际上是逻辑删 - 并不会执行delete语句,执行的是update语句update xx_del set status=1 where id=1;-- 再去根据status=0去加载,给用户端的感觉好像是这条记录被删除了.","categories":[{"name":"数据库","slug":"数据库","permalink":"http://example.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"}],"tags":[{"name":"mysql","slug":"mysql","permalink":"http://example.com/tags/mysql/"}]},{"title":"Mysql_DQL_查询","slug":"Mysql-DQL-查询-01","date":"2021-08-30T11:52:56.000Z","updated":"2021-08-30T12:28:49.358Z","comments":true,"path":"2021/08/30/Mysql-DQL-查询-01/","link":"","permalink":"http://example.com/2021/08/30/Mysql-DQL-%E6%9F%A5%E8%AF%A2-01/","excerpt":"","text":"数据库 数据库(Database - 简称DB) 数据按照一定的数据结构来进行组织,存储和管理的仓库. 学习的数据库mysql - 目前最主流的关系型数据库[免费的.现在属于oracle公司的] 安装的版本&gt;=5.7.x -&gt; 发展[mysql5.5.x,mysql5.6.x,mysql.5.7.x,mysql8.x] - 版本不一样,语法存在差异. SQL SQL - Structured Query Language - 结构化查询语言. 作用: 脚本文件 - 以.sql为脚本的文件 我们本质上就是通过sql语法/命令来操作我们的DB 按照功能来进行分类 DQL(Data Query Language) - 数据查询语言 - 也是整个sql的核心 - 最难的 select DML(Data Manipulation Language) - 数据操纵语言 insert update delete DDL(Data definition Language) - 数据定义语言 create alter drop DCL(Data Control Language) - 数据控制语言 grant[授权],revoke[取消权限] DTL(Data Transaction Language) - 数据事务语言 commit savepoint rollback 脚本文件 mysql中的script文件 - 是以.sql为后缀的文件. mysql - 数据库-由若干张表组成的仓库,数据是存储在一张二维**表[关系]**中的 如果一个数据库存储数据的格式是一个行和列组成表 - 关系[表格]型数据库 生成若干张表 表中插入若干条数据 准备工作##登录mysql 打开cmd mysql -u用户名 -p密码 1admindeMacBook-Pro:~ admin$ mysql -uroot -proot 创建仓库 MYSQL就是通过仓库的形式来管理我们的数据的. 语法:CREATE DATABASE 仓库名; sql的语法大小写是不敏感的. 12mysql&gt; create database j03s;Query OK, 1 row affected (0.00 sec) 查看所有的仓库12345678910mysql&gt; show databases;+--------------------+| Database |+--------------------+| information_schema || j03s || mysql || performance_schema || sys |+--------------------+ 使用仓库1mysql&gt; use j03s 查看所有的表1mysql&gt; show tables; 导入脚本1mysql&gt; source sql脚本文件的绝对路径; 1mysql&gt; source /Users/admin/Desktop/j03s_mysql_all/教学脚本/mysql_cn.sql; 该脚本文件中的表 123456789+----------------+| Tables_in_j03s |+----------------+| s_customer || s_dept || s_emp || s_ord || s_region |+----------------+ 继续导入 - 面试中常常使用到的一个脚本 12345678+----------------+| Tables_in_j03s |+----------------+| course || sc || student || teacher |+----------------+ 确认数据的编码 建议修改编码之后,建议重启mysql服务 右击计算机 - 管理 - 服务 - 服务和应用程序 - 右边的窗口 - mysql - 右击重启 1mysql&gt; show variables like &#x27;char%&#x27;; 123456789101112+--------------------------+-----------------------------------------------------------+| Variable_name | Value |+--------------------------+-----------------------------------------------------------+| character_set_client | utf8 || character_set_connection | utf8 || character_set_database | utf8 || character_set_filesystem | binary || character_set_results | utf8 || character_set_server | utf8 || character_set_system | utf8 || character_sets_dir | /usr/local/mysql-5.7.28-macos10.14-x86_64/share/charsets/ |+--------------------------+-----------------------------------------------------------+ 12需要对每一项进行单独的设置mysql&gt;set character_set_client=utf8; mysql插入中文乱码 检测上面的编码 my.ini文件在哪里 1234567[client]# 设置mysql客户端默认字符集default-character-set=utf8[mysqld]# 服务端使用的字符集默认为8比特编码的latin1字符集character-set-server=utf8 本身自己的cmd的编码 如果还有问题,卸载重来. 简单Query 属于DQL命令 - select命令 query语法 查询的本质 查什么 到哪里查[必须先使用数据库,然后才能查看这个库下的表] 1234-- 查询整张表的某些列SELECT 列1,列2,列n FROM 表名;-- 查询整张表中的所有列,*代表所有的列SELECT * FROM 表名; 查询表结构1234567891011desc 表名;mysql&gt; desc student;+-------+-------------+------+-----+---------+-------+| Field | Type | Null | Key | Default | Extra |+-------+-------------+------+-----+---------+-------+| id | int(10) | YES | | NULL | || sname | varchar(10) | YES | | NULL | || age | datetime | YES | | NULL | || sex | varchar(10) | YES | | NULL | |+-------+-------------+------+-----+---------+-------+ 查询练习 查询student表中的姓名sname 1mysql&gt; select sname from student; 查询student表中的学生信息 1mysql&gt; select * from student; 查询s_emp员工表中的first_name和last_name 1mysql&gt; select first_name,last_name from s_emp; 查询客户[s_customer]的姓名以及客户的电话号码 1mysql&gt; select name,phone from s_customer; 查询s_emp中的title列 1mysql&gt; select title from s_emp; 排重关键字distinct 列名 1mysql&gt; select distinct title from s_emp; 条件查询 query-conditional语法 如果查询语句后面不加where条件,查询的是整张表中的数据 需要对数据进行筛选,需要使用条件查询 语法 1234-- 查询满足条件表达式的数据SELECT 列1,列2,列nFROM 表名WHERE 条件表达式; 运算符 比较运算符 =,&gt;,&lt;,&gt;=,&lt;=,!=,&lt;&gt; 其他运算符 2-1. in(集合列表) 2-2. not in(集合列表) 2-3. between … and … 在 … 和 …区间 - 是一个闭区间 is null - 判断某列是否为空,注意判断是否为空,不能使用= is not null - 判断某列是否不为空,不能使用!= 逻辑运算符 not and - 用来连接多个条件的,多个条件同时为true,才能返回结果 or - 用来连接多个条件的,只要有一个条件成立,就会返回结果. 条件查询练习 查询工资高于1200的员工的信息[id,first_name,salary] 1mysql&gt; select id,first_name,salary from s_emp where salary&gt;1200; 把部门编号为41,42,43的员工信息查询出来 12345-- 写法使用in关键字 - db设计,表列命名不能使用mysql关键字mysql&gt; select id,first_name,dept_id from s_emp where dept_id in(41,42,43);-- 写法 - 使用or逻辑运算符mysql&gt; select id,first_name,dept_id from s_emp where dept_id=41 or dept_id=42 or dept_id=43; 查询工资在1200~1450之间的员工的信息 12345-- between .. and .. 闭区间mysql&gt; select id,first_name,salary from s_emp where salary between 1200 and 1450;-- and逻辑运算符mysql&gt; select id,first_name,salary from s_emp where salary&gt;=1200 and salary&lt;=1450; 查询title[职称]为Stock Clerk的员工信息 1234567-- 注意title列的数据类型varchar(25) - 字符串-- mysql中使用单引号来表示字符串mysql&gt; select id,first_name,title from s_emp where title=&#x27;Stock Clerk&#x27;;-- 具体存储的值全部换成小写 - 也是可以查询出来的.-- mysql5.7.x版本不仅仅是sql语法忽略了大小写,表中查询也是忽略的 - 但是不建议这样做.mysql&gt; select id,first_name,title from s_emp where title=&#x27;stock clerk&#x27;; 查询有提成[commission_pct]的员工信息 1mysql&gt; select id,first_name,commission_pct from s_emp where commission_pct is not null; 列别名和列的计算 我们可以给列重新命名 1234567891011121314-- 语法一:列1 列别名1 - 推荐使用的语法mysql&gt; SELECT 列1 列别名1,列2 列别名2 FROM 表名 [WHERE条件查询];mysql&gt; select id 编号,first_name 名字,salary 工资 from s_emp;-- 语法二: 列1 as 列别名1 - 不推荐使用mysql&gt;select id as 编号,first_name as 名字,salary as 工资 from s_emp;-- 语法三: mysql中可以使用双引号来保持/包裹格式-- 列1 &quot;列别名1&quot;mysql&gt; select id &quot;编号&quot;,first_name &quot;名字&quot;,salary &quot;工资&quot; from s_emp;-- 需求:希望列别名每个汉字间距一点[空一格]mysql&gt; select id &quot;编 号&quot;,first_name &quot;名 字&quot;,salary &quot;工 资&quot; from s_emp; mysql中的列支持计算的 12-- 查询员工的年薪mysql&gt; select first_name,salary*12 年薪 from s_emp; 练习 12-- 查询员工的年薪,但是要包括提成mysql&gt; select first_name,salary*12*(1+commission_pct/100) 年薪 from s_emp; 以上的查询结果 - 有提成的员工全部查询成功,没有提成的员工,计算年薪都是null 在mysql中null值直接进行计算,结果还是null值,因此一般需要对null值进行处理,如果是数字列为null.需要作为0来进行处理 mysql中内置了很多函数 - 空值置换函数 - coalesce(m,n) 计算规则类似于java中的三元操作符m==null?n:m 1mysql&gt; select first_name,salary*12*(1+coalesce(commission_pct,0)/100) 年薪 from s_emp; 模糊查询 使用like关键字 % - 占位符 - 代表任意多个任意字符 _ 占位符 - 代表任意单个任意字符 练习 比如查询teacher表中所有的李姓老师 1mysql&gt; select * from teacher where tname like &#x27;李%&#x27;; 比如查询first_name第三个字母是e的员工信息 1mysql&gt; select first_name from s_emp where first_name like &#x27;__e%&#x27;; 查询职称title中包含VP的并且工资高于1200的员工信息 1mysql&gt; select first_name,title,salary from s_emp where title like &#x27;%VP%&#x27; and salary&gt;1200; 查询first_name以M开头的员工信息 1mysql&gt; select first_name from s_emp where first_name like &#x27;M%&#x27;; 查询first_name中不包含字母n的员工信息 1mysql&gt; select first_name from s_emp where first_name not like &#x27;%n%&#x27;; 找出非41,42,43部门的员工 1mysql&gt; select first_name,dept_id from s_emp where dept_id not in(41,42,43); 转义字符 了解即可 12mysql&gt; update s_emp set first_name=&#x27;Car_men&#x27; where id=1;mysql&gt; update s_emp set first_name=&#x27;Ma_rk&#x27; where id=4; 需求 - 查询first_name中包含_的员工信息 1234567mysql&gt; select first_name from s_emp where first_name like &#x27;%_%&#x27;;默认的转义字符mysql&gt; select first_name from s_emp where first_name like &#x27;%\\_%&#x27;;自定义转义字符mysql&gt; select first_name from s_emp where first_name like &#x27;%?_%&#x27; escape &#x27;?&#x27;; 列的拼接功能 s_emp表中first_name[名]和last_name[姓] db设计满足三大范式.第一范式保证列的原子性 - 列不可再分割. 姓名 -姓一列+名一列 12&gt;-- 拼接的过程也使用到了内置函数concat(...) - 可变长列表&gt;mysql&gt; select concat(last_name,&#x27; &#x27;,first_name) 姓名 from s_emp; 排序 1-- 排序的语法SELECT 列1,列2,列nFROM 表名[WHERE 条件表达式][ORDER BY 列名] [asc | desc]; 练习 查看员工的信息,找出工资大于1200的,并且根据salary来升序 order by + 列的名称 1-- asc可以省略不写mysql&gt; select first_name,salary from s_emp where salary&gt;1200 order by salary; 1-- 如果是降序的,desc不能省略的mysql&gt; select first_name,salary from s_emp where salary&gt;1200 order by salary desc; order by + 列的序号 - 推荐使用的. 列的序号是查询语句中的列的序号,列的序号是从1开始的 1mysql&gt; select first_name,salary from s_emp where salary&gt;1200 order by 2; order by + 列别名 1mysql&gt; select first_name,salary _sal from s_emp where salary&gt;1200 order by _sal desc; 查看员工的信息,找出工资大于1200的,并且根据salary来降序.如果salary一样,那么继续根据first_name来进行一个升序. 1mysql&gt; select first_name,salary from s_emp where salary&gt;1200 order by 2 desc,1; 找出年薪高于21000的员工的信息[包括提成的],并且根据年薪降序排. 1mysql&gt; select first_name,salary*12*(1+coalesce(commission_pct,0)/100) year_salary from s_emp where salary*12*(1+coalesce(commission_pct,0)/100)&gt;21000 order by 2 desc; 为高级查询作个铺垫 - 子查询语法 - 精髓 - 就是把查询语句得到的表看成是真正的”临时表”. 12-- 分解 - &quot;临时表&quot;select first_name,salary*12*(1+coalesce(commission_pct,0)/100) year_salary from s_emp 123-- 整合-- select * from (另外一个查询语句) 表别名select * from (select first_name,salary*12*(1+coalesce(commission_pct,0)/100) year_salary from s_emp) core_ where year_salary&gt;21000 order by 2 desc; 高级查询-part01 - 最关键 多表查询,表和表之间的关系 - 通过外键列来维护的. RDBMS专业术语 主键列 外键列 - 确定好外键列是进行多表查询的前提,通常外键列是交给多的一方进行维护的 关联查询传统的写法 如果没有直接关系的俩张表,它们是不能够直接进行一个join操作. 错误的写法❌ - 笛卡尔积 1-- 查询员工(s_emp)的id,first_name以及这个员工所在的部门(s_dept)的id以及部门的名称mysql&gt; select id,first_name,id,name from s_emp,s_dept;ERROR 1052 (23000): Column &#x27;id&#x27; in field list is ambiguous如果查询的结果中出现多个表中同名的列,请你给表取别名,通过表别名.列名mysql&gt; select e.id,e.first_name,d.id,d.name from s_emp e,s_dept as d;总共出现了300条 = 25 * 12 进行筛选 - 去除错误的笛卡尔积 1mysql&gt; select e.id,e.first_name,d.id,d.name from s_emp e,s_dept as d where e.dept_id = d.id; 练习 3-1. 找出外键列 3-2. 去除笛卡尔积 1-- 找出区域在&#x27;Asia&#x27;的所有的员工信息mysql&gt; select e.first_name,r.name from s_emp e,s_dept d,s_region r where r.name=&#x27;Asia&#x27; and r.id = d.region_id and e.dept_id=d.id;-- 缺点 - 如果表的数量一旦增多,发现哪些表和哪些之间是否有直接的关系.我们体验不会太好 查看学生的姓名,课程的名字,以及该课程授课的老师的名字以及该学生在这门课的得分情况 student,course,teacher,sc 1mysql&gt;select s.sname,c.cname,t.tname,_sc.score from student s,course c,teacher t,sc _sc where _sc.sid = s.id and _sc.cid = c.id and c.tid = t.id; join+on写法 表 join 表 on 一的一方的主键 = 多的一方的外键. on的目的不是为了进行条件筛选 - 目的去除笛卡尔积 只要具有直接关系的俩张表才能够使用join进行连接 内连接 - 默认的inner join,但是inner可以省略不写 12-- 查询部门id为31的部门名称以及该部门下的员工的名字和薪水mysql&gt; select d.id,d.name,e.first_name,e.salary from s_emp e join s_dept d on e.dept_id = d.id where d.id=31; 12-- 找出区域在&#x27;Asia&#x27;的所有的员工信息mysql&gt; select r.name,e.first_name from s_region r join s_dept d on r.id = d.region_id join s_emp e on d.id = e.dept_id where r.name=&#x27;Asia&#x27;; 12-- 李老师的授课情况信息,包括教的学生的姓名,课程的名字,以及该课程授课的老师的名字以及该学生在这门课的得分情况mysql&gt; select t.tname,s.sname,c.cname,_sc.score from student s join sc _sc on s.id = _sc.sid join course c on c.id = _sc.cid join teacher t on t.id = c.tid where t.tname like &#x27;李%&#x27;; 12-- 查看顾客的id,姓名以及该顾客拥有的订单信息[订单所有列]mysql&gt; select c.id,c.name,o.* from s_customer c join s_ord o on c.id = o.customer_id; 12-- 查看所有区域,以及这个区域上的部门信息mysql&gt; select r.name,d.* from s_region r join s_dept d on d.region_id = r.id; 左连接和右连接 内连接 - inner join 查看顾客的id,姓名以及该顾客拥有的订单id - 拥有订单的客户才能够被查询出来 - inner join 12345678910111213141516171819202122232425262728mysql&gt;select c.id,c.name,o.id oid from s_customer c inner join s_ord o on c.id = o.customer_id;-- 总共查询得到16条数据-- inner join - 结果中少掉了207和215俩个客户 - 因为查看订单表s_ord,发现这俩个人就没有订单信息-- inner join - 内连接的写法,A表 join B表 - 如果A表中的记录在B表中不存在.那么关联查询之后.这个在B表中不存在的A表中的-- 这个记录也同样不会被关联查询出来.mysql&gt; select c.id,c.name,o.id oid from s_customer c inner join s_ord o on c.id = o.customer_id;+-----+----------------------------+-----+| id | name | oid |+-----+----------------------------+-----+| 201 | Unisports | 97 || 202 | OJ Atheletics | 98 || 203 | Delhi Sports | 99 || 204 | Womansport | 100 || 205 | Kam&#x27;s Sporting Goods | 101 || 206 | Sportique | 102 || 208 | Muench Sports | 103 || 208 | Muench Sports | 104 || 209 | Beisbol Si! | 105 || 210 | Futbol Sonora | 106 || 211 | Kuhn&#x27;s Sports | 107 || 212 | Hamada Sport | 108 || 213 | Big John&#x27;s Sports Emporium | 109 || 214 | Ojibway Retail | 110 || 204 | Womansport | 111 || 210 | Futbol Sonora | 112 |+-----+----------------------------+-----+16 rows in set (0.00 sec) 分析 1mysql&gt; select c.id,c.name from s_customer c;+-----+----------------------------+| id | name |+-----+----------------------------+| 201 | Unisports || 202 | OJ Atheletics || 203 | Delhi Sports || 204 | Womansport || 205 | Kam&#x27;s Sporting Goods || 206 | Sportique || 207 | Sweet Rock Sports || 208 | Muench Sports || 209 | Beisbol Si! || 210 | Futbol Sonora || 211 | Kuhn&#x27;s Sports || 212 | Hamada Sport || 213 | Big John&#x27;s Sports Emporium || 214 | Ojibway Retail || 215 | Sporta Russia |+-----+----------------------------+15 rows in set (0.00 sec)mysql&gt; select o.id,o.customer_id from s_ord o;+-----+-------------+| id | customer_id |+-----+-------------+| 97 | 201 || 98 | 202 || 99 | 203 || 100 | 204 || 101 | 205 || 102 | 206 || 103 | 208 || 104 | 208 || 105 | 209 || 106 | 210 || 107 | 211 || 108 | 212 || 109 | 213 || 110 | 214 || 111 | 204 || 112 | 210 |+-----+-------------+16 rows in set (0.00 sec) 左连接 - left join A表 join B表 - 以left join左边的表为基准表.右边的表非基准表.如果基准表中的记录在非基准表不存在.但是也能够查询出来. 如果这个客户没有订单信息,那么也要将这个客户的信息查询出来 12345678910111213141516171819202122232425mysql&gt; select c.id,c.name,o.id oid from s_customer c left join s_ord o on c.id = o.customer_id;+-----+----------------------------+------+| id | name | oid |+-----+----------------------------+------+| 201 | Unisports | 97 || 202 | OJ Atheletics | 98 || 203 | Delhi Sports | 99 || 204 | Womansport | 100 || 205 | Kam&#x27;s Sporting Goods | 101 || 206 | Sportique | 102 || 208 | Muench Sports | 103 || 208 | Muench Sports | 104 || 209 | Beisbol Si! | 105 || 210 | Futbol Sonora | 106 || 211 | Kuhn&#x27;s Sports | 107 || 212 | Hamada Sport | 108 || 213 | Big John&#x27;s Sports Emporium | 109 || 214 | Ojibway Retail | 110 || 204 | Womansport | 111 || 210 | Futbol Sonora | 112 || 207 | Sweet Rock Sports | NULL || 215 | Sporta Russia | NULL |+-----+----------------------------+------+18 rows in set (0.00 sec) 右连接 - right join A表 join B表 - 以right join右边的表为基准表.左边的表非基准表.如果基准表中的记录在非基准表不存在.但是也能够查询出来. 1select c.id,c.name,o.id oid from s_ord o right join s_customer c on c.id = o.customer_id; 自关联 - 自己关联自己 – 员工s_emp表中的manager_id - 上司的id -&gt; 绑定的就是s_emp表中的id 12345678910111213141516171819202122232425262728293031mysql&gt; select id,first_name,manager_id from s_emp;+----+------------+------------+| id | first_name | manager_id |+----+------------+------------+| 1 | Car_men | NULL || 2 | LaDoris | 1 || 3 | Midori | 1 || 4 | Ma_rk | 1 || 5 | Audry | 1 || 6 | Molly | 2 || 7 | Roberta | 2 || 8 | Ben | 2 || 9 | Antoinette | 2 || 10 | Marta | 2 || 11 | Colin | 3 || 12 | Henry | 3 || 13 | Yasmin | 3 || 14 | Mai | 3 || 15 | Andre | 3 || 16 | Elena | 6 || 17 | George | 6 || 18 | Akira | 7 || 19 | Vikram | 7 || 20 | Chad | 8 || 21 | Alexander | 8 || 22 | Eddie | 9 || 23 | Radha | 9 || 24 | Bela | 10 || 25 | Sylvie | 10 |+----+------------+------------+25 rows in set (0.00 sec) 练习 123-- 查询员工的名字,以及这个员工的上司的名字 - 一个上司拥有多个下属的.-- 效果:这个员工没有上司,也要能够查询出来.mysql&gt; select e1.first_name 员工名字,e2.first_name 上司 from s_emp e1 left join s_emp e2 on e2.id = e1.manager_id 分组查询 SELECT 语句 WHERE 语句 GROUP BY 语句 [HAVING 组函数判断] ORDER BY语句 多行函数 count函数 - 统计个数 1234567891011121314-- 统计s_emp的员工的个数mysql&gt; select count(*) from s_emp;-- 除了可以写*,那么还可以推荐写idmysql&gt; select count(e.id) from s_emp e;-- 重复的数据也算1个mysql&gt; select count(title) from s_emp;-- 统计职称,重复的数据,只要统计一次mysql&gt; select count(distinct title) from s_emp;-- 如果遇到null值,忽略null值的统计mysql&gt; select count(commission_pct) from s_emp; avg,sum,min,max - 忽略null值 12-- 统计学生的得分情况mysql&gt;select avg(score),sum(score),min(score),max(score) from sc; group by 统计各个部门编号,以及这个部门的员工的数量 1mysql&gt; select dept_id,count(*) from s_emp group by dept_id; 统计部门人数大于等于3的部门的编号以及人数信息 条件是分组之后得到的,所以不能使用where语句,where语句是出现在group by分组之前的.一定是用having语句来进行判断 having后面一定只能跟组函数的判断 1mysql&gt; select dept_id,count(*) from s_emp group by dept_id having count(*)&gt;=3; 统计部门[41,42,43]人数大于等于4的部门的编号以及人数信息 1mysql&gt; select dept_id,count(*) from s_emp where dept_id in(41,42,43) group by dept_id having count(*)&gt;=4; 统计部门[41,42,43]人数大于等于3的部门的编号以及人数信息,并且根据部门编号降序排列 1mysql&gt; select dept_id,count(*) from s_emp where dept_id in(41,42,43) group by dept_id having count(*)&gt;=3 order by 1 desc; 分组练习 经常分组统计 - 分组+统计.也是可以只进行分组的动作. 12345-- 统计每个职称的人数 - 分组+统计了mysql&gt; select title,count(id) from s_emp group by title;-- 只是分组 - 除了可以使用distinct来去重.那么我们也可以直接使用分组进行去重.mysql&gt; select title from s_emp group by title; 统计部门的名称,编号以及该部门上的员工的数量 1234567891011mysql&gt; select d.id,d.name,count(e.id) from s_emp e join s_dept d on e.dept_id = d.id group by d.id,d.name;-- 注意点,写group by 容易发生错误的地方.-- mysql5.7以后对group by的写法要求变得高了.推荐.-- 如果select后面除了存在组函数以外,还存在其他列.那么group by后面的列一定要和select后面的列高度保持一致.-- 1. select 列1,列2,组函数 from 表 group by 列1,列2-- 但是如果select后面只有组函数select count(e.id) from s_emp e join s_dept d on e.dept_id = d.id group by d.id; 统计每个客户的订单数量[超过1的统计出来],没有订单的客户也要能够统计出来 1mysql&gt; select c.id,c.name,count(o.id) from s_customer c left join s_ord o on c.id = o.customer_id group by c.id,c.name having count(o.id)&gt;1; 统计每个区域的部门的数量 1mysql&gt; select r.id,r.name,count(d.id) from s_region r join s_dept d on r.id = d.region_id group by r.id,r.name; 统计每个区域上的员工的数量 12mysql&gt;select r.name,r.id,count(e.id) from s_region r join s_dept d on r.id = d.region_id join s_emp eon e.dept_id = d.id group by r.name,r.id; 统计每个学生的课程的总分,平均分 12345mysql&gt; select v.sid,sum(v.score),avg(v.score) from sc v group by v.sid;-- 统计每个学生的id,姓名以及他的课程的总分,平均分mysql&gt; select s.id,s.sname,sum(v.score),avg(v.score) from student s left join sc v on s.id = v.sidgroup by s.id,s.sname; 统计每个老师授课的课程的数量 1mysql&gt; select t.id,t.tname,count(c.id) from teacher t join course c on t.id = c.tid group by t.id,t.tname; 统计每个课程的最低分,最高分,平均分 1mysql&gt; select c.id,c.cname,min(v.score),max(v.score),avg(v.score) from course c join sc v on c.id = v.cid group by c.id,c.cname; 统计李老师的学生数量 1234mysql&gt; select t.id,t.tname,count(v.sid) from teacher t join course c on t.id = c.tidjoin sc v on v.cid = c.id where t.tname like &#x27;李%&#x27;group by t.id,t.tname; 子查询 - 最难的 子查询是效率不如关联查询.但是子查询更加灵活.能用关联查询解决的查询,肯定也是可以通过子查询去解决. 但是子查询可以解决关联查询解决的查询.使用原则优先使用关联查询. 注意点:子查询必须要使用()括号 三个维度 子查询作为外部查询的列. 子查询作为外部查询的where语句中 子查询可以看做是一张”虚拟表/临时表”,可以对这个”虚拟表”再次进行查询. ###子查询作为外部查询的where语句中 12345678910-- 查询和&#x27;Ben&#x27;在同一个部门的员工first_name,dept_id;-- 分解 - 找出&#x27;Ben&#x27;的部门idmysql&gt; select dept_id from s_emp where first_name=&#x27;Ben&#x27;;//43-- 找出43部门的所有的员工,但是不包含Benmysql&gt; select first_name,dept_id from s_emp where first_name!=&#x27;Ben&#x27; and dept_id=43;-- 整合到一块儿mysql&gt; select first_name,dept_id from s_emp where first_name!=&#x27;Ben&#x27; and dept_id=(select dept_id from s_emp where first_name=&#x27;Ben&#x27;); 子查询作为外部查询的列 123-- 查询客户的id,客户的姓名,以及该客户的订单个数mysql&gt; select c.id,c.name,(select count(o.customer_id) from s_ord o where c.id=o.customer_id) 订单数量from s_customer c; 12-- 查询部门的id,部门的名称,以及这个部门上的员工的个数mysql&gt; select d.id,d.name,(select count(e.id) from s_emp e where e.dept_id = d.id) 员工数 from s_dept d; ###子查询可以看做是一张”虚拟表/临时表”,可以对这个”虚拟表”再次进行查询. 使用场景最多的子查询 12345678910111213141516171819202122-- 用子查询来实现 - 查询和&#x27;Ben&#x27;在同一个部门的员工first_name,dept_id-- (select e.dept_id from s_emp e1 where e1.first_name=&#x27;Ben&#x27;)结果必须返回单个值mysql&gt; select e.first_name,(select e.dept_id from s_emp e1 where e1.first_name=&#x27;Ben&#x27;) from s_emp e;和下面的这个效果是一样的mysql&gt; select e.first_name,e.dept_id from s_emp e;-- 修改-- 思路 e.first_name,子查询e.dept_id - 判断成立 - 有值,否则为null-- e.dept_id是否和&#x27;Ben&#x27;是一个部门的.select e.first_name,(select e.dept_id from s_emp e1 where e1.first_name=&#x27;Ben&#x27; and e.dept_id=e1.dept_id) didfrom s_emp e;-- 把上面的查询的结果作为&quot;虚拟表&quot; - 别名 - core_select * from ( select e.first_name,(select e.dept_id from s_emp e1 where e1.first_name=&#x27;Ben&#x27; and e.dept_id=e1.dept_id) did from s_emp e) core_ where core_.did is not null and core_.first_name&lt;&gt;&#x27;Ben&#x27;; exists和not exists用法 exists - 是否存在.只要存在,那么就返回true - 顺利被查询出来 not exists - 不存在 如果是false,反而会被顺利查询出来 案例 1234-- exists(子查询 - 如果有结果,返回true,否则返回false)mysql&gt;select first_name from s_emp where exists(select 1 from s_emp where 1=1);mysql&gt;select first_name from s_emp where not exists(select 1 from s_emp where 1=2); 练习 - salary是不重复的 查询和’Ben’在同一个部门的员工first_name,dept_id 123mysql&gt; select e.first_name,e.dept_id from s_emp e where exists(select 1 from s_emp e1 where e1.first_name=&#x27;Ben&#x27; and e1.dept_id=e.dept_id) and e.first_name&lt;&gt;&#x27;Ben&#x27;; 找出各个部门工资排名前二的员工 “e-我”这个部门中,如果还有人工资比我高.那么这个数量不能超过1个. 1234mysql&gt; select e.dept_id,e.first_name,e.salary from s_emp e where exists( select 1 from s_emp e1 where e.dept_id = e1.dept_id and e1.salary&gt;e.salary having count(*)&lt;=1) order by 1; not exists来实现的 12345不存在&#x27;我e&#x27;这个部门中,有人的工资比我高.并且这个数量超过1个.mysql&gt; select e.dept_id,e.first_name,e.salary from s_emp e where not exists( select 1 from s_emp e1 where e.dept_id = e1.dept_id and e1.salary&gt;e.salary having count(*)&gt;1) order by 1; 找出各个部门中工资最高的 1234mysql&gt; select e.dept_id,e.first_name,e.salary from s_emp e where not exists( select 1 from s_emp e1 where e.dept_id = e1.dept_id and e1.salary&gt;e.salary having count(*)&gt;0) order by 1; mysql 单行函数 - 了解即可 第一个作业 - 字符串函数+数字函数+日期函数[能有多少] - mysql_function.md 字符串函数 instr(str,substr) - 返回字符串substr在字符串str第一次出现的位置(str不包含substr时返回0) mysql下标索引从1开始的 1mysql&gt;select instr(&#x27;ppopo&#x27;,&#x27;o&#x27;);//3,找不到则返回0 lpad(str,len,padstr) - 用字符串padstr填补str左端直到字串长度为len并返回 rpad(str,len,padstr) - 用字符串padstr填补str右端直到字串长度为len并返回 12345mysql&gt;select rpad(&#x27;abc&#x27;,6,&#x27;do&#x27;);//abcdodmysql&gt;select rpad(&#x27;吴亦凡&#x27;,10,&#x27;*&#x27;);//-- oracle数据库rpad函数 - 遇到汉字,一个汉字是占3个长度吴亦凡* left(str,len) - 返回字符串str的左端len个字符 right(str,len) - 返回字符串str的右端len个字符 substring(str,pos,len) - 返回字符串str的位置pos起len个字符 substring(str,pos) - 返回字符串str的位置pos起后面的子串 ltrim(str) - 返回删除了左空格的字符串str rtrim(str) - 返回删除了右空格的字符串str space(n) - 返回由n个空格字符组成的一个字符串 replace(str,from_str,to_str) - 用字符串to_str替换字符串str中的子串from_str并返回 reverse(str) - 颠倒字符串str的字符顺序并返回 insert(str,pos,len,newstr) - 把字符串str由位置pos起len个字符长的子串替换为字符串 1mysql&gt;select insert(&#x27;Carmen&#x27;,2,5,&#x27;*****&#x27;); lower(str) - 返回小写的字符串str upper(str) - 返回大写的字符串str char_length(str) - 不管汉字还是数字或者是字母都算是一个字符。 length(str);//汉字占3个,其他占1个. 列中的应用123456789101112131415161718192021222324252627282930-- 将first_name列的数据全部反转mysql&gt; select first_name,reverse(first_name) from s_emp;-- 这些函数是允许嵌套使用的mysql&gt; select first_name,upper(reverse(first_name)) from s_emp;-- 练习 - 模拟银行账户的输出方式-考虑该列是中文的情况.-- 查询效果-- Car_men C******-- 吴亦凡 吴**-- Mark M**-- concat函数 - 字符串的拼接mysql&gt; select first_name,concat(substring(first_name,1,1),rpad(&#x27;*&#x27;,char_length(first_name)-1,&#x27;*&#x27;)) 显示账户 from s_emp;-- replace函数-- replace(str,oldStr,newStr);mysql&gt; select first_name,replace(first_name,substring(first_name,2),rpad(&#x27;*&#x27;,char_length(first_name)-1,&#x27;*&#x27;)) 账户 from s_emp;-- 直接使用rpad函数-- rpad(str,拼接之后总的长度,appendStr);mysql&gt;select first_name,rpad(substring(first_name,1,1),char_length(first_name),&#x27;*&#x27;) 账户 from s_emp;-- 使用insert函数-- insert(str,pos,len,newstr) - 把字符串str由位置pos起len个字符长的子串替换为字符串-- insert函数的基本使用mysql&gt; select insert(&#x27;abcde&#x27;,2,3,&#x27;*&#x27;);//a*emysql&gt; select first_name,insert(first_name,2,char_length(first_name)-1,rpad(&#x27;*&#x27;,char_length(first_name)-1,&#x27;*&#x27;)) 账户 from s_emp; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354&gt;剖析一下 - s_customer表phone列最后一个&#x27;-&#x27;后面的phone的数字.&gt;mysql&gt; select phone,reverse(phone) from s_customer;&gt;+----------------+----------------+&gt;| phone | reverse(phone) |&gt;+----------------+----------------+&gt;| 55-2066101 | 1016602-55 |&gt;| 81-20101 | 10102-18 |&gt;| 91-10351 | 15301-19 |&gt;| 1-206-104-0103 | 3010-401-602-1 |&gt;| 852-3692888 | 8882963-258 |&gt;| 33-2257201 | 1027522-33 |&gt;| 234-6036201 | 1026306-432 |&gt;| 49-527454 | 454725-94 |&gt;| 809-352689 | 986253-908 |&gt;| 52-404562 | 265404-25 |&gt;| 42-111292 | 292111-24 |&gt;| 20-1209211 | 1129021-02 |&gt;| 1-415-555-6281 | 1826-555-514-1 |&gt;| 1-716-555-7171 | 1717-555-617-1 |&gt;| 7-3892456 | 6542983-7 |&gt;+----------------+----------------+&gt;instr(str,substr);//从左到右查找substr在str中第一次出现的位置&gt;mysql&gt; select instr(reverse(phone),&#x27;-&#x27;) from s_customer;&gt;-- 取出&#x27;-&#x27;左边的元素&gt;left(str,len) - 返回字符串str的左端len个字符&gt;mysql&gt; select phone,left(reverse(phone),instr(reverse(phone),&#x27;-&#x27;)-1) from s_customer;&gt;+----------------+--------------------------------------------------+&gt;| phone | left(reverse(phone),instr(reverse(phone),&#x27;-&#x27;)-1) |&gt;+----------------+--------------------------------------------------+&gt;| 55-2066101 | 1016602 |&gt;| 81-20101 | 10102 |&gt;| 91-10351 | 15301 |&gt;| 1-206-104-0103 | 3010 |&gt;| 852-3692888 | 8882963 |&gt;| 33-2257201 | 1027522 |&gt;| 234-6036201 | 1026306 |&gt;| 49-527454 | 454725 |&gt;| 809-352689 | 986253 |&gt;| 52-404562 | 265404 |&gt;| 42-111292 | 292111 |&gt;| 20-1209211 | 1129021 |&gt;| 1-415-555-6281 | 1826 |&gt;| 1-716-555-7171 | 1717 |&gt;| 7-3892456 | 6542983 |&gt;+----------------+--------------------------------------------------+&gt;-- 继续反转&gt;mysql&gt; select phone,reverse(left(reverse(phone),instr(reverse(phone),&#x27;-&#x27;)-1)) from s_customer; 数字函数 abs(n) - 求绝对值 mod(n,m) - 取模运算,返回n被m除的余数(同%操作符) floor(n) - 返回不大于n的最大整数值 - 向下取整 ceiling(n) - 返回不小于n的最小整数值 - 向上取整 round(n[,d]) - 返回n的四舍五入值,保留d位小数(d的默认值为0) 123mysql&gt;select round(3.5);mysql&gt;select round(3.456,2);//3.46 pow(x,y) - 返回值x的y次幂 sqrt(n) - 返回非负数n的平方根 pi() - 返回圆周率 rand() - 返回在范围**[0到1.0)**内的随机浮点值 truncate(n,d) - 保留数字n的d位小数并返回 - 直接截取 练习 求1~3之间的随机整数 12mysql&gt; select floor(rand()*3+1);mysql&gt; select truncate(rand()*3+1,0); 计算年薪 - 保留小数点2位 1select first_name,truncate(salary*12*(1+coalesce(commission_pct,0)/100),2) 年薪 from s_emp; 日期函数 查询当前系统的日期 - select now(); dayofweek(date) - 返回日期date是星期几(1=星期天,2=星期一,……7=星期六,odbc标准) weekday(date) - 返回日期date是星期几(0=星期一,1=星期二,……6= 星期天) year(date) - 返回date的年份(范围在1000到9999) month(date) - 返回date中的月份数值 dayofmonth(date) - 返回date是一月中的第几日(在1到31范围内) hour(time) - 返回time的小时数(范围是0到23) minute(time) - 返回time的分钟数(范围是0到59) second(time) - 返回time的秒数(范围是0到59) period_add(p,n) - 增加n个月到时期p并返回(p的格式yymm或yyyymm) 1234mysql&gt; select period_add(&#x27;202108&#x27;,3);-- 需求把s_emp表中的start_date往后延1个月mysql&gt; select start_date,period_add(date_format(start_date,&#x27;%Y%m&#x27;),1) from s_emp; 注意:p可以是字符串,一定要满足一定的格式,或者可以直接使用date类型. period_diff(p1,p2) - 返回在时期p1和p2之间月数(p1和p2的格式yymm或yyyymm) p1-p2 curdate() - 以’yyyy-mm-dd’或yyyymmdd格式返回当前日期值(根据返回值所处上下文是字符串或数字) curtime() - 以’hh:mm:ss’或hhmmss格式返回当前时间值(根据返回值所处上下文是字符串或数字) now() - 以’yyyy-mm-dd hh:mm:ss’或yyyymmddhhmmss格式返回当前日期时间(根据返回值所处上下文是字符串或数字) last_day(date) - date日期所在月的最后一天是什么时候 datediff(d1,d2) - 两个日期d1,d2之间相差的天数 timestampdiff(type,d1,d2) - type - year,month,day… mysql中,虽然日期date_format函数来转成字符串类型的,mysql内部为了简化我们的写法,有的时候有的函数. 只要你传入的字符串满足一定的格式,那么它就会自动被转成日期函数. 补充1234567891. date_add(date,interval n type)2. date_sub(date,interval n type)type:yearmonthdayhourminutesecond 日期格式化 date_format(date,format) - 把日期转换成指定模板的字符串. 根据format字符串格式化date值 (在format字符串中可用标志符: %m 月名字(january……december) %w 星期名字(sunday……saturday) %d 有英语前缀的月份的日期(1st, 2nd, 3rd, 等等。） %Y 年, 数字, 4 位 %y 年, 数字, 2 位 %a 缩写的星期名字(sun……sat) %d 月份中的天数, 数字(00……31) %e 月份中的天数, 数字(0……31) %m 月, 数字(01……12) %c 月, 数字(1……12) %b 缩写的月份名字(jan……dec) %j 一年中的天数(001……366) %H 24时制小时(00……23) %k 小时(0……23) %h 12时小时(01……12) %i 小时(01……12) %l 小时(1……12) %i 分钟, 数字(00……59) %r 时间,12 小时(hh:mm:ss [ap]m) %t 时间,24 小时(hh:mm:ss) %s 秒(00……59) %p am或pm %w 一个星期中的天数(0=sunday ……6=saturday ） demo1mysql&gt; select start_date,date_format(start_date,&#x27;%Y-%m-%d %H:%i:%s&#x27;) from s_emp; 日期练习 找出员工的工作月数 - 和当前的日比较的 1mysql&gt; select first_name,start_date,timestampdiff(month,start_date,now()) 月份 from s_emp; 查询员工的工作天数 123mysql&gt; select first_name,start_date,timestampdiff(day,start_date,now()) 天数 from s_emp;mysql&gt; select first_name,start_date,abs(datediff(start_date,now())) 天数 from s_emp; 计算一年前,当前,一年后的日期 date_add(date,interval n type) date_sub(date,interval n type) 123mysql&gt; select date_sub(now(),interval 1 year) 一年前,now() 当前,date_add(now(),interval 1 year) 一年后;mysql&gt; select date_add(now(),interval -12 month) 一年前,now() 当前,date_add(now(),interval 12 month) 一年后; 当前日期前6个月的最后一天 1mysql&gt; select last_day(date_sub(now(),interval 6 month)); 把员工的入职日期格式化为年/月/日 1234mysql&gt; select start_date,date_format(start_date,&#x27;%Y-%m-%d&#x27;) from s_emp;-- 1990年05月03日mysql&gt; select start_date,date_format(start_date,&#x27;%Y年%m月%d日&#x27;) from s_emp; 找出5月份入职的员工 1mysql&gt; select first_name,start_date from s_emp where month(start_date)=5; 类型的转换日期转字符串 数据查询出来之后显示用的. date_format(date,模板); 字符串转日期 插入数据的时候,需要将日期列的字符串转换成日期类型,才能够插入到date类型列. mysql中只要你的字符串满足默认支持的格式.那么就会默认转成date类型. 123456789-- date列insert into test_date values(3,&#x27;xx&#x27;,&#x27;2019-09-08&#x27;);//ok &#x27;2019-09-08&#x27;insert into test_date values(4,&#x27;xx&#x27;,&#x27;2019/10/08&#x27;);//ok &#x27;2019/10/08&#x27;insert into test_date values(5,&#x27;xx&#x27;,&#x27;20191105&#x27;);//ok &#x27;20191105&#x27;insert into test_date values(5,&#x27;xx&#x27;,&#x27;2018-11-05 13:08:09&#x27;);//ok假设如果指定的是一个非法的字符串模板mysql&gt; insert into test_date values(5,&#x27;xx&#x27;,&#x27;05/11/2023&#x27;);ERROR 1292 (22007): Incorrect date value: &#x27;05/11/2023&#x27; for column &#x27;d1&#x27; at row 1 解决一个非法模板的字符串 - mysql不能把这个形式的字符串自动转换成date/datetime类型 str_to_date(str,pattern) 123str的格式也必须要和pattern是匹配 - 实现str-date类型的转换mysql&gt; insert into test_date values(6,&#x27;xx&#x27;,str_to_date(&#x27;05/11/2023&#x27;,&#x27;%d/%m/%Y&#x27;)); date和datetime date - 年月日 datetime - 年月日时分秒 mysql中列如果是一个日期,常用的俩个类型分别是date和datetime 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051drop table test_date;create table test_date( id int(7), name varchar(20), d1 date);-- 插入数据insert into test_date values(1,&#x27;admin&#x27;,now());-- 插入指定的日期到表中mysql&gt; insert into test_date values(5,&#x27;xx&#x27;,&#x27;20191105&#x27;);-- 列是date,但是插入数据包含时分秒的mysql&gt; insert into test_date values(5,&#x27;xx&#x27;,&#x27;2018-11-05 13:08:09&#x27;);-- 查询出来的d1列的内容默认显示的日期的格式%Y-%m-%dmysql&gt; select * from test_date;+------+-------+------------+| id | name | d1 |+------+-------+------------+| 1 | admin | 2021-08-17 |+------+-------+------------+drop table test_datetime;create table test_datetime( id int(7), name varchar(20), d1 datetime);insert into test_datetime values(1,&#x27;tom&#x27;,now());-- 效果,如果列设置成了datetime,查询出来的模板是-%Y-%m-%d %H:%i:%smysql&gt; select * from test_datetime;+------+------+---------------------+| id | name | d1 |+------+------+---------------------+| 1 | tom | 2021-08-17 10:12:18 |+------+------+---------------------+-- 插入一个指定的日期 - 仅仅包含年月日mysql&gt; insert into test_datetime values(5,&#x27;xx&#x27;,&#x27;2019-09-08&#x27;);-- 时分秒是自动归05 | xx | 2019-09-08 00:00:00 mysql&gt;insert into test_datetime values(5,&#x27;xx&#x27;,&#x27;2019/09/08 13:12:18&#x27;);5 | xx | 2019-09-08 13:12:18","categories":[{"name":"数据库","slug":"数据库","permalink":"http://example.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"}],"tags":[{"name":"mysql","slug":"mysql","permalink":"http://example.com/tags/mysql/"}]},{"title":"反射工厂设计模式","slug":"ReflectFactory","date":"2021-08-15T06:02:18.000Z","updated":"2021-08-15T06:04:16.342Z","comments":true,"path":"2021/08/15/ReflectFactory/","link":"","permalink":"http://example.com/2021/08/15/ReflectFactory/","excerpt":"","text":"反射工厂设计模式 顶级父类接口123public interface IBaseDao &#123; void add();&#125; 顶级父类接口的实现类12345678910public class StudentDaoImpl implements IBaseDao &#123; public StudentDaoImpl() &#123; System.out.println(&quot;StudentDaoImpl......&quot;); &#125; @Override public void add() &#123; System.out.println(&quot;Student...add...&quot;); &#125;&#125; 配置文件-供反射使用-根据key取value(全限定名)1StudentDaoImpl = stu.aistar.design.factory.reflect.StudentDaoImpl2 利用枚举特性写一个工具类-用来读取配置文件里面的value(全限定名)1234567891011121314151617181920212223242526272829public enum PropUtil &#123; INSTANCE; // 定义一个Properties属性 private Properties properties; PropUtil()&#123; //可以在构造方法 - 初始化的 //Properties对象就是.properties属性文件[encoding=utf-8]在内存中的映射. properties = new Properties(); //固定的语法 - 死记住 //获取属性文件字节输入流 InputStream in = Thread.currentThread() .getContextClassLoader() .getResourceAsStream(&quot;stu/aistar/design/factory/reflect/bean.properties&quot;); try &#123; //Properties对象就是.properties属性文件[encoding=utf-8]在内存中的映射. properties.load(in); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; //普通方法 public String getValue(String key)&#123; //确认properties不为null return properties == null ? null : properties.getProperty(key); &#125;&#125; 创建反射工厂模式-利用刚读取到的全限定名-利用反射技术创建接口的实现类对象-从而对接口的方法进行操作1234567891011121314151617181920212223242526272829303132/** * 本类用于演示：反射工厂 - 反射工厂既能够保证在新增一个产品的时候,能够遵守&quot;开闭原则&quot;, * 又能够保证始终仅仅只有一个工厂类. * * Properties + 反射 + 泛型方法/泛型类 */public class BaseFactory&lt;T&gt; &#123; //面向接口编程 //泛型方法 - 静态方法&lt;T&gt;,同时也要设置泛型类 public T getInstance(String type)&#123; T t = null; //传进来的type是一个全限定类型，我们需要用forName方法 try &#123; //获取class实例的方式 Class&lt;?&gt; c = Class.forName(type); //反射调用空参构造 try &#123; t = (T) c.newInstance(); //构造空参 可以调用接口实现类中的方法 &#125; catch (InstantiationException e) &#123; e.printStackTrace(); &#125; catch (IllegalAccessException e) &#123; e.printStackTrace(); &#125; &#125; catch (ClassNotFoundException e) &#123; e.printStackTrace(); &#125; return t; &#125;&#125; 单元测试12345678910111213141516171819202122232425262728293031323334public class FactoryTest &#123; public static void main(String[] args) &#123; //1. 获取StudentDaoImpl对象 //有多少个产品实现类 - 都是需要配置到bean.properties文件中的. String stuClass = PropUtil.INSTANCE.getValue(&quot;StudentDaoImpl&quot;); //获取的是全限定类型 BaseFactory&lt;StudentDaoImpl&gt; baseFactory = new BaseFactory&lt;&gt;();// IBaseDao stuDao = baseFactory.getInstance(stuClass);//// stuDao.add(); //思考好处 /** * 场景：如果哪天实现类功能升级了. * 当一个类的功能拓展之后，尽量不要去动原来的类 - “开闭原则” * 解决方案一：不推荐，再去写一个类StudentDaoImpl2.java extends StudentDaoImpl.java * 继承虽然解决了功能的拓展，同时也增加了类之间的耦合性 - “高内聚，低耦合” * * 解决方案二：引导如果想要对一个类进行功能的拓展，使用设计原则 - 合成复用原则来替代继承的写法. * * 设计原则 - 依赖倒置原则 - 由维护具体-维护抽象. * * 凡是代码中用到StudentDaoImpl，代码需要大量的改动 * 代码改动 - 小牧编译 - 重新部署 * IBaseDao stuDao = new StudentDaoImpl(); * * 只需要修改配置文件即可 * STUDENT_DAO=tech.aistar.design.factory.reflect.StudentDaoImpl2 */ IBaseDao stuDao = baseFactory.getInstance(stuClass); stuDao.add(); &#125;&#125;","categories":[{"name":"设计模式","slug":"设计模式","permalink":"http://example.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"java","slug":"java","permalink":"http://example.com/tags/java/"}]},{"title":"线程锁(华为笔试题)","slug":"Test04","date":"2021-08-15T05:49:16.000Z","updated":"2021-08-15T05:50:34.450Z","comments":true,"path":"2021/08/15/Test04/","link":"","permalink":"http://example.com/2021/08/15/Test04/","excerpt":"","text":"线程的通信 - 重点同程公司笔试题 - 循环打印abc ABC 123 abc ABC 123 打印小写字母abc的线程,打印大写字母ABC线程,打印数字123的线程 保证必须按照上面的顺序进行输出 - synchronized - wait和notify/notifyAll不能解决原因是notify随机唤醒,notifyAll唤醒所有 使用Lock中的同步队列 - 解决方案 - 唤醒指定的等待队列上的某个线程. Lock接口中提供的构建等待队列的方法 - Condition newCondition(); Contion提供的关于线程通信的俩个方法 - 出现在同步代码内部 - lock()-&gt;unlock()内部 void await();//当前线程会进入到阻塞状态.必须要等其他线程唤醒的 void signal();//哪个线程的Conition对象去调用signal()方法,哪个线程就会被唤醒 demo 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495public class LockTongxinDemo &#123; Lock lock = new ReentrantLock(); //有几个线程,就构建几个队列 private Condition c1 = lock.newCondition(); //给小写用 private Condition c2 = lock.newCondition(); //给大写用 private Condition c3 = lock.newCondition(); //给数字用 private int count = 0; //标记 //count = 0,打印小写字母的执行 //count = 1,打印大写字母的执行 //count = 2,打印数字的执行 //1. void await();//当前线程会进入到阻塞状态.必须要等其他线程唤醒的 //2. void signal();//哪个线程的Conition对象去调用signal()方法,哪个线程就会被唤醒 public void printLower()&#123; while (true)&#123; lock.lock(); if (count!=0)&#123; try &#123; c1.await(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; System.out.print(&quot;abc&quot;); System.out.println(); try &#123; Thread.sleep(1000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; count = 1; c2.signal(); lock.unlock(); &#125; &#125; public void printUpper()&#123; while (true)&#123; lock.lock(); if (count!=1)&#123; try &#123; c2.await(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; System.out.print(&quot;ABC&quot;); System.out.println(); try &#123; Thread.sleep(1000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; count = 2; c3.signal(); lock.unlock(); &#125; &#125; public void printNum()&#123; while (true)&#123; lock.lock(); if (count!=2)&#123; try &#123; c3.await(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; System.out.print(&quot;123&quot;); System.out.println(); try &#123; Thread.sleep(1000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; count = 0; c1.signal(); lock.unlock(); &#125; &#125; public static void main(String[] args) &#123; LockTongxinDemo Tx = new LockTongxinDemo(); Thread t1 = new Thread(()-&gt;Tx.printLower()); Thread t2 = new Thread(()-&gt;Tx.printUpper()); Thread t3 = new Thread(()-&gt;Tx.printNum()); t1.start(); t2.start(); t3.start(); &#125;&#125;","categories":[{"name":"大题小做","slug":"大题小做","permalink":"http://example.com/categories/%E5%A4%A7%E9%A2%98%E5%B0%8F%E5%81%9A/"}],"tags":[{"name":"题目","slug":"题目","permalink":"http://example.com/tags/%E9%A2%98%E7%9B%AE/"}]},{"title":"线程和进程","slug":"Thread","date":"2021-08-14T06:16:55.000Z","updated":"2021-08-14T06:22:55.807Z","comments":true,"path":"2021/08/14/Thread/","link":"","permalink":"http://example.com/2021/08/14/Thread/","excerpt":"","text":"进程和线程一个程序至少一个进程，一个程序至少一个线程。线程不能单独执行运行的，他一定是运行在进程的内部的. 进程[正在执行中的应用程序]：是并发执行的程序在执行过程中分配和管理资源的基本单位，是一个动态概念。 竞争计算机系统资源的基本单位。-“多任务操作系统”-“多个进程在同时在运行” - CPU分配资源-“分时分片” 处理器[cpu]调度的基本单位 线程：是进程的一个执行单元，是进程内部调度实体。比进程更小的独立运行的基本单位。线程也被成为轻量级进程。 一个进程可以拥有多个进程的,同一个进程内部的多个线程是可以共享进程资源的 比如启动Java程序 启动Java程序实际上就是启动JVM[对字节码文件进行逐行翻译 - 翻译成底层的机器语言]开启一个JVM进程 - jvm.exe[windows中的可执行文件.C语言写的程序直接编译成了.exe可执行文件] 当JVM进程启动之后,同时开启俩个线程 - 分别是main主线程以及一个GC线程[后台守护线程]守护线程 - 如果后台只剩下守护线程在执行的时候,那么进程就会结束.进程的结束不需要等到守护线程全部执行完才会结束. main线程负责执行main方法中的程序 - main方法中的程序全部执行完之后,main线程运行结束GC线程负责进行垃圾对象的回收 创建线程的传统的方式 第一种方式：extends Thread方式 - 共享代码，不共享资源 只有将资源设置成静态的 - 也是进行一个资源的共享的 第二种方式：implements Runnable接口 - 共享代码，共享资源 Thread和Runnable区别 第一种方式extends Thread方式 - 共享代码,不共享资源 只有将资源设置成静态的 - 也是进行一个资源的共享的 第二种方式implements Runnable接口 - 共享代码,共享资源 第三种方式Callable接口 推荐配合Future+线程池一起使用 Callable和Runnable接口的区别 Callable可以通过Future来得到异步计算的结果 - 拿到线程执行之后的结果. Callable调用的是call方法,Runnable调用的是run方法. call方法是可以抛出一个异常列表的,但是run方法是不允许抛出异常列表的 Callable例子1234567891011121314151617181920212223242526272829303132333435363738//拿到线程执行之后的结果 Callable+FutureTask -&gt; 线程执行的结果 class C1 implements Callable&lt;Integer&gt;&#123; public static void main(String[] args) &#123; System.out.println(&quot;main-begin...&quot;); Callable&lt;Integer&gt; c = new C1(); //FutureTask - 异步任务 FutureTask&lt;Integer&gt; task = new FutureTask&lt;&gt;(c); //利用异步任务来构建Thread对象 Thread t = new Thread(task); t.start();//启动线程 System.out.println(&quot;线程已经启动了...&quot;); try &#123; //拿线程计算的结果 //get()方法一定是要等到线程执行结束之后 - 才会停止 System.out.println(&quot;result:&quot;+task.get()); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; catch (ExecutionException e) &#123; e.printStackTrace(); &#125; System.out.println(&quot;main-end...&quot;); &#125; @Override public Integer call() throws Exception &#123; int total = 0; for (int i = 1; i &lt;= 100 ; i++) &#123; total+=i; &#125; //故意模拟一个比较费时费力的任务 Thread.sleep(2000); return total;//5050 &#125;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960public class CallablePoolDemo &#123; public static void main(String[] args) &#123; //创建一个可缓存的线程池对象 ExecutorService executorService = Executors.newCachedThreadPool(); //向这个缓存池中提交任务 //第一个任务 第二个任务 Future&lt;Integer&gt; future1 = executorService.submit(new C1()); Future&lt;Integer&gt; future2 = executorService.submit(new C2()); //任务的数量和线程的数量一定一样吗？ //有个效果 -&gt; 两个线程 - 同时执行这两个异步任务 //需要将两个线程执行的结果进行一个相加的操作 try &#123; //get方法肯定是会等到线程执行完毕之后 - 才会继续走 Integer res1 = future1.get(); Integer res2 = future2.get(); int result = future1.get() + future2.get(); //如果两个线程的get 方法不走完，main线程也是不会继续执行的 System.out.println(&quot;开始整合....&quot;); System.out.println(Thread.currentThread().getName() + &quot; --- &quot; + result); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; catch (ExecutionException e) &#123; e.printStackTrace(); &#125; &#125;&#125;class C1 implements Callable&lt;Integer&gt;&#123; @Override public Integer call() throws Exception &#123; System.out.println(Thread.currentThread().getName() + &quot;正在计算 &quot; + &quot;1~10:&quot;); Integer total = 0; for (int i = 0; i &lt;= 10; i++) &#123; total+=i; &#125; Thread.sleep(1000); System.out.println(&quot;计算结果为：&quot;+total); return total; &#125;&#125;class C2 implements Callable&lt;Integer&gt;&#123; @Override public Integer call() throws Exception &#123; System.out.println(Thread.currentThread().getName() + &quot;正在计算&quot; + &quot;1~100:&quot;); Integer total = 0; for (int i = 0; i &lt;= 100; i++) &#123; total+=i; &#125; Thread.sleep(1000); System.out.println(&quot;计算结果为：&quot;+total); return total; &#125;&#125; 线程安全的类和线程非安全的类 StringBuilder - 线程非安全的字符串类,StringBuffer - 线程安全的字符串类 ArrayList - 线程非安全的集合,Vector - 线程安全的集合 HashMap - 线程非安全的集合,Hashtable - 线程安全的集合 以上线程安全的类 - api方法使用到了synchronized方法进行了修饰 - 在某个时刻,只能由一个线程去访问,其他线程都是出于等待状态 Thread提供的常用方法 static Thread currentThread()；//返回当前正在执行的线程的引用对象 String getName()；//返回线程的名称 void start()；//启动线程，本质当t1.start()方法的时候底层会让JVM去启动线程，我们的程序是没有资格和能力去真正的把一个线程给启动起来的。CPU调度JVM进程—调用t1线程 void setName(String name)；//给线程设置名称 void setPriority(int n);//设置线程的优先级,数字[1~10].注意点:数字越大,优先级越高.但是并不是优先级越高的线程就一定会优先执行.只是希望它先执行.最终还是要cpu的. void setDaemon(boolean on);//设置成true,这个线程成为了一个后台守护线程了. //如果后台只剩下守护线程在执行 - 可以结束了//不需要等到所有的守护线程运行结束才结束 synchronized关键字 java语言的关键字 可用来给对象和方法或者代码块加锁 当他锁定一个方法[同步方法]或者一个代码块[同步代码块]的时候，同一时刻最多只有一个线程执行这段代码 当两个并发线程访问同一个对象object中的这个加锁同步代码块时，一个时间内只能有一个线程得到执行。另一个线程必须等待当前线程执行完这个代码块以后才能执行该代码块。 非公平锁 如果同步代码块中出现了异常，那么仍然还是会自动释放锁资源的。 基础方法在java，每个对象有且仅有一个同步锁，并且同步锁是依赖于对象存在的。当我们调用对象的synchronized修饰的同步方法时候，就是获取了该对象的同步锁。 修饰普通方法 - 对象锁 - 不同的对象拥有独立的“一把锁”，每个对象的”锁“是不冲突的- “自助餐” 修饰静态方法 - “类锁”- 作用于这个类下的所有的对象 - 这个类实例化出来的所有的对象竞争的是同一把“锁” - ”类锁“ - “一个桌子上吃饭饭” 修饰代码块synchronized(this) - 对象锁 修饰代码块(XXX.class) - “类锁” synchronized特性 原子性 123456所谓的原子性代表一个操作或者多个操作，要么执行全部并且执行的过程中不能被任何因素打断.要么就不执行.比如i++，i+=2，i=i+1；这些操作都不是原子操作[地区，计算，赋值]。这三个步骤不是原子性 - 三个步骤中的任何一个步骤在执行的过程。其他都可能去打断他。int x = 10; //原子操作特殊的 - 了解一下double x = 3.0d 或者 long x1 = 20L - 不具备原子性的。 可见性 原因：遇见synchronized之后，清空本地工作内存，重新从主存去拷贝最新的值 1多个线程访问同一个资源时，这个资源的状态，信息等对于其他线程都是可见的 有序性 在同一个时刻，只能由一个线程进入. 可重入性 当一个线程申请到锁资源并且执行完毕之后[释放]，仍然还有机会再去继续申请曾经申请过的锁资源。 JMMJMM就是java内存模型(java memory model） - 不是JVM内存模型 java内存模型规定所有的变量都存储在主内存中，包括实例变量[类中的非静态属性]，静态变量，但是不包括局部变量和方法参数。每个线程都有自己的工作内存，线程的工作内存保存了该线程用到的变量和主内存的副本拷贝，线程对变量的操作都在工作内存中进行。线程不能直接读写主内存中的变量。 不同的线程之间也无法访问对方工作内存中的变量。线程之间变量值的传递均需要通过主内存来完成。 描述i++过程 – 多线程安全问题前提： 线程是不能对主内存中的数据进行直接的操作的，必须是在本地的工作内存中去完成的，完成之后，刷回主内存的。 线程之间是隔离的，每个线程去执行方法的时候，都会在本地开辟一块区域[栈帧-线程栈]，每个线程在本地工作内存中 对资源的修改，那么这个资源的信息、状态，对其他线程都是不可见的。 1add方法没有使用synchronized进行修饰的流程 脏数据-本地工作内存中的变量的数据和主内存中的变量的数据的值已经不一样，违背了“JMM中的缓存的一致性”的原则. 123456789101112131415161718无锁资源情况下的addi++ 不是一个原子性操作的意思就是在它的中间的过程中,可以被被其他线程打断①T1线程从主存中拷贝变量的副本到本地的工作内存中 - read读取(i=0) =&gt; T1 `T1线程让出了CPU执行权力.T0线程获取执行权力 - 从主存拷贝变量的副本(i=0)` =&gt; T0 `T0线程直接进行了计算,赋值,重新刷回到主存[i=1]` =&gt; T0 `T0线程刷回i到主存之后,此时主存的i=1,T0线程让出cpu执行权` ②在本地的工作内存中对i进行计算,计算完之后,再把自增的数据重新赋值个i =&gt; T1 `T1线程继续执行②,由于之前T1线程并没有执行结束,因此它不会从已经更新的主存中重新去拷贝i的副本` `所以T1线程继续执行的时候,使用的仍然是自己本地工作内存中的那个变量i[read下来的,初始值仍然是0]` `T1线程i = i + 1,刷回到主存[i=1]` `因为线程是隔离的,T1线程它是不知道T0线程对i进行了修改的.`③把最终的本地工作内存中的i的计算结果 - [当前线程执行完毕之后]刷回到主存中[时间是不固定的.但是当前线程执行完毕之后,它肯定会刷回到主存] =&gt; T1 [如果是单线程环境下,当T1线程把最终的结果刷回到主存之后,第二次再次调用add()方法的时候,那么T1线程仍然会再次从主存中 获取变量的副本,重复执行①②③) 隐约的信号:如果线程T1没有执行结束,那么它是不会从主存中重新拉取值的 看到的效果是 - 俩个线程都同时操作了i++,但是主存中的i实际上是只加了1次的结果. 如何解决问题使用synchronized对i++所在的地方进行修饰. 当某个对象调用add方法，得到锁资源的时候，会先清空本地工作内存，清空的目的是为了让后面的操作重新从主存中开呗最新的值！ 123public synchronized void add()&#123; i++;&#125; 因为add方法进行了同步 - synchronized进行了修饰了.在某个时刻，只能由一个线程【获得锁资源的】进去执行 [去读、计算、赋值] - 三个步骤.其他线程是不可能介入的.因为没有获取锁资源的线程都在外部进行同步阻塞 当正在执行的线程释放锁资源之前，他会将本地工作内存中的改变刷回到主内存 什么时候工作内存中的改变会同步到主存中单线程 当前的单线程执行方法结束的时候 多线程 线程释放锁资源之间 线程切换 分析可见性代码先写再读 读线程为什么可以终止循环 1234567891011121314151617181920212223242526272829303132333435363738394041public class VisibilityDemo &#123; //实例变量 - 主内存中存在的 private volatile int x; public void writeX()&#123; x=5; &#125; public void readX()&#123; while (x!=5)&#123; &#125; if (x==5)&#123; System.out.println(&quot;==stop==&quot;); &#125; &#125; public static void main(String[] args) &#123; VisibilityDemo vd = new VisibilityDemo(); Thread t1 = new Thread(new Runnable() &#123; //创建一个写线程 @Override //使用匿名内部类 public void run() &#123; vd.writeX(); &#125; &#125;); Thread t2 = new Thread(()-&gt;vd.readX()); //创建一个读的线程 //使用lambda表达式 //线程的执行顺序和你先启动哪个是无关的. //大部分的场景是 -概率更高 - 先启动哪个线程,哪个线程优先执行的机会更大 //如果先写后读 t1.start(); try &#123; //此处的睡一秒,已经足够让我们的写线程把x=5的最终结果刷回到主存了呀 Thread.sleep(1000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; t2.start(); //发现x变成了5，所以会执行stop &#125;&#125; 先读后写 多个线程访问同一个资源时，这个资源的状态，信息等，对于其他线程都是不可见的 123456789//省略代码与上述相同//如果先读后写t2.start();//读try &#123; Thread.sleep(1000);&#125; catch (InterruptedException e) &#123; e.printStackTrace();&#125;t1.start();//写 synchronized深入 特点：对象重新获得锁资源的时候，会先清空本地工作内存.强制主存中去拷贝已经更新的变量. 1234567891011121314151617181920212223242526272829303132//先读再写,仅仅是在循环体中添加了一行代码 public void readX()&#123; //写线程过了许久之后,x=5的改变刷回到主存 //但是读线程在执行循环 - 循环体中出现了同步代码块 - 遇到synchronized //一旦遇到synchronized - 尝试去获取锁资源 - 会清空本地工作内存[把x清空掉了] //继续循环又会使用到x,由于本地工作内存已经清空了呀,所以读线程只能到主存中去强制再 // 去拷贝一份x的变量到本地工作内存 //拿到的肯定是写线程已经更新之后的那个值x=5 while(x!=5)&#123; // System.out.println();//增加的代码 - read线程跳出了循环 - 发现了新的x,重新拷贝最新的x &#125; if(x==5) &#123; System.out.println(&quot;-----stopped---&quot;); &#125;&#125;原因：//System.out.println()这个println方法的内部底层是 - 同步代码块 - synchronizedprivate void newLine() &#123; try &#123; synchronized (this) &#123; //... &#125; &#125; catch (InterruptedIOException x) &#123; Thread.currentThread().interrupt(); &#125; catch (IOException x) &#123; trouble = true; &#125;&#125; 如何保证可见性 - 解决方案 使用synchronized来保证可见性 使用volatile来修饰实例变量 作用1：强制让程序遵守”缓存一致性“协议.如果主存中的变量一旦发生了改变.线程就会强制从主存中重新拷贝这个更新的数据到自己的本地工作内存中去. 作用2：禁止指定重排的 - 单例 123456789x Student s = new Student();指令重排 - JVM指令优化之后①给对象分配空间②空间地址立即给s,s保存到栈③对象的初始化 volatile Student s = new Student();//禁止指令重排①给对象分配空间③对象的初始化②空间地址立即给s,s保存到栈 volatile关键字的作用 保证可见性 volatile是不会造成阻塞的 禁止指令重排 不能保证原子性 123456789101112131415161718192021222324252627282930volatile int i = 0;//i对于俩个线程而言都是可见的.主存中一旦改变了.另外一个线程肯定就能够&quot;看到&quot; - //自己会强制再去重新拷贝一份到本地缓存中@Overridepublic void run()&#123; add();&#125;public void add()&#123; i++;&#125;t1.start();t2.start();//诱导 - //强制让程序遵守&quot;缓存一致性&quot;协议.如果主存中的变量一旦发生了改变.//线程就会强制从主存中重新拷贝这个最新的数据到自己的本地工作内存中去.//最终的i出来的结果&lt;200000 -&gt; 不能保证原子性//t1执行到最后一步,在自己的工作内存中已经计算结束了,//i已经自增完毕,i=1&lt;---其他线程介入了---&gt;但是还没有来得及刷回到主存./*t0线程直接计算完,i=1,刷回到主存,结束但是t1已经对i操作已经结束了,t1的内部已经不会再去操作i只剩下最后一个动作-&gt;i=1也会刷回到主存中*/ volatile和synchronized的区别！ volatile只能用于变量，而synchronized可以作用于变量、方法和代码块 多线程访问volatile不会发生阻塞，而synchronized关键字会发生阻塞 volatile能够保证数据的可见性，就是在多个线程之间是可见的，不能保证原子性，而synchronized关键字可以保证 volatile关键字主要解决的是多个线程之间的可见性，而synchronized关键字保证的是多个线程访问资源的同步性 volatile是可以禁止jvm指令重排的，但是synchronized是不能的 synchronized的底层原理 了解 每一个锁资源对应一个monitor对象，在HotSpot虚拟机中它是由ObjectMonitor实现的(C++实现) 线程和进程的区别 地址空间：同一进程的线程共享本进程的地址空间，而进程之间则是独立的地址空间。 进程与进程之间是独立的. 同一个进程内部的多个线程是可以共享进程资源的. 1比如:没有国[进程]就没有家[线程] 家[进程] - 拥有多个家庭成员的[线程] 资源拥有：同一进程内的线程共享本进程的资源，但是进程之间的资源是独立的。 一个进程崩溃后，在保护模式下不会对其他进程产生影响，但是一个线程崩溃整个进程都死掉。所以多进程要比多线程健壮。 进程切换时，消耗的资源大，效率高。所以涉及到频繁的切换时，使用线程要好于进程。同样如果要求同时进行并且又要共享某些变量的并发操作，只能用线程不能用进程。 -进程重量级的单位(创建,切换,销毁 - 费时)s -线程轻量级的单位(创建,切换,销毁 - 比较高) 执行过程：每个独立的进程有一个程序运行的入口、顺序执行序列和程序入口。但是线程不能独立执行，必须依存在应用程序中，由应用程序提供多个线程执行控制。 线程是处理器调度的基本单位，但是进程不是。 两者均可并发执行。 一个线程只属于一个进程，但是一个进程可以拥有多个线程，但至少一个线程资源分配给进程，同一进程中所有线程共享该进程的所有资源。 线程状态 - 线程生命周期 简介:线程的生命周期. New：新建状态/瞬态，当线程对象创立后，即进入了新建状态，如：Thread t = new MyThread() Runnable：就绪状态，当调用线程对象的start()方法（t.start()），线程就进入就绪状态。处于就绪状态的线程，只是说明此线程已经做好了准备，随时等待cpu调度执行，并不是说执行了t.start()此线程立即就会执行 Running：运行状态，当cpu开始调度处于就绪状态的线程时，此时线程才得以真正执行，即进入到运行状态。 Blocked：阻塞状态，处于运行状态中的线程由于某种原因，暂时放弃对cpu的使用权，停止执行，此时进入阻塞状态，直到其进入到就绪状态，才有机会再次被cpu调用以进入到运行状态 Dead：死亡状态(结束状态)，线程执行完了或者因异常退出了run()方法，该线程结束生命周期 （1）就绪状态是进入到运行状态的唯一入口 （2）线程想要进入到运行状态执行，首先必须处于就绪状态中 （3）根据阻塞产生的原因，阻塞状态又可以分为三种： 【1】等待阻塞：运行状态中的线程执行wait()方法，使本线程进入到等待阻塞状态 【2】同步阻塞：线程在获取synchronized同步锁失败（因为锁被其他线程占用），它会进入同步阻塞状态 【3】其他阻塞：通过调用线程的sleep()或join()或发出了I/O请求时，线程会进入到阻塞状态。当sleep()状态超时时、join()等待线程终止或者超时、或者I/O处理完毕时，线程重新转入就绪状态.之前获取键盘输入. 守护线程 GC - 运行在后台的 - 负责回收垃圾对象的. 核心:线程结束的时候不需要关心后台的守护线程是否也运行结束.线程是不会等后台的守护线程全部运行结束才结束. 当后台只有守护线程在执行的时候,就可以认为线程可以结束了. 12345678910111213141516171819202122232425262728293031323334353637383940414243public class DaemonDemo &#123; public static void main(String[] args) &#123; Thread t1 = new T1(); Thread t2 = new T2(); //将打印数字的线程 - 设置成后台守护线程 //如果后台只剩下守护线程在执行 - 可以结束了 //不需要等到所有的守护线程运行结束才结束 t2.setDaemon(true); //如果t1和t2都不是守护线程 - main线程一定是等待两个线程全部执行完之后，才会结束 t1.start(); t2.start(); &#125;&#125;class T1 extends Thread&#123; @Override public void run() &#123; for (int i = 65; i &lt;100 ; i++) &#123; System.out.println((char)i); try &#123; Thread.sleep(100); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125;&#125;class T2 extends Thread&#123; @Override public void run() &#123; for (int i = 0; i &lt;100 ; i++) &#123; System.out.println(i); try &#123; Thread.sleep(500); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125;&#125; Lock - 同步代码简介:它是一个接口,下面有很多实现类,笔试题lock和synchronized的区别! lock是接口,synchronized它是一个关键字 lock锁是一个显示锁(手动申请锁,手动释放锁),synchronized隐式锁(自动申请/释放锁) lock手动申请锁**(对象锁)** lock是锁代码块 lock出现异常的时候,是不会主动释放资源的. 123456789101112131415161718192021222324252627282930313233343536373839404142434445/** * 本类用于演示： Lock同步代码 - 同步代码块 * 申请的是对象锁 - 相同的对象才会去竞争一把锁. * 如果出现了异常 - 是不会主动释放锁的. */public class LockHelloDemo &#123; //构建lock对象 - 接口 Lock lock = new ReentrantLock(); public void add()&#123; try &#123; //begin.. //多个线程就会去竞争&quot;锁资源&quot; lock.lock();//手动申请&quot;锁资源&quot; - 显示锁 //在某个时刻只能由一个线程进入去执行... //同步代码开始 System.out.println(Thread.currentThread().getName()+&quot;:0&quot;); try &#123; //sleep如果出现同步代码中,它并不会释放锁资源,只会让出cpu时间片段 Thread.sleep(1000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(Thread.currentThread().getName()+&quot;:1&quot;); //end... //同步代码结束 &#125;catch (Exception e) &#123; e.printStackTrace(); &#125;finally &#123; lock.unlock(); &#125; &#125; public static void main(String[] args) &#123; LockHelloDemo lockHelloDemo = new LockHelloDemo(); Thread t1 = new Thread(()-&gt;lockHelloDemo.add()); Thread t2 = new Thread(()-&gt;lockHelloDemo.add()); t1.start(); t2.start(); &#125;&#125; 死锁死锁产生的条件 互斥条件：指进程对所分配到的资源进行排它性使用，即在一段时间内某资源只由一个进程占用。如果此时还有其它进程请求资源，则请求者只能等待，直至占有资源的进程用毕释放。 请求和保持条件：指进程已经保持至少一个资源，但又提出了新的资源请求，而该资源已被其它进程占有，此时请求进程阻塞，但又对自己已获得的其它资源保持不放。 不剥夺条件：指进程已获得的资源，在未使用完之前，不能被剥夺，只能在使用完时由自己释放。 环路等待条件：指在发生死锁时，必然存在一个进程——资源的环形链，即进程集合{P0，P1，P2，···，Pn}中的P0正在等待一个P1占用的资源；P1正在等待P2占用的资源，……，Pn正在等待已被P0占用的资源。 只要打破四个条件的一个,就可以防止死锁. 死锁是不可避免,但是需要写程序的破坏四个条件中的一个. 静态域容易产生死锁. 四种常见的线程池 - 必考线程池的返回值ExecutorService简介 ExecutorService是Java提供的用于管理线程池的类。该类的两个作用：控制线程数量和重用线程 Executors.newCacheThreadPool()：可缓存线程池，先查看池中有没有以前建立的线程，如果有，就直接使用。如果没有，就建一个新的线程加入池中，缓存型池子通常用于执行一些生存期很短的异步型任务 Executors.newFixedThreadPool(int n)：创建一个可重用固定个数的线程池，以共享的无界队列方式来运行这些线程。 Executors.newScheduledThreadPool(int n)：创建一个定长线程池，支持定时及周期性任务执行 Executors.newSingleThreadExecutor()：创建一个单线程化的线程池，它只会用唯一的工作线程来执行任务，保证所有任务按照指定顺序(FIFO, LIFO, 优先级)执行。","categories":[{"name":"多线程","slug":"多线程","permalink":"http://example.com/categories/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"}],"tags":[{"name":"java","slug":"java","permalink":"http://example.com/tags/java/"}]},{"title":"Enum(枚举类型)","slug":"Enum","date":"2021-08-10T05:20:13.000Z","updated":"2021-08-10T05:21:39.736Z","comments":true,"path":"2021/08/10/Enum/","link":"","permalink":"http://example.com/2021/08/10/Enum/","excerpt":"","text":"枚举类型枚举常量 - 类型安全的常量 - 公共的静态的常量[final]属性 - 不可变的 jdk5.0开始提供的,以前的作用就是用来替代常量接口的 回忆常量接口 - 管理和维护项目中所有的常量的 12345678910public interface IConsts&#123;//最全的写法 - 接口中只能出现公开的静态的常量属性//public static final int Car = 1;//精简的写法//public int CAR = 1;//最精简的写法int CAR = 1;&#125; 关键字 使用enum关键字来定义一个枚举类型的 switch()中的参数类型可以是byte,short,int,char,enum,String,Byte,Short,Integer 特点 枚举常量,多个枚举常量,使用,隔开.最后一个枚举常量不需要使用逗号了. 如果最后一个枚举常量下面还有代码的话,那么需要使用分号隔开 允许存在构造 - 访问修饰符不能是公开的,protected 枚举类型是不能够被实例化的 枚举类型中可以提供普通属性 每个枚举类型默认都会自动继承java.lang.Enum 枚举类型中是可以存在抽象方法的,但是每个枚举常量必须要实现这个抽象方法 枚举类型不支持再去extends另外一个枚举类型 枚举类型不支持再去手动extends另外一个类 应用 如果某些属性具有固定的一些标识,就可以考虑定义成枚举类型. 比如:User实体类中维护了一个性别属性Gender[性别的枚举类型] 比如:Order实体类也会存在固定的状态 - 未付款,已付款.已下单未付款.取消订单等… 字符串-&gt;枚举常量 比如一个注册页面 用户名 tom 性别 单选按钮 男 单选按钮 女 确定按钮 未来.当点击确定按钮,后台接受到M,F - 后台接受到的数据都是字符串数据. 我们是不能够直接将这个字符串数据设置到实体类中的枚举常量属性上的. 每个自定义的枚举类型Gender.java默认都会继承java.lang.Enum 12public static &lt;T extends Enum&lt;T&gt;&gt; T valueOf(Class&lt;T&gt; enumType, String name) &#123; &#125; 123456789101112131415161718192021222324/** * 本类用来演示: String-&gt;枚举类型 */public class StringToEnumDemo &#123; public static void main(String[] args) &#123; String gender = &quot;F&quot;;//接受到页面传过来的数据 - 都是字符串类型 //字符串类型是不能够直接设置给实体类的那个枚举常量属性上的 //System.out.println(FString.class); // System.out.println(Integer.class); //Class&lt;?&gt; c = String.class; //System.out.println(c); //将字符串转换成枚举常量类型 //注意 - 字符串的值一定是和枚举常量的名称是保持一致的. //否则 - java.lang.IllegalArgumentException: // No enum constant tech.aistar.day14.enums.Gender.S Gender g = Enum.valueOf(Gender.class,gender); User user = new User(1,&quot;tom&quot;,g); System.out.println(user); &#125;&#125; 枚举单例 它是effective java作者极力推荐的写法 - 枚举实例 - 1. 枚举类型天生就是线程安全的.2. 可以防止序列化或者反射来破坏这种单例的. 单例 - 保证在整个应用程序中,某个类的具体的实例永远只有1个. 什么时候需要把类做成单例的 - 这个类是一个重量级的类[类的创建和销毁的成本比较高.] 枚举常量是类型安全的常量???12345678910111213141516171819public enum Gender&#123; F,M&#125;因为使用枚举常量 - 第一步肯定是先加载枚举类型Gender - JVM通过类加载器[java.lang.ClassLoader]来加载枚举类型protected Class&lt;?&gt; loadClass(String name, boolean resolve) throws ClassNotFoundException &#123; //使用到了synchronized关键字 synchronized (getClassLoadingLock(name)) &#123; //.... 加载类,接口,枚举类型到JVM内存 &#125; &#125;很多线程都在调用Gender.M - &gt; 都想尝试加载Gender枚举类型到JVM内存.但是由于loadClass加载的那块代码使用到了synchronized[锁]只能由一个线程进去执行,并且只会执行一次. 由于每个枚举常量F 本质 就是 public static final Gender F = new Gender();//使用到了static关键字//意味着当枚举类型一旦被加载了,枚举常量立即就会被分配空间以及初始化,并且机会只有一次.所以在整个内存中F常量也就只会存在一份.//无论在哪里被调用.无论被多少给线程调用 - 大家拿到的都是同一个/同一份那个枚举常量. 具体的代码的实现123456789101112131415161718192021222324252627282930313233343536/** * 本类用来演示: 枚举单例实现方式 */public class Singleton04 implements Serializable &#123; private Singleton04()&#123; System.out.println(&quot;私有化构造&quot;); &#125; //内部的枚举类型 private enum SingletonEnum&#123; //枚举常量的实例 INSTANCE;//public static final SingletonEnum INSTANCE = new SingletonEnum(); //final修饰的变量要赋值 private final Singleton04 instance; //枚举类型提供一个空参构造 - 枚举类型是不能new的 SingletonEnum()&#123; instance = new Singleton04(); &#125; //提供一个普通方法 public Singleton04 getInstance()&#123; return instance; &#125; &#125; //外部类肯定是要提供一个方法,返回自己的一个唯一实例的 public static Singleton04 getInstance()&#123; return SingletonEnum.INSTANCE.getInstance(); &#125;&#125;class TestSingle04&#123; public static void main(String[] args) &#123; System.out.println(s1 == s2);//true &#125;&#125; 枚举单例写法12345678910111213141516171819202122232425262728293031/** * 本类用来演示: 枚举单例 - 最精简的写法 - 多线程安全的写法 - 饿汉模式 */public enum Singleton05 &#123; //public static final Singleton05 INSTANCE = new Singleton05(); INSTANCE; Singleton05()&#123; System.out.println(&quot;比较繁琐的操作的事情,费时费力的事情&quot;); &#125; public static Singleton05 getInstance()&#123; return INSTANCE; &#125;&#125;对比饿汉模式的写法public class Singleton01 &#123; //2. 初始化一个变量,该变量就是该类的唯一实例[对象] private static Singleton01 instance = new Singleton01(); //1. 私有化构造 private Singleton01()&#123; //比较费时费力的代码,可能需要更多的时间 System.out.println(&quot;Singleton01...&quot;); &#125; //3. 提供一个公开的静态的方法来返回这个类的唯一实例 public static Singleton01 getInstance()&#123; return instance; &#125;&#125; 枚举单例阻止序列化的破坏 序列化单例对象s1 反序列化封装到单例对象s3 s1 == s3 ;// 仍然为true 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051/** * 本类用来演示: 枚举单例 - 最精简的写法 * 只能用来玩枚举类型，才不会被序列化破坏！！！ */public enum Singleton05 &#123; //public static final Singleton05 INSTANCE = new Singleton05(); INSTANCE; Singleton05()&#123; System.out.println(&quot;比较繁琐的操作的事情,费时费力的事情&quot;); &#125; public static Singleton05 getInstance()&#123; return INSTANCE; &#125;&#125;class TestSingleton05&#123; public static void main(String[] args) &#123; Singleton05 s1 = Singleton05.getInstance(); Singleton05 s2 = Singleton05.getInstance(); System.out.println(s1 == s2);//true //序列化 try(ObjectOutputStream out = new ObjectOutputStream(new FileOutputStream(&quot;src/tech/aistar/design/ss.txt&quot;)))&#123; //对单例进行序列化操作 out.writeObject(s1); &#125; catch (FileNotFoundException e) &#123; e.printStackTrace(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; //反序列化 try(ObjectInputStream in = new ObjectInputStream(new FileInputStream(&quot;src/tech/aistar/design/ss.txt&quot;)))&#123; Singleton05 s3 = (Singleton05) in.readObject(); System.out.println(s1 == s3);//true &#125; catch (FileNotFoundException e) &#123; e.printStackTrace(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; catch (ClassNotFoundException e) &#123; e.printStackTrace(); &#125; &#125;&#125; 枚举细节 - 抽象方法枚举类型中是可以存在抽象方法的,但是每个枚举常量必须要实现这个抽象方法 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263/** * 本类用来演示: 季节的枚举类型 */public enum Season&#123; //枚举类型中是可以存在抽象方法的,但是每个枚举常量必须要实现这个抽象方法 SPRING(&quot;春天&quot;)&#123; @Override public Season next() &#123; return Season.SUMMER; &#125; &#125;, SUMMER(&quot;夏天&quot;) &#123; @Override public Season next() &#123; return Season.AUTUMN; &#125; &#125;, AUTUMN(&quot;秋天&quot;) &#123; @Override public Season next() &#123; return Season.WINTER; &#125; &#125;, WINTER(&quot;冬天&quot;) &#123; @Override public Season next() &#123; return Season.SPRING; &#125; &#125;; private String sign; Season()&#123; &#125; Season(String sign) &#123; this.sign = sign; &#125; public String getSign() &#123; return sign; &#125; //提供一个抽象方法 - 但是要求所有的枚举常量都要重写这个抽象方法 public abstract Season next();&#125;class TestSeason&#123; public static void main(String[] args) &#123; Season s = Season.SPRING; for(;;)&#123; System.out.println(s+&quot;-&quot;+s.getSign()); try &#123; //让程序睡一秒钟 Thread.sleep(1000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; s = s.next(); &#125; &#125;&#125;","categories":[{"name":"枚举类型","slug":"枚举类型","permalink":"http://example.com/categories/%E6%9E%9A%E4%B8%BE%E7%B1%BB%E5%9E%8B/"}],"tags":[{"name":"java","slug":"java","permalink":"http://example.com/tags/java/"}]},{"title":"Generic2(泛型的继承)","slug":"Generic2","date":"2021-08-10T05:17:46.000Z","updated":"2021-08-10T05:18:43.681Z","comments":true,"path":"2021/08/10/Generic2/","link":"","permalink":"http://example.com/2021/08/10/Generic2/","excerpt":"","text":"泛型类的继承 子类不指定具体的类型 子类指定具体的类型 demo123456789101112131415161718/** * 本类用来演示: 泛型类的继承 */public class GenericExtendsDemo &#123;&#125;//泛型父类class Sup&lt;T&gt;&#123; &#125;//子类继承父类的时候,没有指定具体的类型class Sub&lt;T&gt; extends Sup&lt;T&gt;&#123; &#125;//子类继承父类的时候,指定了具体的类型class Sub01&lt;Product&gt; extends Sup&lt;Product&gt;&#123; &#125; 泛型的具体应用 了解一下即可 场景:在接口的制定中.很多接口具有相同的或者类似的功能.比如 123456789101112131415161718192021//dao层接口 - data access object - 数据访问对象层 - 数据持久层//这一层专门和数据库[crud增删改查操作][文件_IO流操作]打交道//教师的业务接口public interface ITeacherDao&#123; void save(Teacher teacher); //保存教师&#125;public interface IStudentDao&#123; //学生的业务接口 void save(Student student); // 保存学生&#125;//再去写俩个具体的实现类分别是TeacherDaoImpl.java以及StudentDaoImpl.java//这俩个实现类中 - 具体的代码,现阶段知识点 - 把单个java对象保存到文件中[IO流技术].//未来 - 肯定是要把java对象保存到db中 - 持久化的操作[java内存中的对象保存到DB中]//关于dao层 - java如何操作数据库 - 原生技术jdbc,dao层框架 - Hibernate框架以及mybatis框架//比如现在选取的是所谓的Hibernate框架Hibernate框架来把java的内存对象保存到DB中session.beginTransaction(); //开启一个事务session.save(user); //具体的调用的是这个框架中的保存方法session.getTransaction().commit();//提交一个事务 顶级接口的实现类IBaseDao 12345public interface IBaseDao&lt;T&gt; &#123; //顶级的业务接口中应该存储的就是各个子接口中共性的方法 //这些方法都有共同点 - 大部分的代码是一样的,仅仅是操作的对象不一样而已. void save(T t);&#125; IBaseDao的实现类 12345678910public class BaseDaoImpl&lt;T&gt; implements IBaseDao&lt;T&gt; &#123; @Override public void save(T t) &#123;// session.beginTransaction();//开启一个事务// session.save(t);//具体的调用的是这个框架中的保存方法// session.getTransaction().commit();//提交一个事务 System.out.println(t); &#125;&#125; Student接口，具体的业务接口去继承这个顶级的业务接口，具有相同特征的需要继承 123public interface IStudent extends IBaseDao&lt;Student&gt; &#123; void taoKe();&#125; 具体的学生接口的实现类StudentImpl(里面可以用来定义学生中特有的方法) 同时也需要继承顶级业务接口的实现类，这样就可以接受已经实现的方法 1234567//泛型继承 - 指定了泛型类public class StudentImpl extends BaseDaoImpl&lt;Student&gt; implements IStudent &#123; @Override public void taoKe() &#123; System.out.println(&quot;逃课...&quot;); &#125;&#125; 单元测试 12345678public class TestBase &#123; public static void main(String[] args) &#123; IStudent student = new StudentImpl(); Student s = new Student(1,&quot;代文恒&quot;); student.save(s); student.taoKe(); &#125;&#125;","categories":[{"name":"泛型","slug":"泛型","permalink":"http://example.com/categories/%E6%B3%9B%E5%9E%8B/"}],"tags":[{"name":"java","slug":"java","permalink":"http://example.com/tags/java/"}]},{"title":"Generic泛型","slug":"Generic","date":"2021-08-08T14:44:49.000Z","updated":"2021-08-08T14:48:49.302Z","comments":true,"path":"2021/08/08/Generic/","link":"","permalink":"http://example.com/2021/08/08/Generic/","excerpt":"","text":"泛型Generic定义 Java在1.5之后加入了泛型的概念。泛型，即“参数化类型”。 泛型的本质是为了参数化类型(将类型参数化传递)(在不创建新的类型的轻快下，通过泛型指定的不同类型来控制形参具体限制的类型)。也就是说在泛型使用过程中，操作的数据类型被指定为一个参数。 这种参数类型可以用在类、接口和方法中，分别被称为泛型类、泛型接口、泛型方法。 泛型只能是对象类型，比如User、Student，或者内置对象类型，比如String、Integer[一定是包装类型] 123456789101112~~~java//jdk5.0之前List list = new ArrayList();//集合中可以添加任意类型的数据//jdk5.0开始~jdk7.0之前//类型安全的集合框架List&lt;Integer&gt; list - new ArrayList&lt;Integer&gt;();//在编译期间确定了集合中添加的数据的类型,只能是Integer类型.//jdk7.0开始//结论:泛型只有编译期间的概念,在运行期间将会被擦除.List&lt;Integer&gt; list = new ArrayList&lt;&gt;(); 泛型符号 E - 元素 K,V - 键值对 N - 数字 ？ - 通配符 为什么要有泛型呢？对别一下没有泛型，会导致什么结果？ 加入了泛型之后，可以保证代码的健壮性 加入了泛型之后，取值的时候，不需要进行强制类型的转换 加入了泛型之后，代码会变得更加简介 123456789101112131415161718192021222324public class GenericDemo &#123; public static void main(String[] args) &#123; //jdk5.0之前 List list = new ArrayList(); //集合中可以添加任何类型的数据 list.add(10); //10-&gt;java.lang.Integer list.add(&quot;ok&quot;); //字符串 //没有泛型的时候,获取集合中的元素 - 统计的返回值类型都是Object类型 //需要进行强制类型的转换，转换的过程中有可能会抛出java.lang.ClassCastException类型转换失败异常 //在类型转换之前，建议先进行类型的判断，使用instanceof关键字 String s = (String) list.get(1); System.out.println(s); //jdk7.0开始 //一旦指定了泛型,add方法中的E成了String类型,返回类型也是String类型 List&lt;String&gt; list1 = new ArrayList&lt;&gt;(); list1.add(&quot;ok&quot;); list1.add(&quot;no&quot;); //根据下标获取 - 不需要进行类型的强制转换了，自动能识别出返回类型就是你指定的那个泛型. String s1 = list1.get(1); System.out.println(s1); &#125;&#125; 泛型只有编译期间的概念，在进行期间将会被擦除结论：泛型是没有多态的 泛型只有编译期间的概念 - 泛型仅仅是在编译期间是有效的 在编译期间一旦确定了泛型，那么在编译期间就只能向这个容器中添加对应类型的数据 否则编译报错. 运行期间将会被擦除 - 泛型是不存在运行时类型的 123456789101112131415161718192021222324252627282930313233343536373839404142public class GenericRuntimeDemo &#123; public static void main(String[] args) &#123; //多态的语法 - 多态的应用 //面向父类编程 / 面向接口编程 //编译时类型 对象名 = new 运行时类型(); //父类 对象 = new 子类(); //接口 对象 = new 实现类(); //java.lang.Integer extends java.lang.Number //java.lang.Long extends java.lang.Number Number n1 = new Integer(10); Number n2 = new Long(20L); //jdk5.0~jdk7.0之前 List&lt;Integer&gt; list1 = new ArrayList&lt;Integer&gt;(); //思考 - 编译时错误的 //结论 ： 泛型是没有多态的 //原因 ： 泛型只有编译期间的概念，在运行期间将会被擦除 //List&lt;Number&gt; list2 = new ArrayList&lt;Integer&gt;(); List&lt;Long&gt; list2 = new ArrayList&lt;Long&gt;(); //获取对象的运行时类型 //忘记了 - java.lang.Object中的toString方法 getClass().getName() // +&quot;@&quot;+Integer.toHexString(hashCode()); //Class实例 - 别名：对象的运行时类型 Class&lt;?&gt; c1 = list1.getClass(); Class&lt;?&gt; c2 = list2.getClass(); System.out.println(c1 == c2); //true //结论：获取运行时类型式中都是ArrayList，和&lt;Integer&gt;&lt;Long&gt;是无关的 //所以泛型仅仅是在编译期间有效，但是在运行期间是无效的[将会被擦除，将会失效] System.out.println(c1);//class java.util.ArrayList System.out.println(c2);//class java.util.ArrayList //结论： 一个类无论被实例化多少次，它在JVM的Class对象/实例永远只有一个 User user1 = new User(); User user2 = new User(); System.out.println(user1.getClass()); System.out.println(user2.getClass()); System.out.println(user1.getClass() == user2.getClass()); //true &#125;&#125; 泛型的通配符 ？extends T - 只能是T类型或者T类型的子类 - 指定类型的上限 123456789101112131415161718192021222324252627282930313233343536373839404142public class WildCardDemo &#123; public static void main(String[] args) &#123;// List&lt;?&gt; list = new ArrayList&lt;&gt;();// list.add(10); //error// list.add(&quot;ok&quot;); //error// list.add(null); //ok List&lt;Integer&gt; list = new ArrayList&lt;&gt;(); list.add(10); list.add(12); list.add(14); List&lt;Long&gt; longs = new ArrayList&lt;&gt;(); longs.add(100L); longs.add(200L); longs.add(300L); //能否定义一个方法，能够打印上面两个集合 printList(list); System.out.println(&quot;============&quot;); printList(longs); &#125; //泛型是不存在多态的 //假设认为是List&lt;Number&gt; list = new ArrayList&lt;Long&gt;(); //error //Integer 和 Long都是extends Number //? extends T - 只能是T类型或者T类型的子类 - 指定类型的上限 //? super T - 只能是T类型或者T类型的父类 - 指定类型的下限 //建议 - 比较器Collections.sort(list&lt;T&gt; list,Comparator&lt;? super T&gt; c&gt; private static void printList(List&lt;? extends Number&gt; list) &#123; //推荐使用集合的迭代器 //获取集合的迭代器对象 Iterator&lt;? extends Number&gt; iter = list.iterator(); while (iter.hasNext())&#123; //Integer,Long -&gt; extends -&gt; Number -&gt; 多态的语法 Number nt = iter.next(); System.out.println(nt); &#125; &#125;&#125; ？super T - 只能是T类型或者T类型的父类 - 指定类型的下限 泛型类定义类的时候，给定一个泛型，真正使用的时候，再确定具体的类型 123456789101112131415161718192021222324252627282930313233343536public class GenericClassDemo&lt;T&gt; &#123; //定义属性 private T t; public GenericClassDemo() &#123; &#125; //将类型参数化传递 public GenericClassDemo(T t) &#123; this.t = t; &#125; //将类型参数化传递 public void setT(T t) &#123; this.t = t; &#125; //泛型方法 public T getT() &#123; return t; &#125; public static void main(String[] args) &#123; //测试泛型类 GenericClassDemo&lt;String&gt; genericClassDemo = new GenericClassDemo(&quot;java&quot;); genericClassDemo.setT(&quot;ok&quot;); String t = genericClassDemo.getT(); System.out.println(t); System.out.println(&quot;==========&quot;); GenericClassDemo&lt;Integer&gt; c = new GenericClassDemo&lt;&gt;(100); System.out.println(c.getT()); &#125;&#125; 泛型方法如果泛型加载类上面，对整个类内部的泛型的地方都有影响 如果某个类中就那么几个方法需要使用到泛型，没有必要定义泛型类，只需要定义泛型方法即可。 如果若干个很多个方法都使用到了泛型，有必要定义一个泛型类 1234567891011121314151617181920212223242526272829303132public class GenericMethodDemo &#123; //非静态方法 - 无返回值类型 public &lt;T&gt; void test01(T t)&#123; System.out.println(&quot;test01...&quot;+t); &#125; //非静态方法 - 带返回值类型的 public &lt;E&gt; E test02(E e)&#123; System.out.println(&quot;e:&quot;+e); return e; &#125; //静态方法 public static &lt;E&gt; E test03(E e)&#123; System.out.println(&quot;test03...e:&quot;+e); return e; &#125; public static void main(String[] args) &#123; GenericMethodDemo genericMethodDemo = new GenericMethodDemo(); //如何确定到方法的参数T //JVM根据传入的方法的实参 - 拿到这个实参的类型 -&gt; 方法的参数T genericMethodDemo.test01(&quot;100+String&quot;); //String //调用带有返回类型 genericMethodDemo.test02(616.6); //Double //泛型是类型安全的 GenericMethodDemo.test03(&quot;ajoighoiaehgoa&quot;); &#125;&#125; 泛型应用1234567ObjectInputStream/ObjectOuputStream - 操作对象类型的字节文件输入流和对象类型的文件字节输出流 Object in.readObject()/out.writeObject(Object obj);Jdk没有对readObject方法进行优化,每次调用完之后,进行强制类型的转换操作的. 思考 - 无论是保存/读取User对象或者Book对象 - 用一个方法去实现 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859public class IOUtil&lt;T&gt; &#123; //提供一个方法可以任意保存的任意对象 public static &lt;T&gt; void writeList(List&lt;T&gt; list,String path)&#123; try(ObjectOutputStream out =new ObjectOutputStream(new FileOutputStream(path))) &#123; out.writeObject(list); &#125; catch (FileNotFoundException e) &#123; e.printStackTrace(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; //提供一个方法可以读取文件中的任意对象 //语法如果定义成了一个泛型类，并且是静态方法的话，那么必须要把这个静态方法也设置成泛型方法 //如果是定义成了一个泛型类，但是是普通方法的话，那么这个普通方法是不需要设置成泛型方法的 public static &lt;T&gt; List&lt;T&gt; readList(String path)&#123; List&lt;T&gt; list = null; try(ObjectInputStream in = new ObjectInputStream(new FileInputStream(path))) &#123; //因为对象类型的字节输入流是【一次性读取】的 所以直接输入给list list = (List&lt;T&gt;) in.readObject(); &#125; catch (FileNotFoundException e) &#123; e.printStackTrace(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; catch (ClassNotFoundException e) &#123; e.printStackTrace(); &#125; return list; &#125;&#125;class Test&#123; public static void main(String[] args) &#123; Product d1 = new Product(1,&quot;老戴&quot;); Product d2 = new Product(2,&quot;老李&quot;); Product d3 = new Product(3,&quot;老刘&quot;); Product d4 = new Product(4,&quot;老尼玛&quot;); List&lt;Product&gt; list = new ArrayList&lt;&gt;(); list.add(d1); list.add(d2); list.add(d3); list.add(d4); String path = &quot;src/stu/aistar/util/content.txt&quot;; IOUtil.writeList(list,path); List&lt;Product&gt; list1 = IOUtil.readList(path); if(null != list1 &amp;&amp; list1.size()&gt;0)&#123; list1.forEach(e-&gt; System.out.println(e)); &#125; &#125;&#125;class delFile&#123; public static void main(String[] args) &#123; String s = &quot;src/stu/aistar/util/content.txt&quot;; File file = new File(s); if (file.isFile())&#123; file.delete(); &#125; &#125;&#125;","categories":[{"name":"泛型","slug":"泛型","permalink":"http://example.com/categories/%E6%B3%9B%E5%9E%8B/"}],"tags":[{"name":"java","slug":"java","permalink":"http://example.com/tags/java/"}]},{"title":"对象包装流+CRUD","slug":"Test03","date":"2021-08-06T10:06:21.000Z","updated":"2021-08-06T10:07:41.723Z","comments":true,"path":"2021/08/06/Test03/","link":"","permalink":"http://example.com/2021/08/06/Test03/","excerpt":"","text":"CRUD操作 本篇所用到的技术： 接口的定义，实现类 序列化 利用对象字节流-包装流，对数据进行增删改查到指定文件中，和对文件进行读取 Phone实体类 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051package stu.aistar.day13.project.entity;import java.io.Serializable;public class Phone implements Serializable &#123; private int id; private String name; private double price; public Phone() &#123; &#125; public int getId() &#123; return id; &#125; public void setId(int id) &#123; this.id = id; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public double getPrice() &#123; return price; &#125; public void setPrice(double price) &#123; this.price = price; &#125; public Phone(int id, String name, double price) &#123; this.id = id; this.name = name; this.price = price; &#125; @Override public String toString() &#123; final StringBuilder sb = new StringBuilder(&quot;Phone&#123;&quot;); sb.append(&quot;id=&quot;).append(id); sb.append(&quot;, name=&#x27;&quot;).append(name).append(&#x27;\\&#x27;&#x27;); sb.append(&quot;, price=&quot;).append(price); sb.append(&#x27;&#125;&#x27;); return sb.toString(); &#125;&#125; IPhoneDao接口(对数据的操作) 1234567891011121314package stu.aistar.day13.project.dao;import stu.aistar.day13.project.entity.Phone;import java.util.List;public interface IPhoneDao &#123; List&lt;Phone&gt; findAll(); void delById(Integer id); void save(Phone phone); void updateById(Integer id);&#125; PhoneDaoImpl实现类 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136package stu.aistar.day13.project.dao.impl;import stu.aistar.day13.project.dao.IPhoneDao;import stu.aistar.day13.project.entity.Phone;import java.io.*;import java.util.ArrayList;import java.util.List;import java.util.Scanner;/** * 本类用于演示： */public class PhoneDaoImpl implements IPhoneDao &#123; private String path = &quot;src/stu/aistar/day13/project/data/phone.txt&quot;; @Override public List&lt;Phone&gt; findAll() &#123; List&lt;Phone&gt; list = new ArrayList&lt;&gt;(); //定义一个数组用来存储查询出来的信息 File file = new File(path); if (!file.exists() || file.length()==0)&#123; System.out.println(&quot;文件不存在！！！！！！！！！！！！！！！！！！&quot;); return null; &#125; try(ObjectInputStream in =new ObjectInputStream(new FileInputStream(path)))&#123; list = (List&lt;Phone&gt;) in.readObject(); //从文件中读取数据 存放到list集合中 &#125; catch (FileNotFoundException e) &#123; e.printStackTrace(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; catch (ClassNotFoundException e) &#123; e.printStackTrace(); &#125; return list; //返回list &#125; @Override public void delById(Integer id) &#123; List&lt;Phone&gt; list = findAll(); //先把所有的产品查询出来 以便后序操作(del...) try(ObjectInputStream in = new ObjectInputStream(new FileInputStream(path)); ObjectOutputStream out = new ObjectOutputStream(new FileOutputStream(path))) &#123; boolean flag = false; //用来记录 想要删除的id对应的产品是否存在 for (int i = 0; i &lt; list.size(); i++) &#123; if (list.get(i).getId() == id)&#123; list.remove(i); i--; flag = true; //存在想要删除的产品 &#125; &#125; if (!flag)&#123; //flag = false的时候进入这里 证明产品不存在 System.out.println(&quot;您想要删除的产品不存在！&quot;); &#125; out.writeObject(list); &#125; catch (FileNotFoundException e) &#123; e.printStackTrace(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; @Override public void save(Phone phone) &#123; File file =new File(path); if (!file.exists())&#123; //第一次存产品的时候进入 -&gt; 第一次该文件还不存在 //多余 写入文件自动创建 try &#123; file.createNewFile(); //创建文件 &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; List&lt;Phone&gt; list = new ArrayList&lt;&gt;(); //创建集合 list.add(phone); //存入该产品 try(ObjectOutputStream out = new ObjectOutputStream(new FileOutputStream(path))) &#123; out.writeObject(list);//写入文件(提示：每一次写文件 系统都是将该文件清空 然后再存入你写进去的文件) System.out.println(&quot;保存成功！&quot;); &#125; catch (FileNotFoundException e) &#123; e.printStackTrace(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125;else if(file.length()==0)&#123; //文件存在 但是文件为空的状态下 List&lt;Phone&gt; list = new ArrayList&lt;&gt;(); //需要创建一个集合 以便后序存储 list.add(phone); //将产品存进集合 try(ObjectOutputStream out = new ObjectOutputStream(new FileOutputStream(path))) &#123; out.writeObject(list); //写入文件 System.out.println(&quot;保存成功！&quot;); &#125; catch (FileNotFoundException e) &#123; e.printStackTrace(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125;else &#123; //此处为文件存在 且文件不为空的情况下 List&lt;Phone&gt; oldList = findAll(); //先把文件中的数据查询出来 然后加入新产品 oldList.add(phone); try(ObjectOutputStream out = new ObjectOutputStream(new FileOutputStream(path))) &#123; out.writeObject(oldList); //存进文件里 System.out.println(&quot;保存成功！&quot;); &#125; catch (FileNotFoundException e) &#123; e.printStackTrace(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125; @Override public void updateById(Integer id) &#123; List&lt;Phone&gt; list = findAll(); Phone phone = null; Scanner sc = new Scanner(System.in); System.out.println(&quot;您要修改的是&quot;+id+&quot;号产品：&quot;); for (int i = 0; i &lt; list.size(); i++) &#123; //找到你想要修改的产品的id对应的下标 if (list.get(i).getId() == id)&#123; phone = list.get(i); //把下标对应的产品拿出来 System.out.print(&quot;请修改它的名字：&quot;); phone.setName(sc.nextLine()); //修改为新的名字 System.out.print(&quot;请修改它的价格：&quot;); phone.setPrice(sc.nextDouble()); //修改为新的价格 list.remove(i); //把原本的那个数据删除 list.add(phone); //存进你修改过后的原产品 break; //break 的原因是 你已经找到了该产品 &#125; &#125; System.out.println(&quot;修改成功！&quot;); try(ObjectOutputStream out = new ObjectOutputStream(new FileOutputStream(path)))&#123; out.writeObject(list); &#125; catch (FileNotFoundException e) &#123; e.printStackTrace(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125;&#125; 下面就是一些测试。。。。。。。。。。。。。。。。。。。。。。。。。。。","categories":[{"name":"大题小做","slug":"大题小做","permalink":"http://example.com/categories/%E5%A4%A7%E9%A2%98%E5%B0%8F%E5%81%9A/"}],"tags":[{"name":"题目","slug":"题目","permalink":"http://example.com/tags/%E9%A2%98%E7%9B%AE/"}]},{"title":"IO字符流","slug":"IO二","date":"2021-08-06T08:30:16.000Z","updated":"2021-08-06T08:35:04.589Z","comments":true,"path":"2021/08/06/IO二/","link":"","permalink":"http://example.com/2021/08/06/IO%E4%BA%8C/","excerpt":"","text":"字符流java.io.Reader[C] - 顶级的字符输入流 - 抽象类 BufferedReader[C] - 带缓冲功能的字符流 123public BufferedReader(Reader in) &#123; this(in, defaultCharBufferSize);&#125; FileReader[C] - 字符流中的节点流 - 具备真正的字符文件的读写操作的. 实例12345678910111213141516171819202122232425262728public class ReaderHelloDemo &#123; public static void main(String[] args) &#123; //1. 确定流 //2. 确定源头 //3. 循环读取 //4. 关闭流 - 可以采取语法糖 - JVM去自行关闭 //demo - 用来读取文本文件，然后将内容输出到控制台上去 try(BufferedReader in = new BufferedReader(new FileReader(&quot;src/stu/aistar/day13/Book.java&quot;)))&#123; //一行一行进行读取 String line = null; //循环读取 while (true)&#123; line = in.readLine(); //读取一整行的数据，若读取不到，则返回false //循环退出条件 if (line == null) break; System.out.println(line); &#125; &#125; catch (FileNotFoundException e) &#123; e.printStackTrace(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125;&#125; 字符输出流java.io.Writer[C] - 顶级的字符输出流 - 抽象类 PrintWriter[C] - 自带缓存功能 1234567PrintWriter(Writer out);//第二个参数是是否自动刷新缓存//缓存里面的数据什么时候会被同步到磁盘上//1. 缓存中的数据满的时候 - 会自动刷新//2. 缓存中的数据还不足以撑满这个缓存 - close或者flush - 强制刷新缓存PrintWriter(Writer out, boolean autoFlush); FileWriter[C] -字符流中的节点流 - 具备真正的字符文件的读写操作的. 123456构造方法:1. FileWriter(String path);//写到哪里去,目标的绝对/相对路径//第二个参数代表的是是否追加写入.如果append设置成true.支持分批次的写//和分批次的读 - 都是字符串2. FileWriter(String path,boolean append); 实例12345678910111213141516171819202122232425262728293031323334353637383940public class WriterHelloDemo &#123; public static void main(String[] args) &#123; test02(); &#125; private static void test02() &#123; //1. 构建一个不自动刷新,但是能够实现追加写入的功能. //第一个true - 代表的是是否追加写入 - true//第二个true - 是否自动刷新缓存,设置成true之后,那么就不需要在程序代码中手动刷新,不需要再去写out.flush();//推荐 - 1. 构建一个自动刷新的输出流 2. 程序代码的之后还是推荐手动刷新out.flush()3. 依然需要关闭流 - jvm try(PrintWriter out = new PrintWriter(new FileWriter(&quot;src/stu/aistar/day13/write.txt&quot;,true),true)) &#123; //out.write(&quot;刚才还好玩呢，现在一点叽霸意思都没有！&quot;); out.println(&quot;不能再好玩了！&quot;); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; private static void test01() &#123; //1. 构建的是一个不自动刷新，不追加写入的字符输出流 //每次都会覆盖原来的文件，并且在第一次写入的时候，会自动创建这个文件的 try(PrintWriter out = new PrintWriter(new FileWriter(&quot;src/stu/aistar/day13/write.txt&quot;)))&#123; //因为语法糖 - close()操作 - 底层就是关闭流之前，会强制舒心缓存 //有可能有部分学生的计算机，他没有达到强制刷新缓存的效果 //场景 - 内存中的数据不能写入到磁盘上的这文件中的[文件中的内容是空的] //print方法以及println方法 //print方法写入之后，后面是没有加一个\\n //println方法写入之后，后面是有一个\\n //把内存中的数据持久化到磁盘中的文件中、 out.print(&quot;真他吗的好玩！&quot;); //推荐在结束的时候，手动刷新一下缓存 out.flush(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125;&#125; 文件的拷贝123456789101112131415161718192021222324252627282930313233public class FileCopyReaderDemo &#123; public static void main(String[] args) &#123; copyFile(&quot;src/stu/aistar/day13/FileDemo.java&quot;,&quot;src/stu/aistar/day13/FileDemo001.java&quot;); &#125; private static void copyFile(String src, String target) &#123; //1. 构建流 - 源头和目标的确定 try(BufferedReader in = new BufferedReader(new FileReader(src)); PrintWriter out = new PrintWriter(new FileWriter(target))) &#123; //2. 定义一个变量 - 用来保存每次读取到的一行的数据 String line = null; //3. 循环读取 while (true)&#123; line = in.readLine(); //循环退出条件 if (line == null) break; //写一行出去 out.println(line); &#125; System.out.println(&quot;文件拷贝完毕！&quot;); &#125; catch (FileNotFoundException e) &#123; e.printStackTrace(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125;&#125; 总结笔试 常见的字节流和字符流 装饰器的设计模式 难一点的知识点 - 同步[打电话]IO/异步[发短信]IO区别,阻塞IO/非阻塞IO区别 BufferedInputStream - 内置的缓冲数组 - 8kb","categories":[{"name":"IO流","slug":"IO流","permalink":"http://example.com/categories/IO%E6%B5%81/"}],"tags":[{"name":"java","slug":"java","permalink":"http://example.com/tags/java/"}]},{"title":"IO字节流","slug":"IO一","date":"2021-08-05T12:29:47.000Z","updated":"2021-08-06T09:58:25.105Z","comments":true,"path":"2021/08/05/IO一/","link":"","permalink":"http://example.com/2021/08/05/IO%E4%B8%80/","excerpt":"","text":"File java.io.File[C] - File包含文件或者文件夹[目录directory] 作用:它是用来操作File本身的元信息的[比如支持File的创建,删除,获取File的名称,获取File的路径等信息] 它并不支持文件里面的内容的读写操作[文件内中的内容的读写操作是交给IO流去实现] 支持本地File以及远程File的操作的. File对象 - Java程序将磁盘上的文件加载内存中然后映射到File对象上 - File是内存中的磁盘上的映射. 构造方法 File(String path);//利用一个路径来构建一个File实例.这个路径可以是文件的路径,也可以是文件夹的路径 路径分成相对路径和绝对路径. 绝对路径 - windows操作系统是以盘符号开头的路径,Linux/mac以/开头的路径 相对路径 - 不是以盘符或者/开头的路径 常用方法 boolean createNewFile();//创建一个文件,该方法是要抓取异常的. String getAbsolutePath();//获取该File的绝对路径 String getName();//获取File的名称 String getParent();//获取该File的父目录的绝对路径 boolean exists();//判断File是否存在 boolean delete();//删除文件或者文件夹 6-1. 文件是否可以直接被删除的 6-2. 如果是空目录 - 直接删除的 6-2. 如果是非空目录 - 将会删除失败 - 递归算法来实现的. boolean mkdir();//创建单层次的目录,一次只能创建一个目录 boolean mkdirs();//既可以创建单层次的目录,又可以同时创建多个不存在的目录. boolean isFile();//判断File实例是否为文件的实例 boolean isDirectory();//判断file实例是否为文件夹的实例 String[] list();//返回的是File的名称,返回的是传入的路径下的第一层的内容. File[] listFiles();//返回的第一层的File实例 File[] listFiles(FilenameFilter filter);//找到指定后缀/前缀/满足条件的这么一个File实例 练习 传入一个目录,输出这个目录下的所有的内容. 123456789101112131415161718192021222324public class Test &#123; public static void main(String[] args) &#123; findAllFile(&quot;C:/Users/ASUS/Desktop/img&quot;); &#125; private static void findAllFile(String path) &#123; File file = new File(path); if (!file.exists())&#123; System.out.println(file + &quot;不存在,请给我一个正确的目录好吗？&quot;); &#125; File[] files =file.listFiles(); for (File f : files) &#123; if (f.isFile())&#123; //如果是文件 - 直接输出名称 System.out.println(f.getName()); &#125;else if (f.isDirectory())&#123; //如果是文件夹 - 输出绝对路径 System.out.println(f.getAbsoluteFile()); //findAllFile(f.getAbsolutePath()); &#125; &#125; &#125;&#125; 练习②删除一个非空目录 12345678910111213141516171819202122//删除一个非空目录(现阶段只会删除里面的文件，文件夹不会删除)public class Test001 &#123; public static void main(String[] args) &#123; String path = &quot;C:\\\\Users\\\\ASUS\\\\Desktop\\\\one&quot;; delNoEmptyDirectory(path); &#125; private static void delNoEmptyDirectory(String path) &#123; File file =new File(path); File[] files = file.listFiles(); for (File f : files) &#123; if (f.isFile())&#123; f.delete(); &#125;else if (f.isDirectory())&#123; String nextPath = f.getAbsolutePath(); delNoEmptyDirectory(nextPath); &#125; &#125; &#125;&#125; IO流 流是一种抽象概念，它代表了数据的无结构化传递。按照流的方式[数据在传输之前,需要进行转换,转换成无结构的字节/字符序列]进行有序的输入输出，数据被当成无结构的字节序或字符序列。从流中取得数据的操作称为提取操作，而向流中添加数据的操作称为插入操作。用来进行输入输出操作的流就称为IO流。换句话说，IO流就是以流的方式进行输入(Input)输出(Output) 流想象成是数据传输的那个管道 磁盘中数据加载/读入到内存中 - 输入 java内存中数据写出去到磁盘中 - 输出 流的分类 按照流的方向 - 输入流和输出流 按照流的读取的单位不同 - 字节流[按照单个字节单个字节进行读写,文本文件或者二进制文件]和字符流[单个字符进行读写,只能操作文本字符文件] 按照流的功能 - 节点流[基础流]和拓展流[过滤流或者包装流] - 采用了”装饰器设计模式思想” **节点流才具备真正操作文件的能力.**拓展流只是让流的功能更加强大而已,拓展流脱离了节点流的话,那么是不允许的. 拓展流的使用必须要建立在节点流的基础之上. 字节流字节输入流 java.io.InputStream[C] - 字节输入流的顶级的抽象的父类 java.io.FileInputStream[C] - 文件字节输入流 - 操作文件的读操作. - 典型的节点流 java.io.ObjectInputStream[C] - 操作对象类型的字节输入流 - 典型的包装流 java.io.FilterInputStream[C] - 过滤流 java.io.BufferedInputStream[C] - 带缓存功能的流 - 缓冲流 java.io.DataInputStream[C] - 操作基本数据类型的字节输入流 字节输出流 java.io.OutputStream[C] - 字节输出流的顶级的抽象的父类 java.io.FileOutputStream[C] - 文件字节输出流 - 操作文件的写操作. - 典型的节点流 java.io.ObjectOutputStream[C] - 操作对象类型的字节输出流 - 典型的包装流 java.io.FilterOutputStream[C] - 过滤流 java.io.BufferedOutputStream[C] - 带缓存功能的流 - 缓冲流 java.io.DataOutputStream[C] - 操作基本数据类型的字节输出流 InputStream常用方法 void close();//关闭流,流本身就是一个对象[占内存 - 昂贵的资源] abstract int read();//单个字节单个字节的读取,如果读不到,返回-1 int read(byte[] b);//从输入流读取一些字节数，并将它们存储到缓冲区 b 。 OutputStream常用方法 void close();//关闭 abstract void write(int b);将指定的字节写入此输出流。 void write(byte[] b, int off, int len); IO流的编程步骤 确定流 - 选什么流 确定源头和目标 循环读取,循环写出 - while 关闭流 缓冲流BufferedInputStream 在它出来之前,可以可以单个字节单个字节进行读写操作 - 弊端:java程序和磁盘的IO交互比较频繁,性能就会低下. 采取了自定义的数组的方式.从磁盘文件中读取一定数量的字节先放入到缓冲数组中.然后再从缓冲数组中一次性写出到磁盘中. 减少了java程序和磁盘的IO交互 - 性能提高. JDK中发现了这点,提供了缓冲流BufferedInputStream 123456789101112131415private static int DEFAULT_BUFFER_SIZE = 8192;//默认的容量8kbprotected volatile byte buf[];//内置的缓冲区public BufferedInputStream(InputStream in) &#123;this(in, DEFAULT_BUFFER_SIZE);&#125;public BufferedInputStream(InputStream in, int size) &#123;super(in);if (size &lt;= 0) &#123; throw new IllegalArgumentException(&quot;Buffer size &lt;= 0&quot;);&#125;buf = new byte[size];//初始化内置的缓冲区数组 - 大小是8kb&#125; 底层利用了”装饰器”思想.这个流属于包装流,拓展流,过滤流,本身不具备真正的文件的读写能力. 构建带缓冲功能的流,必须要以节点流作为支撑 构架一个带缓冲功能的能够读取文件的字节输入流 BufferedInputStream in = new BufferedInputStream(new FileInputStream(“路径”)); BufferedOutputStream out = new BufferedOutputStream(new FileOutputStream(“路径”)); 缓冲数组 BufferedInputStream本身已经在底层定义了8kb的字节数组,那么为什么程序中还自定义了一个3kb的字节数组[可以不定义,read()方法],自定义的byte[]和内置的byte[]各自的作用是什么? 内置的8kb的byte[] - 在一开始或者后面空闲的时候,由JVM去装载磁盘上的数据,提前放入到这个内置的byte[]中的. 123456789101112131415161718192021222324252627282930313233343536/** * 本类用来演示: 缓冲流 */public class BufferDemo &#123; public static void main(String[] args) &#123; BufferedInputStream in = null; BufferedOutputStream out = null; try &#123; //jvm加载磁盘上的数据到内置的byte[]中 in = new BufferedInputStream(new FileInputStream(&quot;src/sth/aistar/day13/fast.gif&quot;)); out = new BufferedOutputStream(new FileOutputStream(&quot;src/stu/aistar/day13/fast_副本.gif&quot;)); //自定义一个byte[] //真正的读 byte[] buf = new byte[3*1024]; int len = -1; while(true)&#123; len = in.read(buf); if(len==-1) break; out.write(buf,0,len); &#125; System.out.println(&quot;文件拷贝成功!&quot;); &#125; catch (FileNotFoundException e) &#123; e.printStackTrace(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125;&#125; 读过程 当初始化好缓冲流之后,jvm会立即读取磁盘中的数据到内置的缓冲数组中 当程序中循环读取到的时候 len = in.read(buf); = 程序是直接从内置的缓冲区[内置的缓冲数组中] 一旦内置的数组中的8kb数据被取完,那么jvm在空闲的时候,继续加载文件中下一个8kb的字节到内置的缓冲区. 语法糖 jdk7.0提供的写法 作用 - 把流的关闭交给JVM 12345try(资源对象的声明1;资源对象的声明2)&#123;&#125;catch(..)&#123;...&#125; 1234567891011121314151617181920212223242526272829/** * 本类用来演示: 语法糖 - JVM去关闭流 */@SuppressWarnings(&quot;all&quot;)public class StreamAutoCloseDemo &#123; public static void main(String[] args) &#123; //自动关闭这些资源 try(BufferedInputStream in = new BufferedInputStream(new FileInputStream(&quot;src/stu/aistar/day13/fast.gif&quot;)); BufferedOutputStream out = new BufferedOutputStream(new FileOutputStream(&quot;src/stu/aistar/day13/fasts.gif&quot;)))&#123; //自定义一个byte[] byte[] buf = new byte[3*1024]; int len = -1; while(true)&#123; len = in.read(buf); if(len==-1) break; out.write(buf,0,len); &#125; System.out.println(&quot;文件拷贝成功!&quot;); &#125; catch (FileNotFoundException e) &#123; e.printStackTrace(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125;&#125; ObjectInputStream/ObjectOutputStream 操作对象类型的字节输入流和字节输出流,拓展流,必须要以节点流作为支撑 构建一个能够读写对象类型的文件字节输入流/输出流 1ObjectInputStream in = new ObjectInputStream(new FileInputStream(&quot;path&quot;)) 构建一个能够读写对象类型的并且带缓冲功能的文件字节输入流 1ObjectInputStream in = new ObjectInputStream(new BufferedInputStream(new FileInputStream(&quot;path&quot;))); 利用”装饰器”思想,我们构建出功能更加强大的流,但是又不会对原来的流的结构产生任何影响. 对象的序列化 也叫做 - 数据的持久化的过程. - 把内存中的java对象存储到磁盘的文件的过程. 注意点: 如果保存的是单个对象,这个对象的实体类必须要实现java.io.Serializable序列化接口 如果没有实现这个接口,进行序列化的时候,抛出一个java.io.NotSerializableException不可被序列化的异常 保存的是数组/集合,那么集合中的每个对象对应的实体类也是需要实现这个序列化的接口 关于追加写入,设置FileOutputStream(String path,boolean append);//append设置true,但是不支持分批次读取. 对象的反序列化 java对象已经存储到磁盘的文件中,希望再从文件中将这些对象数据加载到内存中[映射到java对象上].","categories":[{"name":"IO流","slug":"IO流","permalink":"http://example.com/categories/IO%E6%B5%81/"}],"tags":[{"name":"java","slug":"java","permalink":"http://example.com/tags/java/"}]},{"title":"异常和日期格式处理","slug":"Exception","date":"2021-08-04T13:50:45.000Z","updated":"2021-08-05T12:22:11.685Z","comments":true,"path":"2021/08/04/Exception/","link":"","permalink":"http://example.com/2021/08/04/Exception/","excerpt":"","text":"SimpleDateFormat java.text.SimpleDateFormat - 日期格式处理类 线程不安全的类. 目标 Date类型转换成String类型 - 按照指定的日期格式. 1234//pattern必须是一个有效的格式化模板,如果传入了一个非法模板//那么就会抛出一个java.lang.IllegalArgumentException - 非法参数异常// Illegal pattern character &#x27;q&#x27;String format(Date date); String类型转换成Date类型. 1234//如果构造中的pattern的格式和日期的字符串的格式不一致,那么在调用//parse方法的时候就会抛出java.text.ParseException: Unparseable date: &quot;2020-09-03&quot;//解析失败异常Date parse(String str); 模板pattern Letter Date or Time Component Presentation Examples G Era designator Text AD y Year Year 1996; 96 Y Week year Year 2009; 09 M Month in year (context sensitive) Month July; Jul; 07 L Month in year (standalone form) Month July; Jul; 07 w Week in year Number 27 W Week in month Number 2 D Day in year Number 189 d Day in month Number 10 F Day of week in month Number 2 E Day name in week Text Tuesday; Tue u Day number of week (1 = Monday, …, 7 = Sunday) Number 1 a Am/pm marker Text PM H Hour in day (0-23) Number 0 k Hour in day (1-24) Number 24 K Hour in am/pm (0-11) Number 0 h Hour in am/pm (1-12) Number 12 m Minute in hour Number 30 s Second in minute Number 55 S Millisecond Number 978 z Time zone General time zone Pacific Standard Time; PST; GMT-08:00 Z Time zone RFC 822 time zone -0800 X Time zone ISO 8601 time zone -08; -0800; -08:00 日期工具类 java.util.Date BigDecimal api: java.math 构造方法 BigDecimal(double val) BigDecimal(String val);//处理小数精度的问题 常用方法 BigDecimal add(BigDecimal augend)返回 BigDecimal ，其值是 (this + augend) ，其标为 max(this.scale(), augend.scale()) 。 BigDecimal divide(BigDecimal divisor) 除法 BigDecimal multiply(BigDecimal multiplicand) 乘法 BigDecimal subtract(BigDecimal subtrahend) 减法 笔试题 在java开发中如何处理小数精度丢失的问题 需要使用到的是BigDecimal(String val); 123456789101112131415161718192021222324package tech.aistar.day12;import java.math.BigDecimal;/** * 本类用来演示: 处理小数 * * @author: success * @date: 2021/8/4 9:27 上午 */public class BigDecimalHandlerFloatDemo &#123; public static void main(String[] args) &#123; BigDecimal d1 = new BigDecimal(&quot;0.1&quot;); BigDecimal d2 = new BigDecimal(String.valueOf(0.2)); BigDecimal result = d1.add(d2); //BigDecimal-&gt;double/String double resultDouble = result.doubleValue(); System.out.println(resultDouble); System.out.println(result); &#125;&#125; BigInteger 笔试题 - 递归算法求阶乘 构造:BigInteger(String val); 12345678910111213public class BigIntegerDemo &#123; public static void main(String[] args) &#123; System.out.println(test(6)); &#125; public static BigInteger test(int n)&#123; if(n==1) return BigInteger.ONE; BigInteger current = new BigInteger(String.valueOf(n)); return current.multiply(test(n-1)); &#125;&#125; 四种内部类 看懂别人写的内部类语法即可 成员内部类 - 把内部类看成是外部类的一个成员 a. 成员内部类不能再去定义静态成员 b. 成员内部类中可以通过Outer.this.非静态属性名来访问外部类的非静态属性 1外部类.内部类 对象名 = 外部类对象.new 内部类(); 静态内部类- 把内部类看成是外部类的一个静态成员 1外部类.内部类 对象名 = new 外部类.内部类(); a. 内部是可以定义静态和非静态属性的 b. 内部的普通方法中是不允许访问外部类的非静态属性的. c. 内部的普通方法中是允许访问外部类的静态属性的 局部内部类 - 内部类是出现在外部类的方法中. a. 内部类是不允许使用访问修饰符,比如不能使用public b. 不能定义静态属性的 c. 访问到外部类的静态和非静态成员的 d. 生命只在所在的方法中,方法外部是没有办法拿到这个对象的(不能直接在外部new) 匿名内部类 - 必须掌握的 好处 - 我们可以在程序中少写实现类 jdk8.x中如果遇到函数式接口.推荐使用lambda表达式来替代匿名内部类的写法的. 装饰器模式 IO流使用到了”装饰器”设计模式思想 装饰器模式（Decorator Pattern）允许向一个现有的对象添加新的功能，同时又不改变其结构。这种类型的设计模式属于结构型模式，它是作为现有的类的一个包装。 UML Unified Modeling Language- 统一建模语言 BA - 需求分析师 powerndesigner starUML 掌握目标: 看懂箭头即可 类与类之间由弱到强关系是: *没关系 &gt;** **依赖 &gt; 关联 &gt; 聚合 &gt; 组合。* 依赖 虚线+箭头&lt;—— 可以简单的理解，就是一个类A使用到了另一个类B，而这种使用关系是具有偶然性的、、临时性的、非常弱的 123456789101112131415public class A&#123;public void test(B b)&#123; //自己的功能 //B类中的功能 b.test();&#125;&#125;public class B&#123;&#125; 关联 箭头 实线+箭头&lt;- A类关联了B类 - A依赖于B 1234567public class A&#123;private B b;&#125;public class B&#123;&#125; 组合关系 属于关联的一种 - 强调的是整体和局部的关系,这种关系非常紧密.整体是可以决定局部的生命周期的. 箭头 - 实线+实心菱形 123456789101112131415161718192021222324package tech.aistar.uml.combination;/** * 本类用来演示:属于关联的一种 - 强调的是整体和局部的关系,这种关系非常紧密. * 整体是可以决定局部的生命周期的. * * @author: success * @date: 2021/8/4 10:34 上午 */public class Baby &#123; private Eye eye; private Hand hand; public Baby()&#123; this.eye = new Eye(); this.hand = new Hand(); &#125; public static void main(String[] args) &#123; Baby b = new Baby(); &#125;&#125; 聚合关系 属于关联的一种 - 强调的是整体和局部的关系,这种关系较紧密.整体是可以不用决定局部的生命周期的 - 局部单独存在的 箭头 - 实线+空心菱形 1234567public class Computer &#123; private Cpu cpu; public Computer(Cpu cpu)&#123; this.cpu = cpu; &#125;&#125; Throwable java.lang.Throwable - 异常和错误的顶级的类 两个分支: java.lang.Error - 错误 - 错误一旦发生,程序员是么有办法进行扭转的 - 不需要在代码中进行处理. 1-1. 子类VirtualMachineError虚拟机级别的错误 ​ 1-1-1. 子类java.lang.StackOverflowError 堆栈溢出 - 应用程序因为递归太深没有指定出口的时候. ​ 1-1-2. 子类java.lang.OutOfMemoryError 内存泄漏 - [GC垃圾回收机制 - 后台自动回收垃圾对象] java.lang.Exception - 异常 - 程序在运行的过程中发生了不正常的情况. 异常的分类 运行时异常[RuntimeException]都是非运行时异常的子类[Exception] 运行时异常 - 未检测异常 顶级的父类java.lang.RuntimeException java.lang.NullPointerException - 空指针异常 java.util.InputMismatchException - 输入不匹配异常 12Scanner sc = new Scanner(System.in);int n = sc.nextInt();//只能获取整数.但是输入了一个字符串&quot;abc&quot; java.lang.ArithmeticException - 分母为0 java.lang.IllegalArgumentException - 非法参数异常 12SimpleDateFormat sdf = new SimpleDateFormat(&quot;yyyy-MM-dd&quot;);构造中的模板如果传入了一个非法模板 java.lang.IndexOutOfBoundsException - 下标越界异常 - 比如list.get(100); 5-1. java.lang.StringIndexOutOfBoundsException - 字符串下标越界异常 5-2. java.lang.ArrayIndexOutOfBoundsException - 数组下标越界异常 java.util.NoSuchElementException - 不存在此元素 12LinkedList&lt;Character&gt; list = new LinkedList&lt;&gt;();System.out.println(list.getFirst());//获取栈顶元素,但是栈顶没有元素 java.lang.ClassCastException - 类型转换失败异常 1父类类型转换成子类类型之前,推荐先使用instanceof关键字进行类型的判断 非运行时异常 - 已检测异常 java.text.ParseException - 解析失败异常 - 字符串的模板和pattern不匹配 InterruptedException - 中断异常 - Thread.sleep(1000); java.lang.CloneNotSupportedException - 不允许被clone. 1当调用对象的clone方法,但是这个对象没有去实现java.lang.Cloneable接口 java.io.IOExcetion - IO流异常 4-1. java.io.EOFException - 已经读取到文件的末尾了. 4-2. java.io.FileNotFoundException - 文件找不到异常 java.sql.SQLException - SQL异常,比如程序中的sql语句要是写错了. 异常的处理方式 运行时异常不需要处理(也是可以处理的),只需要在编程的时候,注意一下验证/判断.稍微谨慎一点. 非运行时异常 - 编译期间就需要立即对其进行处理.处理的方式有俩种.一种是积极处理 - try..catch的方式 另外一种是消极处理. 积极处理方式 语法一 - try….catch….catch….finally 推荐使用到的 - 因为针对每种不同的异常进行单独的日志记录,单独的异常处理. 1234567891011try&#123; //code.. //code..&#125;catch(异常类型1 e1)&#123;&#125;catch(异常类型2 e2)&#123;&#125;finally&#123; //无论是否出现异常,都会执行&#125;注意:上方的异常类型不能是下方的异常类型的父类. 语法二 - jdk7.0提供的新的写法 123456try&#123; //code... //code...&#125;catch(异常类型1 | 异常类型2)&#123; //...&#125; 语法三 - 简单粗暴 12345try&#123; //....&#125;catch(异常总父类)&#123; //...&#125; 消极处理 比如在某个方法中某些代码出现了非运行时异常,那么在自己方法的内部”不着急”去积极处理.而是把这个异常抛出去了. 为了自己不处理,而是抛出去? - 因为这个方法有可能会被反复在其他地方调用 - 原则:谁调用,谁负责最终处理. 原则谨记 - 不要把异常抛给main方法,等同于把异常抛给jvm,等同于一旦出现异常,程序就会崩溃. 直接在方法的签名[声明]上使用throws关键字+异常类型1,异常类型2 在方法体中使用throw+异常对象 123456789101112public static void d(int n) throws FileNotFoundException &#123; if(n==0)&#123; //System.out.println(&quot;异常的描述....&quot;); //throw + 运行时异常对象,不需要在方法的签名上抛出异常 - 本身运行时异常就不需要处理呀! //throw new RuntimeException(&quot;发生异常了...&quot;); //throw + 非运行时异常 配合 必须要在方法的签名上throws+非运行时异常类型 throw new FileNotFoundException(&quot;文件不存在!&quot;); &#125; System.out.println(&quot;n:&quot;+n);&#125; 笔试题 - throws和throw有什么区别 笔试题11234567891011121314try&#123; //code... //code.. return;//结束整个方法&#125;catch(异常类型 e)&#123; &#125;catch(异常类型 e)&#123; &#125;finally&#123; //无论是否出现异常,都会执行&#125;假设try&#123;&#125;中没有任何异常发生,所有的code都会顺利执行.1. finally中的代码执行否? - 肯定会执行2. return语句是在finally块之前执行还是之后执行? - 之后 笔试题21234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253package tech.aistar.day12.exception;/** * 本类用来演示: 笔试题 * * @author: success * @date: 2021/8/4 3:23 下午 */public class FinallyDemo &#123; public static void main(String[] args) &#123; System.out.println(test());//1 System.out.println(change());//A&#123;age=200&#125; &#125; //finally中修改了基本数据类型 public static int test()&#123; int i = 0;//① //try可以直接和finally一起使用.... try&#123; //此处将i自增后的结果缓存起来了.并且这个缓存的结果就是作为最终返回出去的一个结果 - 对待基本数据类型. return ++i; &#125;finally &#123; ++i;//③ System.out.println(&quot;i:&quot;+i); &#125; &#125; //finally修改了对象类型的属性 public static A change()&#123; A a = new A(); try&#123; a.age = 100; //return是在finally之后执行 return a; &#125;finally &#123; //对待对象类型 - finally中的修改对象的属性值,是对return的结果是产生了影响的. a.age = 200; &#125; &#125;&#125;class A&#123; public int age = 18; @Override public String toString() &#123; final StringBuilder sb = new StringBuilder(&quot;A&#123;&quot;); sb.append(&quot;age=&quot;).append(age); sb.append(&#x27;&#125;&#x27;); return sb.toString(); &#125;&#125; 笔试题3 final和finally和finalize三者之间的区别? - 一点关系都没有 final a. 修饰的局部变量一旦赋值成功,不可改变 b. 修饰的属性一旦赋值成功,不可改变 c. 修饰的类不可被继承 d. 修饰的方法不可被重写 finally a. 一般是和try..catch搭配使用的.try块中无论是否出现异常,finally块中代码都会执行 b. finally块中一般写的是释放或者关闭资源的代码 finalize - Object类中提供的方法 a. 当GC想去回收一个垃圾对象之前,会去调用这个对象的finalize方法.是由JVM去调用. b. 该方法未必一定会被调用得到. 自定义异常 项目中其实是专门包exception - 专门自定义自己的异常[大量的] jdk内置的异常不够用,不符合实际的业务场景. 步骤 写一个异常类继承java.lang.Exception 提供父类的5个构造方法即可 思考为什么要自定义异常 123System.out.println(&quot;余额小于0&quot;);throw new BalanceLtZeroException(&quot;余额小于0!&quot;); 场景:有的时候访问某些网站的时候 - 跳转到一个友好的页面 - 显示比如服务器正在维护/升级… 我们应该提供一个异常处理器 - 会监控软件程序在整个项目运行的过程中发生的一切异常. 一旦它发现了某个地方产生了异常,那么它就会对这些异常进行一个日志记录,然后再让程序跳转到一个友好的界面. SpringMVC/SpringBoot - 异常处理器 - 只认识异常. 复习 重点围绕OO - 面向对象 三大特性 - 封装,继承,多态 抽象类和接口区别 四种访问修饰符的作用权限 方法的重载和方法的重写 单例 - 双重检测锁 简单工厂 static关键字的作用 - static练习 预习 泛型 IO流 - 大头 并发编程 - 多线程 - 大头中的大头 - 最难的最难的最难的 反射技术 - 看懂框架的源码[反射技术 + 设计模式] 动态代理 - [jdk动态代理 + cglib动态代理] 枚举类型","categories":[{"name":"异常处理","slug":"异常处理","permalink":"http://example.com/categories/%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/"}],"tags":[{"name":"java","slug":"java","permalink":"http://example.com/tags/java/"}]},{"title":"面向对象","slug":"FaceObject","date":"2021-08-01T12:38:32.000Z","updated":"2021-08-02T02:56:11.668Z","comments":true,"path":"2021/08/01/FaceObject/","link":"","permalink":"http://example.com/2021/08/01/FaceObject/","excerpt":"","text":"面向对象 java语言属于面向对象的语言 面向对象本身不是一门具体的技术,符合人类思维的思想. 宗旨:把一个复杂的大型的业务,利用面向对象的思想进行面向对象的分析, 接着面向对象的设计,最终进行面向对象的编程. 对象是数据在内存中的”载体” 重新认识类和对象 类是抽象的概念,对象是具体的概念 类是构建对象的蓝图/模板,对象是类的具体的实例化[表现] 类是用来描述对象的. 比如: 类:水果 交通工具 学生 对象:榴莲 飞机 小三 比如: id username age 100 jack 18 101 tom 17 面向对象的思想核心:”一切皆对象” ①分析出系统中业务的关键对象 - “找对象” - 未来页面上显示的数据 ②找出对象的**”属性”** - “对象拥有什么” ③分析出对象的”方法” - “对象可以干什么,对象的功能” ④找出对象与对象之间的关系. 12345671:1 - 一个丈夫对应一个妻子,一个妻子对应一个丈夫.1:N - 一个客户拥有多个订单.一个订单只能属于一个客户 - 70%N:N - 一个学生可以选择多门课程,一门课程可以被多个学生来选择.自关联 - 自己关联自己. ⑤最后一步才会去考虑具体怎么编码实现.可能也会考虑数据结构或者算法. “相亲业务” - 媒婆帮你找一个”对象” 你要查看”对象”的属性 询问”对象”的功能 分析你和”对象”是否来道🌩 考虑 - 追 - 彩礼 - 结婚 - 具体怎么实现! 面向过程的思想 C是典型的面向过程的思想 ①优先考虑的就是算法和数据结构 - 考虑的就是具体怎么实现. 实体类 实体类就是用来描述对象的. 实体类中包含属性,构造方法,getter/setter方法,toString方法. 如何定义属性 语法: 修饰符 数据类型 属性名 [=初始值]; 修饰符 public 公开的 private 私有的 数据类型 八种基本数据类型 内置对象类型以及自定义对象类型. 属性名 参考变量的命名 - “小驼峰” 三大特征 - 封装性封装 - Encapsulation - 屏蔽底层的细节,数据提供保护的机制 属性私有化 提供getter/setter方法 setter方法 - set属性名[首字母变大写] - 推荐的命名规则 setter方法这种设置值的好处 2-1. setter方法中是可以进行参数有效性判断的. 2-2. 业务需求改变了 - 属性名称改变了,使用到这个属性的具体的地方都要发生改变 - “可维护性” 2-3. 并不是所有的属性的值都是通过那么太简单的计算得到的. 123456789101112131415161718192021222324public class Orders&#123; private int id; private double price; private int count; private double total; //getter/setter - 提供好了 public double getTotal()&#123; double result = this.price * this.count; return result; &#125;&#125;Orders o = new Orders();o.setPrice(100.0);o.setCount(10);//o.setTotal(o.getPrice()*o.getCount());System.out.println(o.getTotal()); ​ 2-4. 并不是所有的属性都需要对外进行公开的. this关键字 作用1 - 当前对象,区分方法中参数和实体类中的定义的属性 - 当两者同名的时候. 调用当前实体类中已经存在的另外一个构造方法. 2-1. this()调动空参 2-2. this(参数1,参数2) - 带参构造 2-3. this调用构造的语句一定要在构造体的首行 this和super语句的区别 toString方法 当我们直接输出对象的时候,默认一定会去调用toString方法 - 如果这个对象是null,那么不会调用toString方法的 当自定义的实体类中没有手动提供toString方法,那么这个对象会自动去调用java.lang.Object类中的toString方法 123public String toString() &#123; return getClass().getName() + &quot;@&quot; + Integer.toHexString(hashCode());&#125; java.lang.Object - 它是所有的类的根类,基类,超类,父类. 如果某个类没有明确指定它的父类,那么这个类默认会直接继承java.lang.Object类 “User类是Object类的儿子” - 规定 - “子类可以调用父类中所有的公开的成员“ Object类中提供的toString方法只能用来返回对象的内存地址 - 不满足实际的打印需求 所以需要在实体类中重新重写这个toString方法. 当子类User类一旦重写了toString方法之后,那么就会采取”就近原则”,直接调用自己重写 之后的toString方法. 构造方法-constructor作用:创建对象的时候调用构造方法,通过new关键字 可以在创建对象的同时进行赋值操作,赋值的方式只有1次,setter赋值,可以多次赋值 特点 当实体类中如果没有手动提供任何一个构造方法的时候,那么系统会自动分配一个 空参构造.如果实体类中一旦手动提供了带参构造之后,那么系统将不会再分配一个空参构造了. 定义的时候,不需要返回类型的 123public 类名([参数列表])&#123; //构造体&#125; 构造允许重载的 实体类中推荐只用提供空参,全参 业务类和实体类合二为一居然将业务方法放在了实体类中 - 违背了设计原则 - “单一职责原则”.不要给一个类增加太多的负担 实体类 - 主要是描述对象,数据在内存中的载体 - 注重的应该是数据的存储 业务类 - 存放的是业务方法 - 在于操作这些数据 员工类[编号id,姓名name,工资salary] 业务方法[crud增删改查]放在实体类中 - 【不合理的】 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990public class Emp&#123; private int id;private String name;private double salary;//一个上司拥有多个下属//一个下属对应一个上司//自关联private Emp[] emps;public Emp() &#123;&#125;public Emp(int id, String name, double salary, Emp[] emps) &#123;this.id = id;this.name = name;this.salary = salary;this.emps = emps;&#125;public int getId() &#123;return id;&#125;public void setId(int id) &#123;this.id = id;&#125;public String getName() &#123;return name;&#125;public void setName(String name) &#123;this.name = name;&#125;public double getSalary() &#123;return salary;&#125;public void setSalary(double salary) &#123;this.salary = salary;&#125;public Emp[] getEmps() &#123;return emps;&#125;public void setEmps(Emp[] emps) &#123;this.emps = emps;&#125;//给上司添加一个下属public void addEmp(Emp e)&#123;if (null!=emps)&#123;this.emps = Arrays.copyOf(emps,emps.length+1);emps[emps.length-1] = e;&#125;else &#123;System.out.println(&quot;你是一个员工，你没有资格添加！&quot;);&#125;&#125;//输出下属的个数public void printEmpCount()&#123;if (null==emps)&#123; System.out.println(&quot;你是一个员工,怎么会有下属呢？你这不是扯蛋吗...&quot;);&#125;else &#123; System.out.println(&quot;您下属的个数为：&quot; + emps.length);&#125;&#125;//输出某个上司所有的下属信息public void printEmp()&#123;System.out.println(&quot;您下属的信息如下：&quot;);if(null!=emps &amp;&amp; emps.length&gt;0)&#123; System.out.println(&quot;下属信息如下: &quot;); for (Emp emp : emps) &#123; System.out.println(&quot;\\t&quot;+emp); &#125;&#125;else&#123; System.out.println(&quot;\\tsorry你是一个小员工,没有资格!&quot;);&#125;&#125;&#125;//TestEmp.javaEmp boss = new Emp(1,&quot;boss&quot;,100.0,new Emp[0]);Emp e1 = new Emp(1,&quot;boss&quot;,100.0,null); 业务类和实体类分开业务方法应该专门抽取出来放到一个【业务类】中. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758public class Emp &#123;private int id;private String name;private double salary;private Emp[] emps;public Emp() &#123;&#125;public Emp(int id, String name, double salary, Emp[] emps) &#123; this.id = id; this.name = name; this.salary = salary; this.emps = emps;&#125;public int getId() &#123; return id;&#125;public void setId(int id) &#123; this.id = id;&#125;public String getName() &#123; return name;&#125;public void setName(String name) &#123; this.name = name;&#125;public double getSalary() &#123; return salary;&#125;public void setSalary(double salary) &#123; this.salary = salary;&#125;public Emp[] getEmps() &#123; return emps;&#125;public void setEmps(Emp[] emps) &#123; this.emps = emps;&#125;@Overridepublic String toString() &#123; return &quot;Emp&#123;&quot; + &quot;id=&quot; + id + &quot;, name=&#x27;&quot; + name + &#x27;\\&#x27;&#x27; + &quot;, salary=&quot; + salary + &quot;, emps=&quot; + Arrays.toString(emps) + &#x27;&#125;&#x27;;&#125;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445public class EmpBiz &#123;//将新的员工添加到boos的下属数组中public void addEmp(Emp boos,Emp e)&#123; Emp[] emps = boos.getEmps(); if (null!=emps)&#123; emps = Arrays.copyOf(emps,emps.length+1);//扩容 emps[emps.length-1] = e; &#125;else &#123; System.out.println(&quot;你没有资格！&quot;); &#125; boos.setEmps(emps); // 值 : 地址&#125;public void printEmp(Emp boos)&#123; Emp[] emps =boos.getEmps(); if (emps!=null &amp;&amp; emps.length&gt;0)&#123; System.out.println(&quot;您的下属信息如下：&quot;); for (Emp emp : emps) &#123; System.out.println(emp); &#125; &#125;else &#123; System.out.println(&quot;您是什么勾八，自己是一个员工，心里没点逼数吗？&quot;); &#125;&#125;//删除工资高于salarypublic void delBySalary(Emp boss,double salary)&#123; Emp[] emps = boss.getEmps(); int count = 0; for (int i = 0; i &lt; emps.length; i++) &#123; //统计薪资大于salary的数量 if (emps[i].getSalary() &gt; salary)&#123; count++; &#125; &#125; Emp[] temp = new Emp[emps.length-count]; int index = 0; for (int i = 0; i &lt; emps.length; i++) &#123; if (emps[i].getSalary() &lt; salary)&#123; temp[index++] = emps[i]; &#125; &#125; boss.setEmps(temp);&#125;&#125; 继承Inheritance 将多个具有共同特点的对象抽象出一个”父类”. 父类中存储的是各个子类共同的特点[属性]或者功能[方法] 继承的好处 - 提高了代码的复用性.使用多态的前提,为了代码的可拓展性. 继承的缺点 - 增加了类与类之间的关系.不太符合软件的设计原则”高内聚,低耦合” ——————低耦合 - 模块与模块之间/类与类之间的关系应该越弱越好 - 没有关系 ——————高内聚 - 单个模块/类能够独立完成某个业务功能的能力比较强. ——————实际开发中,可以采用设计原则**”合成复用原则”** - 来替代继承的使用. 使用extends关键字来表示某个类继承某个父类 比如: 1234567891011121314public class A&#123;&#125;public class B extends A&#123;&#125;B 是 A的子类,A是B的父类,基类,超类.1. A的父类就是java.lang.Object - 当某个类如果没有明确指定它的父类是谁,那么这个类默认继承Object2. 子类是可以访问到父类中所有的非私有的成员3. java的类只支持单继承.一个类【只能继承一个父类】.避免出现网状结构,保证类的层次性. java中的接口是支持多重继承.一个【接口可以继承多个接口】.4. 继承具有传播性.C extends B B extends A C间接继承于A,C也是可以访问到A中的所有的非私有的成员5. 不要滥用继承,前提B is A super关键字【必须只能放在构造方法的首行】 语法规则：一个构造方法第一行如果没有this(…);也没有显示的去调用super(…); ​ 系统会默认调用super(); 调用父类的构造 在子类的构造中,如果没有出现任何的super语句.那么系统默认会给定super(); - 【调用父类的空参构造】 当在子类中调用了一个和父类中同名的成员的时候,需要通过super关键字来加以区分[强制调用父类中那个同名的成员] 123456789101112131415161718192021222324252627282930313233343536373839404142public class Animal &#123; private String desc; public Animal() &#123; System.out.println(&quot;====1====&quot;); this.desc = getDesc(); &#125; public String getDesc() &#123; System.out.println(&quot;扰乱你,压根不会执行!&quot;); return &quot;Animal&quot;; &#125; public String toString() &#123; return desc; &#125;&#125;public class Worf extends Animal &#123; private String name; private double weight; public Worf(String name, double weight) &#123; super(); System.out.println(&quot;===3===&quot;); this.name = name; this.weight = weight; &#125; public String getDesc() &#123; System.out.println(&quot;===2===&quot;); return &quot;Worf:&quot; + name + &quot;体重:&quot; + weight; &#125; public static void main(String[] args) &#123; System.out.println(new Worf(&quot;羊&quot;, 10)); &#125; //结果：Worf:null体重:0.0&#125; 12345678910111213141516171819202122232425262728293031323334353637public class Super &#123; int j = 10; public Super() &#123; System.out.println(&quot;===1==&quot;); print(); j = 20; &#125; public void print() &#123; System.out.println(&quot;没有关系&quot;); System.out.println(j); &#125;&#125;public class Sub extends Super &#123; //子类的属性赋值时机等到父类走完！！！ int j = 30; public Sub() &#123; super(); System.out.println(j); System.out.println(&quot;===3===&quot;); print(); j = 40; &#125; //子类重写了父类中的print方法,所以不会去调用父类 public void print() &#123; System.out.println(&quot;===2==4===&quot;); System.out.println(j); &#125; public static void main(String[] args) &#123; System.out.println(new Sub().j); &#125; //结果：0 30 30 40&#125; 多态 - polymorphism对象有多种形态.发生前提是具有继承关系 相同的消息可能会送给多个不同的类别之对象， 而系统可依据对象所属类别，引发对应类别的方法，而有不同的行为。简单来说，所谓多态意指相同的消息给予不同的对象会引发不同的动作。 instanceof进行类型的判断,只有为true的时候,才能够进行类型的转换[强制,向下] 如果没有进行类型的判断,随便进行了一个强制类型转换,可能会抛出java.lang.ClassCastException类型转换失败异常 三种场景应用面向父类编程 对象的编译时类型写成父类,对象的运行时类型写成子类 编译时类型 对象名 = new 运行时类型(); 对象的编译时类型决定了对象的访问能力 - “对象名只能访问到编译时类型中定义的成员” 对象的运行时类型决定了对象的行为能力 - “子类中如果一旦重写了父类中的方法,那么运行期间调用的是子类重写之后的方法” 方法的参数类型写成父类,调用这个方法的时候,可以传入这个父类的任意一个子类对象 方法的返回类型写成父类,方法的返回结果可以是这个父类的任意一个子类对象 - “简单工厂设计模式” final关键字 不可更改,不可变 final修饰的变量/属性 - 不能够重新赋值 final修饰的类 - 不能够被继承 final修饰的方法不能够被重写. 修饰符 访问修饰符 - 决定了这个成员可以在哪里能够被访问. 所有包 子类[可以不同,同包] 同包 本类 public 公共的,公开的 √ √ √ √ protected 受保护的 × √ √ √ 默认的 × × √ √ private 私有的 × × × √ 安全级别:private&gt;默认的&gt;protected&gt;public 可见区域:public&gt;protected&gt;默认的&gt;private 方法的重写 方法的重载和方法的重写有什么区别? 特点: 发生的前提是要有继承关系 重写有个特殊的场景 - 子类重写之后的方法的修饰符,返回类型,方法名,参数列表和父类中高度保持一致 - 重构 子类重写的方法的访问修饰符可以小于或者等于父类 方法名必须要一样. 子类重写的方法的返回类型可以小于[可以是父类方法的返回类型的子类类型]或者等于父类的那个方法 参数列表必须要高度保持一致","categories":[{"name":"java基础语法","slug":"java基础语法","permalink":"http://example.com/categories/java%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/"}],"tags":[{"name":"java","slug":"java","permalink":"http://example.com/tags/java/"}]},{"title":"Abstract+Interface","slug":"Abstract-Interface","date":"2021-08-01T12:28:16.000Z","updated":"2021-08-01T12:33:26.644Z","comments":true,"path":"2021/08/01/Abstract-Interface/","link":"","permalink":"http://example.com/2021/08/01/Abstract-Interface/","excerpt":"","text":"抽象类 抽象类天生就是用来被子类继承的.抽象类天生就是不能够被外部进行实例化的 抽象类使用abstract关键字来进行修饰 抽象类中允许存在构造方法,普通属性,普通方法以及抽象方法. 【普通类是没有资格去定义抽象方法】 【抽象方法】也是使用abstract来修饰的,抽象方法是指【没有方法体】的方法. 【抽象的方法】天生也是用来被子类【重写】的. 抽象类是一种【抽象的数据类型】. 抽象类的继承的特点 如果某个普通的子类继承了抽象类,那么这个子类必须要重写这个抽象父类中的所有的抽象方法. 如果某个子类继承了抽象类,不想重写抽象父类中的所有的抽象方法,那么需要将这个子类也定义成抽象类. 不能一起混用的修饰符 final和abstract一起使用 final修饰的类无法被继承，而抽象类必须被继承使用；final修饰的方法是不允许被子类覆盖的，而抽象方法必须被子类覆盖。 private和abstract能不能一起修饰方法. private修饰的方法是该类私有的方法，不能被子类继承，所以不能被子类覆盖，这与抽象方法必须被子类覆盖矛盾。 static和abstract不能一起用来修饰方法 static静态方法是不存在多态的。 static修饰的方法叫静态方法，该方法依赖于类，随着类的加载而加载，就算没有new一个对象，类方法还是存在，所以静态方法可以用 “类名.方法” 的形式直接调用，但是抽象方法是还未被定义的方法，抽象方法必须被子类覆盖来定义，所以抽象方法随着类加载并没有意义。 接口 属于【抽象的数据类型】,也是不能够被实例化的 接口中不允许定义普通属性的,不允许出现构造的. jdk8.x允许在接口中使用default关键字来定义普通方法. 接口也是用来定义抽象的方法的.接口中的方法都是抽象的方法. 接口的属性都是公开的静态的常量属性. 定义接口的关键字是interface,编译之后也是【.class字节码】文件 接口也是可以静态方法的. 命名规则 使用I开头或者able结尾 多态的另外应用 面向接口编程 ！！！！！！！！！！！！！！！！！！！！！ 对象的编译时类型写成接口,对象的运行时类型写成是实现类 方法的参数类型写成接口,调用方法时可以传入这个接口的任意一个实现类. 方法的返回类型写成接口,方法的返回结果的类型可以是这个接口的任意一个实现类. 接口的规则 接口和类 - 类是可以去实现这个接口的. 接口天生是用来是实现类来实现的 - implements 普通的类去实现某个接口的话,那么必须要实现这个接口中所有的抽象方法 如果抽象的类去实现某个接口的话,那么可以选择实现或者不实现. 一个接口可以拥有多个实现类. 一个类可以同时实现多个接口,接口之间用逗号隔开.需要实现这些接口中所有的抽象方法. 接口和接口 一个接口可以继承多个接口,接口是支持多重继承的. 应用 提供了一种”契约机制”,屏蔽了底层的具体的实现,为了程序的拓展 作用 - 制定开发的这个软件中的功能 - “业务方法” 接口的分类 业务接口 - 该接口中只定义抽象方法 常量接口 - 该接口中只定义了常量属性,管理系统中所有的常量属性的.jdk5.x使用了枚举类型来替代了常量接口 标记接口 - 什么都没有,做标记的. 123456public interface IA&#123;&#125;public class Aimpl implements IA&#123;...&#125;Aimpl a = new Aimpl();System.out.println(a instanceof IA); //true 函数式接口 - jdk8.x - 配合jdk8.x - lambda表达式 里面只有一个抽象方法的接口 - @FunctionalInterface 1234567891011121314151617181920212223@FunctionalInterfacepublic interface Funable &#123; //里面只有一个抽象方法的接口 String add(int a,String b);&#125;Funable funable =new Funable() &#123; //匿名内部类 @Override public String add(int a, String b) &#123; return a+b; &#125;&#125;;//函数式接口的方法只有一个参数 &#123;&#125;以及return关键字都是可以省略 //Funable f = a -&gt; a*10; //Funable f = (a) -&gt; &#123; //return a*10; //&#125;;//lambdaFunable funable = (a,b)-&gt;&#123; return a+b;&#125;;","categories":[{"name":"抽象的数据类型","slug":"抽象的数据类型","permalink":"http://example.com/categories/%E6%8A%BD%E8%B1%A1%E7%9A%84%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"}],"tags":[{"name":"java","slug":"java","permalink":"http://example.com/tags/java/"}]},{"title":"Date + Calendar","slug":"Date-Calendar","date":"2021-08-01T12:27:51.000Z","updated":"2021-08-02T02:38:09.271Z","comments":true,"path":"2021/08/01/Date-Calendar/","link":"","permalink":"http://example.com/2021/08/01/Date-Calendar/","excerpt":"","text":"Dateapi:java.util.Date[C] - 使用这个类之前,必须要导包import - (一般都会自己导包) 这是java中提供的关于日期的处理,内置的对象类型.它本身是一个【过时】的类 里面提供了很多已经过时的方法. 目标:【掌握】这个类中提供的方法 api手册构造方法作用:创建这个类的对象的方式 观察提供的方法是静态的方法还是非静态的方法. - api手册方法摘要 Date类中提供的方法几乎都是【非静态】的方法 - 考虑如何构建这个对象? 如何构建对象 - api手册的构造方法[面向对象] 简单理解构造方法 - “方法”,构造方法通过new关键字调用 Date();//Date d = new Date();//获取当前系统时间 Date(int year, int month, int date);//已经过时的 123Date d2 = new Date(2021-1900,6,21);//year - 1900 =&gt; 实际的year//month的范围是[0,11] Date(long date);//根据一个毫秒数来构建一个指定的日期类型 - 重新设置一个新的Date Java中日期类型Date对象是【不支持运算】的. 1234//计算三天之后的此时此刻 此刻的时间加上三天时间的毫秒数 重新构造时间long afterThreeTime = new Date().getTime()+3L*24*60*60*1000;Date afterThreeDate = new Date(afterThreeTime);System.out.println(afterThreeDate); 常用方法非静态方法 - 日期对象进行调用. long getTime();//返回当前日期的毫秒数的表现形式 - 获取当前系统时间的毫秒数 - 距离1970年1月1日 1970年是计算机的元年 get/set方法 - 过时的 void setYear(int year);// 获得的year是减过1900的，如果你想要得到年份需要加1900 void setMonth(int month);//month的范围[0,11] void setDate(int date);//设置今天是几号 void setHours(int hours);//设置小时 void setMinutes(int minutes);//设置分钟 void setSeconds(int seconds);//设置秒 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556import java.util.Date;/** * 本类用来演示: java.util.Date 日期处理类 */public class DateDemo &#123; public static void main(String[] args) &#123; //1. 创建一个日期对象 Date d = new Date(); //空参构造方法 System.out.println(d); //(获得的是系统当前时间) //为什么此处输出的不是内存地址??? - OO - toString(); //2. 重载的构造方法 - 过时的构造 Date d2 = new Date(2021-1900,6,21); System.out.println(d2);//2021.7.21 //3. 利用毫秒数来构建一个Date对象 Date d3 = new Date(1626829161216L); System.out.println(d3);//根据1970年计算 System.out.println(&quot;====常用方法===&quot;); //4.. 获取当前日期的毫秒数 //1秒 = 1000毫秒 long nowTime = d.getTime(); System.out.println(nowTime);//1626828910303 //练习-计算三天之后的此时此刻 long afterThreeTime = new Date().getTime()+3L*24*60*60*1000; Date afterThreeDate = new Date(afterThreeTime); System.out.println(afterThreeDate); System.out.println(&quot;=====set设置/get获取======&quot;); Date now = new Date(); now.setYear(2021-1900);//设置年份 now.setMonth(6);//设置月份[0,11] now.setDate(25); System.out.println(&quot;now:&quot;+now); int year = now.getYear()+1900; //获取年份 System.out.println(&quot;year:&quot;+year); System.out.println(&quot;month:&quot;+now.getMonth());//获取月份 System.out.println(&quot;date:&quot;+now.getDate()); //获取几号 System.out.println(&quot;day:&quot;+now.getDay()); //周几,周1-周6[1-6],周日是0 System.out.println(&quot;hours:&quot;+now.getHours()); //void setTime(long date); //构造 Date(long time); Date dd = new Date(); dd.setTime(1726830007794L); System.out.println(dd); &#125; Calendarapi - java.util.Calendar 123public abstract class Calendarabstract //[修饰符]修饰的类是一个抽象类 - 不能够被new //即构建Calendar对象 - Calendar cal = new Calendar();//error api手册常用方法 static Calendar getInstance(); 12//获取当前系统的日历对象Calendar cal = Calendar.getInstance();//底层使用到了简单工厂的设计模式[不需要了解暂时] 关于设置日历字段 123456789void set(int year, int month, int date)//此时的year 不用减去1900 只有Date减//设置日历字段中的值 YEAR ， MONTH和 DAY_OF_MONTH 。void set(int year, int month, int date, int hourOfDay, int minute)//设置日历字段中的值 YEAR ， MONTH ， DAY_OF_MONTH ， HOUR_OF_DAY和 MINUTE 。void set(int year, int month, int date, int hourOfDay, int minute, int second)//设置字段中的值 YEAR ， MONTH ， DAY_OF_MONTH ， HOUR_OF_DAY ， MINUTE和 SECOND 。 12//Date -&gt; Calendar ！！！void setTime(Date date); 单独针对单个字段一一进行赋值 12345678910111213141516void set(int field,int value);//只要看到field//公开的静态的常量属性 - 接口中的变量public static final int YEAR = 1;//例如： Calendar cd = Calendar.getInstance(); //通过字面量直接进行设置 - 可读性比较差 //获取Calendar中提供的一些公共的静态的常量属性 //常量的好处 - 提供程序的可读性 cd.set(Calendar.YEAR,2021); cd.set(Calendar.MONTH,6); cd.set(Calendar.DAY_OF_MONTH,21); 关于获取日历字段 1234567891011121314//获取日历信息中关于日期部分的信息 - Calendar转成Date类型//Calendar内部提供的getTime方法-返回值是一个Date类型public final Date getTime();//获取日历指定字段的值public int get(int field); //设置日历指定字段的值public int set(int field); //获取周几int week = cd.get(Calendar.DAY_OF_WEEK);System.out.println(&quot;week:&quot;+(week-1)); //其实内部真正的对应是：周日~周六 [1,7]//-1的目的就是变成0是周日,其余的正好一一对应 ！ 总结 毫秒数 -&gt; Date 12//a. java.util.Date中提供了构造方法Date(long time);Date d = new Date(5611316516515L); //b. 上述类public void setTime(long time); Date dd = new Date(); //默认获取当前系统时间 System.out.println(dd); dd.setTime(1726830007794L); //重新设置时间 System.out.println(dd); Date -&gt; 毫秒数 12//Date类中提供的方法：getTimepublic long getTime(); Calendar -&gt; Date 1234//Calendar类中提供了public final Date getTime();Calendar cal = Calendar.getInstance(); //也是默认获取的是当前的系统时间//calendar -&gt; dateDate date = cal.getTime(); Date -&gt; Calendar 123//Calendar类中void setTime(Date date);Date date1 =new Date(1891800237347L);cal.setTime(date1); 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354import java.util.Calendar;import java.util.Date;/** * 本类用来演示: 日历类java.util.Calendar */public class CalendarDemo &#123; public static void main(String[] args) &#123; //abstract是修饰符 - 修饰类 - 抽象的类 //特点 - 不能够被new[不能够被实例化,具体化] //Calendar cal = new Calendar();//error Calendar cal = Calendar.getInstance(); //System.out.println(cal); //统一设置值 cal.set(2020,6,21); //2020.7.21 //Calendar -&gt; Date Date now = cal.getTime(); System.out.println(now); //Date -&gt; Calendar Date d = new Date(17818237347L); cal.setTime(d); System.out.println(cal.get(1)); System.out.println(&quot;====单个字段一一赋值====&quot;); //void set(int field,int value); Calendar cd = Calendar.getInstance(); //通过字面量直接进行设置 - 可读性比较差 //获取Calendar中提供的一些公开的静态的常量属性 //常量的好处 - 提供程序的可读性 cd.set(Calendar.YEAR,2021); cd.set(Calendar.MONTH,6); cd.set(Calendar.DAY_OF_MONTH,24); System.out.println(cd.getTime());//Calendar-&gt;Date int year = cd.get(Calendar.YEAR); int month = cd.get(Calendar.MONTH)+1; int day = cd.get(Calendar.DAY_OF_MONTH); System.out.println(&quot;year:&quot;+year); System.out.println(&quot;month:&quot;+month); System.out.println(&quot;day:&quot;+day); //获取周几 int week = cd.get(Calendar.DAY_OF_WEEK); System.out.println(&quot;week:&quot;+week);//周日~周六,[1~7] //根据自己的方法可week-1 那么0就是周日1-6就会一一对应 &#125;&#125; 获取键盘键盘输入 java.util.Scanner键盘类 如何构建这个Scanner对象 1Scanner sc = new Scanner(System.in); 方法 3-1. int nextInt();//只能获取整数 3-2. double nextDouble();//获取小数 3-3. String nextLine();//获取字符串 注意点:nextLine不要和nextInt或者nextDouble混用.","categories":[{"name":"日期日历","slug":"日期日历","permalink":"http://example.com/categories/%E6%97%A5%E6%9C%9F%E6%97%A5%E5%8E%86/"}],"tags":[{"name":"java","slug":"java","permalink":"http://example.com/tags/java/"}]},{"title":"模板方法","slug":"Template","date":"2021-08-01T12:18:46.000Z","updated":"2021-08-01T12:22:52.986Z","comments":true,"path":"2021/08/01/Template/","link":"","permalink":"http://example.com/2021/08/01/Template/","excerpt":"","text":"设计模式 - 模板方法 模板方法模式很常用，其目的是在一个方法中定义一个算法骨架，而将一些步骤延迟到子类中。模板方法使得子类可以在不改变算法结构的情况下，重新定义算法的某些步骤。在标准的模板方法模式实现中，主要是使用继承的方式，来让父类在运行期间可以调用到子类的方法。即：处理某个流程的代码已经都具备，但是其中某个节点的代码暂时不能确定。处理步骤在父类中定义好，具体实现延迟到子类中定义 。 抽象的类应用 - 模板方法设计模式. 模板类中只负责定义 需要做的事情 - 不需要具体的实现,具体的实现留给各个子类去实现. 做的事情的流程[步骤] 123456789101112131415public abstract class TemplateDemo &#123; //规定了需要完成的事情 public abstract void start();//演员登台 public abstract void play();//演员表演 public abstract void end();//落幕 //提供一个不可变的方法,用来控制事情执行的顺序 public final void execute()&#123; this.start(); this.play(); this.end(); &#125;&#125; 1234567891011121314151617public class YueYueImpl extends TemplateDemo &#123; @Override public void start() &#123; System.out.println(&quot;小岳岳登场...&quot;); &#125; @Override public void play() &#123; System.out.println(&quot;贱贱地笑话~~~&quot;); &#125; @Override public void end() &#123; System.out.println(&quot;小岳岳被轰走...&quot;); &#125;&#125; 123456public class TestTemplate &#123; public static void main(String[] args) &#123; TemplateDemo t1 = new YueYueImpl(); t1.execute(); &#125;&#125; 缺点模板方法的优点和缺点： 优点： 模板方法提供了一个很好的代码复用平台。 实现了反向控制，通过一个父类调用其子类的操作，通过对子类的具体实现扩展不同的行为，实现了反向控制，符合 “开闭原则”。 缺点： 每一个不同的实现都需要一个子类来实现，导致类的个数增加，使得系统更加庞大。","categories":[{"name":"设计模式","slug":"设计模式","permalink":"http://example.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"java","slug":"java","permalink":"http://example.com/tags/java/"}]},{"title":"小测试(灵活使用Date+Calendar)","slug":"Test02","date":"2021-08-01T12:18:26.000Z","updated":"2021-08-01T12:21:42.904Z","comments":true,"path":"2021/08/01/Test02/","link":"","permalink":"http://example.com/2021/08/01/Test02/","excerpt":"","text":"打印日历1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162import java.util.Calendar;import java.util.Scanner;/** * 本类用于演示：打印日历 */public class HomeWork &#123; public static void main(String[] args) &#123; Scanner scanner = new Scanner(System.in); System.out.print(&quot;请你输入一个年份：&gt;&quot;); int year = scanner.nextInt(); System.out.print(&quot;请你输入一个月份：&gt;&quot;); int month = scanner.nextInt(); System.out.println(&quot;\\t\\t\\t\\t&quot;+year+&quot;年,&quot;+month+&quot;月&quot;); System.out.println(&quot;日\\t一\\t二\\t三\\t四\\t五\\t六&quot;); if (month&lt;=0 || month&gt;12)&#123; System.out.println(&quot;你输入的月份不合法！&quot;); return; &#125; if (year&lt;0)&#123; System.out.println(&quot;sorry,year 不合法!&quot;); return; &#125; int maxDay = getMaxDay(year, month); Calendar calendar = Calendar.getInstance(); calendar.set(year,month-1,1); //设置当前你输入的信息 判断这个月的一号是星期几 int day = calendar.get(Calendar.DAY_OF_WEEK)-1; int num = calendar.get(Calendar.DAY_OF_MONTH); //今天是几号 int count = 0; //计数器 每七个就换一次行 for (int i = 0; i &lt; day; i++) &#123;//为了使一号对应星期几 System.out.print(&quot;\\t&quot;); //把一号推到对应的周期 count++; &#125; for (int i = 1; i &lt;= maxDay; i++) &#123; System.out.print(i==num?i+&quot;*\\t&quot;:i+&quot;\\t&quot;); count++; if (count%7==0)&#123; System.out.println(); count=0; &#125; &#125; &#125; public static int getMaxDay(int year,int month)&#123; //每个月的天数 int day = 0; if ( month==4 || month==6 || month==9 || month==11 )&#123; day = 30; &#125;else if (month == 2)&#123; day = isLeapYear(year)?28:29; &#125;else &#123; day = 31; &#125; return day; &#125; public static boolean isLeapYear(int year)&#123; //判断是否为闰年 return year%4==0 &amp;&amp; year%100!=0 || year%400 ==0; &#125;&#125;","categories":[{"name":"大题小做","slug":"大题小做","permalink":"http://example.com/categories/%E5%A4%A7%E9%A2%98%E5%B0%8F%E5%81%9A/"}],"tags":[{"name":"题目","slug":"题目","permalink":"http://example.com/tags/%E9%A2%98%E7%9B%AE/"}]},{"title":"简单工厂模式","slug":"SimpleFactory","date":"2021-08-01T10:36:57.000Z","updated":"2021-08-01T10:38:23.322Z","comments":true,"path":"2021/08/01/SimpleFactory/","link":"","permalink":"http://example.com/2021/08/01/SimpleFactory/","excerpt":"","text":"设计模式概述设计模式概念设计模式（Design Pattern）是一套被反复使用、多数人知晓的、经过分类的、代码设计经验的总结。 使用设计模式的目的：为了代码可重用性、让代码更容易被他人理解、保证代码可靠性。 设计模式使代码编写真正工程化；设计模式是软件工程的基石脉络，如同大厦的结构一样。 项目中合理地运用设计模式可以完美地解决很多问题，每种模式在现实中都有相应的原理来与之对应，每种模式都描述了一个在我们周围不断重复发生的问题，以及该问题的核心解决方案，这也是设计模式能被广泛应用的原因。 简单工厂模式(以下统称)简单工厂模式是属于创建型模式，但不属于23种GOF设计模式之一。简单工厂模式是由一个工厂对象决定创建出哪一种产品类的实例。简单工厂模式是工厂模式家族中最简单实用的模式，可以理解为是不同工厂模式的一个特殊实现。简单工厂一般分为：普通简单工厂、多方法简单工厂、静态方法简单工厂。 作用:把对象的创建和对象的使用分离 User user = new User();//对象的创建和对象使用没有分离 普通简单工厂 - 必须要脱手写出来的.12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364//接口public interface Sender &#123; void send();&#125;//实现类public class QQSender implements Sender &#123; @Override public void send() &#123; System.out.println(&quot;QQ...send...&quot;); &#125;&#125;public class WXSender implements Sender &#123; @Override public void send() &#123; System.out.println(&quot;WX...send...&quot;); &#125;&#125;//1. 根据传入的参数来返回某个具体的产品[对象]！！！！！！！！/** * 本类用来演示: 简单工厂 */public class ProductFactory &#123; public static final int QQ = 1; public static final int WX = 2; //根据传入的参数来返回某个具体的产品 //多态的应用 - 面向接口编程 //3. 方法的返回类型写成接口,方法的执行结果可以是这个接口的任意一个实现类. public static Sender getInstance(int type)&#123; Sender sender = null; switch (type)&#123; case 1: //对象的创建 - 复杂的过程... sender = new QQSender(); break; case 2: sender = new WXSender(); break; default: System.out.println(&quot;参数不合法&quot;); break; &#125; return sender; &#125;&#125;//测试类public class TestProductFactory &#123; public static void main(String[] args) &#123; //获取QQSender产品 - 使用这个产品 //作用：将对象的创建和使用进行了分离 ！！！！！！ //Sender qq = ProductFactory.getInstance(1); Sender qq = ProductFactory.getInstance(ProductFactory.QQ); qq.send(); Sender wx = ProductFactory.getInstance(ProductFactory.WX); wx.send(); &#125;&#125; 多方法简单工厂123456789101112131415161718192021222324252627282930313233343536373839404142//接口public interface Sender &#123; void send();&#125;//实现类public class QQSender implements Sender &#123; @Override public void send() &#123; System.out.println(&quot;QQ...send...&quot;); &#125;&#125;public class WXSender implements Sender &#123; @Override public void send() &#123; System.out.println(&quot;WX...send...&quot;); &#125;&#125;//多方法简单工厂public class ProductFactory &#123; //有几个产品，就定义几个方法 //每个方法负责生产一个产品 public Sender createQQ()&#123; return new QQSender(); &#125; public Sender createWX()&#123; return new WXSender(); &#125;&#125;//主方法测试public class TestProductFactory &#123; public static void main(String[] args) &#123; ProductFactory factory = new ProductFactory(); Sender qq = factory.createQQ(); qq.send(); Sender wx = factory.createWX(); wx.send(); &#125;&#125; 静态方法简单工厂12345678910111213141516/** * 本类用来演示: 多方法工厂 和上述方法一样，只是把方法定义为静态 */public class ProductFactory &#123; //有几个产品,就定义几个方法 //每个方法负责生成一个产品 public static Sender createQQ()&#123; return new QQSender(); &#125; public static Sender createWx()&#123; return new WXSender(); &#125;&#125; 简单工厂优缺点优点： 很明显，简单工厂的特点就是“简单粗暴”，通过一个含参的工厂方法，我们可以实例化任何产品类，上至飞机火箭，下至土豆面条，无所不能。所以简单工厂有一个别名：上帝类。 缺点： 任何”东西“的子类都可以被生产，负担太重。当所要生产产品种类非常多时，工厂方法的代码量可能会很庞大 在遵循开闭原则（对拓展开放，对修改关闭）的条件下，简单工厂对于增加新的产品，无能为力。因为增加新产品只能通过修改工厂方法来实现。","categories":[{"name":"设计模式","slug":"设计模式","permalink":"http://example.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"java","slug":"java","permalink":"http://example.com/tags/java/"}]},{"title":"面试经典题(二)","slug":"Interview2","date":"2021-07-31T12:56:48.000Z","updated":"2021-07-31T13:00:20.607Z","comments":true,"path":"2021/07/31/Interview2/","link":"","permalink":"http://example.com/2021/07/31/Interview2/","excerpt":"","text":"String,StringBuilder,StringBuffer三者的区别? - 查,补充完整 - 作业 三者之间都是使用final修饰的,都是不可被继承的,jdk处于安全角度考虑的 - 共同点 不同点 2-1. String它是不可变的字符串,线程安全的.比较耗系统资源和内存的.性能是三个当中最低的. 2-2. StringBuilder可变的字符串 - 线程不安全的,效率是最高的. 2-3. StringBuffer可变的字符串 - 线程安全的.效率低于StringBuilder,但是高于String String StringBuffer StringBuilder String的值是不可变的，这就导致每次对String的操作都会生成新的String对象，不仅效率低下，而且浪费大量优先的内存空间 StringBuffer是可变类，和线程安全的字符串操作类，任何对它指向的字符串的操作都不会产生新的对象。每个StringBuffer对象都有一定的缓冲区容量，当字符串大小没有超过容量时，不会分配新的容量，当字符串大小超过容量时，会自动增加容量 可变类，速度更快 不可变 可变 可变 线程安全 线程不安全 多线程操作字符串 单线程操作字符串 包装类型和基本数据类型以及String类型三者之间的相互转换问题. int-&gt;Integer 1231. java.lang.Integer的构造Integer(int n)2. jdk5.0提供的自动封箱Integer a = 10;3. java.lang.Integer提供的static Integer valueOf(int n); Integer -&gt; int 121. int intValue();//java.lang.Number提供的抽象方法,java.lang.Integer重写了该方法2. jdk5.0提供的自动解箱 int-&gt;String 11. java.lang.String提供的方法static String valueOf(int n); String-&gt;int 11. java.lang.Integer类static int parseInt(String s); String-&gt;Integer 121. java.lang.Integer的构造Integer(String n)2. java.lang.Integer的方法static String valueOf(String n); Integer-&gt;String 121. java.lang.Integer的String toString();2. java.lang.String中提供了static String valueOf(Object obj); int和Integer之间的区别 Integer是int的包装类；int是基本数据类型； Integer变量必须实例化后才能使用；int变量不需要； Integer实际是对象的引用，指向此new的Integer对象；int是直接存储数据值 ； Integer的默认值是null；int的默认值是0。 泛型不支持int，但是支持Integer int 存储在栈中，Integer 对象的引用存储在栈空间中，对象的数据存储在堆空间中。 == 和 equals的区别 == 基本类型使用,比较的就是基本类型的数值 equals 对象类型使用.如果某个类没有重写equals方法,那么调用的是java.lang.Object中的equals方法,这个时候仍然使用到的是==比较.如果重写了equals,就看equals提供的是哪些属性一致的时候,才返回true. 面试题 - Collection和Collections有什么区别? static void sort(List list, Comparator&lt;? super T&gt; c) 根据指定的比较器引起的顺序对指定的列表进行排序。 1Collections.sort(bookList,((o1, o2) -&gt; (int) (o2.getPrice()-o1.getPrice()))); static &lt;T extends Comparable&lt;? super T&gt;&gt; void sort(List list) ;//集合中的对象必须要实现java.lang.Comparable可比较接口 面试题HashMap 和 HashTable 区别 HashMap 是 HashTable 的轻量级实现，他们都完成了Map 接口，主要区别在于 HashMap 允许 null key 和 null value,由于非线程安全，效率上可能高于 Hashtable。主要区别如下: HashMap允许将 null 作为一个 entry 的 key 或者 value，而 Hashtable 不允许。 HashMap 把 Hashtable 的 contains 方法去掉了，改成 containsValue 和 containsKey。因为 contains 方法容易让人引起误解。 HashTable 继承自 Dictionary 类，而 HashMap 是 Java1.2 引进的 Map interface 的一个实现。 HashTable 的方法是 Synchronize 的，而 HashMap 不是，在多个线程访问 Hashtable 时，不需要自己为它的方法实现同步，而 HashMap 就必须为之提供外同步。 Hashtable 和 HashMap 采用的 hash/rehash 算法都大概一样，所以性能不会有很大的差异。 ArrayList和LinkedList区别 ArrayList是实现了基于动态数组的数据结构，LinkedList基于链表的数据结构。 对于随机访问get和set，ArrayList觉得优于LinkedList，因为LinkedList要移动指针。 对于新增和删除操作add和remove，LinedList比较占优势，因为ArrayList要移动数据 List和Set区别 两个接口都是继承自Collection，是常用来存放数据项的集合，主要区别如下： List和Set之间很重要的一个区别是是否允许重复元素的存在，在List中允许插入重复的元素，而在Set中不允许重复元素存在。 与元素先后存放顺序有关，List是有序集合，会保留元素插入时的顺序，Set是无序集合。 List可以通过下标来访问，而Set不能。 HashSet和HashMap区别 HashSet的底层是HashMap HashMap HashSet HashMap实现了Map接口 HashSet实现了Set接口 HashMap储存键值对 HashSet仅仅存储对象 使用put()方法将元素放入map中 使用add()方法将元素放入set中 HashMap中使用键对象来计算hashcode值 HashSet使用成员对象来计算hashcode值，对于两个对象来说hashcode可能相同，所以equals()方法用来判断对象的相等性，如果两个对象不同的话，那么返回false HashMap比较快，因为是使用唯一的键来获取对象 HashSet较HashMap来说比较慢 ArrayList和HashSet区别 1.HashSet 是不重复的 而且是无序的! ​ 唯一性保证. 重复对象equals方法返回为true ，重复对象hashCode方法返回相同的整数 ​ HashSet其实就是一个HashMap,只是你只能通过Set接口操作这个HashMap的key部分, 2.ArrayList是可重复的 有序的 ​ 特点：查询效率高，增删效率低 轻量级 线程不安全。 arraylist：在数据的插入和删除方面速度不佳，但是在随意提取方面较快 HashSet和TreeSet区别 一、HashSet HashSet内部的数据结构是哈希表，是线程不安全的。 HashSet当中，保证集合中元素是唯一的方法。 通过对象的hashCode和equals方法来完成对象唯一性的判断。 假如，对象的hashCode值是一样的，那么就要用equals方法进行比较。 假如，结果是true，那么就要视作相同元素，不存。 假如，结果是false，那么就视为不同元素，存储。 注意了，假如，元素要存储到HashCode当中，那么就一定要覆盖hashCode方法以及equals方法。 二、TreeSet TreeSet能够对Set集合当中的元素进行排序，是线程不安全的。 TreeSet当中，判断元素唯一性的方法是依据比较方法的返回结果是否为0，假如是0，那么是相同的元素，不存，假如不是0，那么就是不同的元素，存储。 TreeSet对元素进行排序的方式： 1、元素自身具备比较功能，也就是自然排序，需要实现Comparable接口，并覆盖其compareTo方法。 2、元素自身不具备比较功能，那么就要实现Comparator接口，并覆盖其compare方法。 除此之外，还要注意了，LinkedHashSet是一种有序的Set集合。 也就是其元素的存入和输出的顺序是相同的。 HashMap和TreeMap区别 HashMap的底层是Array，所以HashMap在添加，查找，删除等方法上面速度会非常快。而TreeMap的底层是一个Tree结构，所以速度会比较慢。 另外HashMap因为要保存一个Array，所以会造成空间的浪费，而TreeMap只保存要保持的节点，所以占用的空间比较小。 HashMap如果出现hash冲突的话，效率会变差，不过在java 8进行TreeNode转换之后，效率有很大的提升。 TreeMap在添加和删除节点的时候会进行重排序，会对性能有所影响。 ArrayList和Vector区别 Vector是线程安全的，ArrayList不是线程安全的。 ArrayList在底层数组不够用时在原来的基础上扩展0.5倍，Vector是扩展1倍。","categories":[{"name":"Interview","slug":"Interview","permalink":"http://example.com/categories/Interview/"}],"tags":[{"name":"Interview","slug":"Interview","permalink":"http://example.com/tags/Interview/"}]},{"title":"小测试(用集合-统计题)","slug":"Test01","date":"2021-07-31T11:25:20.000Z","updated":"2021-07-31T11:27:42.915Z","comments":true,"path":"2021/07/31/Test01/","link":"","permalink":"http://example.com/2021/07/31/Test01/","excerpt":"","text":"1. 写一个程序统计每个品牌花费的总费用 - 统计类题型2. 根据总费用降序排123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105/** * 本类用于演示：统计每个品牌所消费的总额 */public class TestPurchase &#123; public static void main(String[] args) &#123; Purchase p1 = new Purchase(&quot;宝洁&quot;,&quot;洗手粉&quot;,18.5); Purchase p2 = new Purchase(&quot;联合利华&quot;,&quot;肥皂&quot;,4.5); Purchase p3 = new Purchase(&quot;宝洁&quot;,&quot;牙膏&quot;,32.5); Purchase p4 = new Purchase(&quot;宝洁&quot;,&quot;毛巾&quot;,14.5); Purchase p5 = new Purchase(&quot;洁利&quot;,&quot;洗面奶&quot;,26.0); Purchase p6 = new Purchase(&quot;好迪&quot;,&quot;洗发水&quot;,27.5); Purchase p7 = new Purchase(&quot;多芬&quot;,&quot;沐浴露&quot;,38.5); Purchase p8 = new Purchase(&quot;宝洁&quot;,&quot;洗洁精&quot;,3.4); List&lt;Purchase&gt; list = new ArrayList&lt;&gt;(); list.add(p1); list.add(p2); list.add(p3); list.add(p4); list.add(p5); list.add(p6); list.add(p7); list.add(p8); // CalSingleBrandSumPrice(list); CalSingleBrandSumPrice1(list); &#125; private static void CalSingleBrandSumPrice1(List&lt;Purchase&gt; list) &#123; Map&lt;String,Double&gt; maps = new HashMap&lt;&gt;(); for (Purchase purchase : list) &#123; String brand = purchase.getBrand(); double price = purchase.getPrice(); if (maps.containsKey(brand))&#123; price += maps.get(brand); maps.put(brand,price); &#125;else &#123; maps.put(brand,price); &#125; &#125; List&lt;Map.Entry&lt;String, Double&gt;&gt; newList= new ArrayList&lt;&gt;(); Set&lt;Map.Entry&lt;String, Double&gt;&gt; entries = maps.entrySet(); Iterator&lt;Map.Entry&lt;String, Double&gt;&gt; it = entries.iterator(); while (it.hasNext())&#123; newList.add(it.next()); &#125; newList.sort((s1,s2)-&gt; (int) (s2.getValue()-s1.getValue())); newList.forEach(e-&gt; System.out.println(e)); &#125; //第二种方法 (老师的，是真特么麻烦··········) private static void CalSingleBrandSumPrice(List&lt;Purchase&gt; list) &#123; Map&lt;String,List&lt;Purchase&gt;&gt; maps = new HashMap&lt;&gt;(); for (Purchase purchase : list) &#123; //放进map集合 value是所有的该品牌 String brand = purchase.getBrand(); if (maps.containsKey(brand))&#123; List&lt;Purchase&gt; ls = maps.get(brand); ls.add(purchase); maps.put(brand,ls); //!!! &#125;else &#123; ArrayList&lt;Purchase&gt; newList = new ArrayList&lt;&gt;(); newList.add(purchase); maps.put(brand,newList); &#125; &#125; Map&lt;String,Double&gt; map = new HashMap&lt;&gt;(); //真正放key=brand,value=sumPrice Set&lt;String&gt; str = maps.keySet(); Iterator&lt;String&gt; it = str.iterator(); while (it.hasNext())&#123; String brand = it.next(); List&lt;Purchase&gt; countList = maps.get(brand); double total = 0; for (Purchase purchase : countList) &#123; total += purchase.getPrice(); &#125; map.put(brand,total); &#125; //只有list集合才能使用sort方法 List&lt;Map.Entry&lt;String, Double&gt;&gt; list1 = new ArrayList&lt;&gt;();//给List 排序 Set&lt;Map.Entry&lt;String, Double&gt;&gt; entries = map.entrySet(); Iterator&lt;Map.Entry&lt;String, Double&gt;&gt; iterator = entries.iterator(); while (iterator.hasNext()) &#123; list1.add(iterator.next()); &#125; list1.sort(new Comparator&lt;Map.Entry&lt;String, Double&gt;&gt;() &#123; @Override public int compare(Map.Entry&lt;String, Double&gt; o1, Map.Entry&lt;String, Double&gt; o2) &#123; return (int) (o2.getValue()-o1.getValue()); &#125; &#125;); list1.forEach(new Consumer&lt;Map.Entry&lt;String, Double&gt;&gt;() &#123; @Override public void accept(Map.Entry&lt;String, Double&gt; stringDoubleEntry) &#123; System.out.println(stringDoubleEntry); &#125; &#125;); &#125;&#125;","categories":[{"name":"大题小做","slug":"大题小做","permalink":"http://example.com/categories/%E5%A4%A7%E9%A2%98%E5%B0%8F%E5%81%9A/"}],"tags":[{"name":"题目","slug":"题目","permalink":"http://example.com/tags/%E9%A2%98%E7%9B%AE/"}]},{"title":"集合框架(二)","slug":"set-list-map2","date":"2021-07-31T08:30:19.000Z","updated":"2021-08-01T11:26:43.654Z","comments":true,"path":"2021/07/31/set-list-map2/","link":"","permalink":"http://example.com/2021/07/31/set-list-map2/","excerpt":"","text":"集合框架 就是内存中的”容器对象” - 存储数据的.开发中来替代数组的使用. 结构123456789101112131415api:java.util Collection[I] - List[I] - 有序可重复 - ArrayList[C] - LinkedList[C] - Vector[C] - Set[I] - 无序不可重复 - HashSet[C] - SortedSet[I] - TreeSet[C]Map[I] - HashMap[C] - key-value的形式存储数据的,针对key是无序不可重复. - Hashtable[C] - Properteis[C] - 属性文件在内存中的映射的对象 Collection[I] boolean add(E e);//向容器中添加一个元素 void clear();//清空容器 boolean contains(Object o);//判断容器中是否包含某个对象 boolean isEmpty();//如果集合中没有数据,集合大小为0,返回true Iterator iterator();// 获取集合对象的迭代器 boolean remove(Object obj);//删除集合容器中第一次出现的这个对象.只能删除1个 int size();//返回集合中的数据的个数 - 集合的大小 List[I] 特点 - 有序并且是可以重复的. E get(int index);//根据下标去取.集合下标边界[0,集合.size()-1] int indexOf(Object obj);//返回此列表中指定元素的第一次出现的索引，如果此列表不包含元素，则返回-1。 E remove(int index);//根据下标删除,并且返回刚刚删除的那个元素 Object[] toArray();//将集合转换成数组. ArrayList[C] 特点:有序可重复的,底层数据结构就是一个”动态增长”的数组. 优点:因为数组是一个有序的序列,所以它可以通过下标直接取值 - 查询效率高. 缺点:增删效率会低.因为涉及到下标的移动. 分析源码123456789101112131415161718192021222324252627282930 /** * 默认的初始的容量 */private static final int DEFAULT_CAPACITY = 10;/** * Shared empty array instance used for default sized empty instances. We * distinguish this from EMPTY_ELEMENTDATA to know how much to inflate when * first element is added. */private static final Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = &#123;&#125;;//就是真正的存储数据的数组transient Object[] elementData; /** * The size of the ArrayList (the number of elements it contains). * * @serial */private int size;//构造public ArrayList() &#123; //1. 初始化elementData,长度为0 //2. 是为了后面的ensureCapacityInternal方法中判断是否是第一次调用add方法 this.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA; //this.elementData = &#123;&#125;&#125; 剖析add方法 ArrayList扩容的原理 12345public boolean add(E e) &#123;ensureCapacityInternal(size + 1); // Increments modCount!!elementData[size++] = e;return true;&#125; 扩容方法 123456789private void ensureCapacityInternal(int minCapacity) &#123; //第一次进来1if (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123; //true//第一次minCapacity = 10minCapacity = Math.max(DEFAULT_CAPACITY, minCapacity);&#125;ensureExplicitCapacity(minCapacity);&#125; 继续ensureExplicitCapacity(minCapacity); 12345678private void ensureExplicitCapacity(int minCapacity) &#123;modCount++;// overflow-conscious code//第一次进来10-0&gt;0if (minCapacity - elementData.length &gt; 0)grow(minCapacity);&#125; grow(minCapacity) 123456789101112131415private void grow(int minCapacity) &#123;// 第一次//oldCapacity = 0//newCapacity = 0int oldCapacity = elementData.length;int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1); //1.5倍if (newCapacity - minCapacity &lt; 0)//第一次会进来newCapacity = minCapacity;//newCapacity = 10if (newCapacity - MAX_ARRAY_SIZE &gt; 0)newCapacity = hugeCapacity(minCapacity);// minCapacity is usually close to size, so this is a win://第一次执行add方法的时候,底层会给我们初始化了一个长度为10的Object[]数组elementData = Arrays.copyOf(elementData, newCapacity);&#125; 集合的遍历 直接输出 增强for循环 - 只读 123456789101112131415161718192021222324252627282930//只读的循环.如果在循环的过程中进行了remove操作 //抛出java.util.ConcurrentModificationException并发修改异常 //实际的底层,调用迭代器对象中的next方法 private class Itr implements Iterator&lt;E&gt; &#123; int cursor; // index of next element to return int lastRet = -1; // index of last element returned; -1 if no such int expectedModCount = modCount; public E next() &#123; checkForComodification(); //.... &#125; final void checkForComodification() &#123; //modCount是当初调用add方法,添加1个元素,modCount自增1个 if (modCount != expectedModCount) throw new ConcurrentModificationException(); &#125;&#125; 发现只要调用了remove方法 - modCount++ private void fastRemove(int index) &#123; modCount++; int numMoved = size - index - 1; if (numMoved &gt; 0) System.arraycopy(elementData, index+1, elementData, index, numMoved); elementData[--size] = null; // clear to let GC do its work&#125; 普通for 迭代器 因为不同的集合的底层的数据结构是不一样的.数据结构不一样,它的遍历方式不一样 为了访问/遍历不同数据结构的集合提供一种统一的遍历方式 1234567 //1. 获取集合的迭代器Iterator&lt;Long&gt; iter = list.iterator();//2. 调用hasNext方法while(iter.hasNext())&#123; //判断迭代器中是否仍有下一个元素可被迭代 Long p = iter.next(); //获取当前迭代的 System.out.println(p);&#125; jdk8提供的新的遍历方式 1234567891011121314list.forEach(new Consumer&lt;Long&gt;() &#123; //匿名内部类 @Override public void accept(Long aLong) &#123; System.out.println(aLong); &#125;&#125;); //lambda表达式来替代匿名内部类的写法//配合函数式接口[只能包含【一个】抽象方法]System.out.println(&quot;======lambda====&quot;);list.forEach(e -&gt; System.out.println(e)); System.out.println(&quot;========&quot;);list.forEach(System.out::println); LinkedList[C] 有序的序列,底层的数据结构双向链表,jdk6以及之前是双向循环链表 链表结构的特点:查询效率很低,每次都会从头节点开始遍历.但是增删效率高,只会涉及到相邻节点的移动. 适合解决栈列和队列的业务题型 - 贪吃蛇 栈列 - 先进后出 队列 - 先进先出 链表结构 相对于数组这种数据结构,需要占用更多的内存.每个节点除了保存具体的数据,还需要保存相邻节点的地址. 单向链表 head - 头节点 tail - 尾节点 element - 节点中真正的保存的数据 next - 下一个节点的地址 单向循环链表 尾节点的next又指向了头节点. 双向链表 - LinkedList底层数据结构 增加了一个pre - 保存的是上一个节点的地址. 双向循环链表 剖析源码1234567891011121314151617181920212223242526272829303132333435363738394041//Node代表的是链表的节点 private static class Node&lt;E&gt; &#123; E item;//真正的元素 Node&lt;E&gt; next; //下一个节点的地址 Node&lt;E&gt; prev; //上一个节点的地址 Node(Node&lt;E&gt; prev, E element, Node&lt;E&gt; next) &#123; this.item = element; this.next = next; this.prev = prev; &#125; &#125;//双向链表如何插入一个新的节点public boolean add(E e) &#123; linkLast(e); return true;&#125;void linkLast(E e) &#123; //第【一】次进入last最后一个节点Node - null final Node&lt;E&gt; l = last;//l = null //第二次进入 l = new Node&lt;&gt;(null,&quot;ok&quot;,null) //第【一】次进入 //newNode = new Node&lt;&gt;(null,&quot;ok&quot;,null) //第二次进入 //newNode = new Node&lt;&gt;(链表中原来的最后一个节点l, &quot;java&quot;, null); final Node&lt;E&gt; newNode = new Node&lt;&gt;(l, e, null); //新插入的节点肯定是作为最后一个节点 - 尾节点 last = newNode; if (l == null) //第【一】次进入,链表之前没有任何元素 first = newNode; //新的节点作为头节点 else l.next = newNode; //原来链表中的最后一个节点的next同时也指向新的节点 size++; modCount++;&#125; 查找源码 1234567891011121314151617181920212223 public E get(int index) &#123; checkElementIndex(index); return node(index).item; &#125;Node&lt;E&gt; node(int index) &#123; //index = 3 // 假设集合中有10个元素 = size = 10 //index&lt;5 - 链表的坐标 if (index &lt; (size &gt;&gt; 1)) &#123; Node&lt;E&gt; x = first;//确定头节点 for (int i = 0; i &lt; index; i++) x = x.next; //① - x第二个 ,i=0 //i=1 x第三个 //i=2 x第四个 return x; &#125; else &#123;//index&gt;=5 Node&lt;E&gt; x = last; for (int i = size - 1; i &gt; index; i--) x = x.prev; return x; &#125;&#125; 删除源码 12345678910111213141516171819202122232425262728293031 public E remove(int index) &#123; checkElementIndex(index); //找到index对应的Node对象,传入到了unlink方法中. return unlink(node(index)); &#125;E unlink(Node&lt;E&gt; x) &#123; // assert x != null; final E element = x.item; final Node&lt;E&gt; next = x.next; final Node&lt;E&gt; prev = x.prev; if (prev == null) &#123; //防止删除的是头节点 first = next; //需要删除的那个节点的下一个节点作为头节点了. &#125; else &#123; //删除的是中间节点 prev.next = next; //原来节点的上一个节点的next指向原来节点的下一个节点 x.prev = null; //优化,更快让GC会回收pre指针. &#125; if (next == null) &#123; //删除的是尾结点 last = prev; //原来节点的上一个节点作为尾节点 &#125; else &#123; //删除的是中间节点 next.prev = prev; //原来节点的下一个节点指向原来节点的上一个节点 x.next = null; &#125; x.item = null; size--; modCount++; return element;&#125; 练习-括号匹配 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950package stu.aistar.day11.homework;import java.util.LinkedList;import java.util.Scanner;/** * 本类用来演示: 括号匹配 */public class BracketsDemo &#123; public static void main(String[] args) &#123; Scanner sc = new Scanner(System.in); System.out.print(&quot;输入括号: &gt;&quot;); String line = sc.nextLine(); if(matches(line))&#123; //isEmpty() 返回true System.out.println(&quot;匹配&quot;); &#125;else&#123; System.out.println(&quot;不匹配&quot;); &#125; &#125; private static boolean matches(String line) &#123; //1. 将字符串转成字符数组 char[] arr = line.toCharArray(); //2. 新建一个LinkedList集合 LinkedList&lt;Character&gt; list = new LinkedList&lt;&gt;(); //3. 将数组中的第一个元素压入栈顶 list.push(arr[0]); //4. 从arr数组的第二个位置开始遍历 for (int i = 1; i &lt; arr.length; i++) &#123; //()[]&#123;&#125; Character c = arr[i]; //获取当前的arr[i] if(list.isEmpty())&#123; //为了避免在栈顶已经没有元素的情况下还去获取 list.push(c); //栈顶元素,非空判断 continue; &#125; Character top = list.getFirst(); //5. 先获取栈顶元素 //6. 栈顶元素和当前的arr[i]进行匹配 if(top.equals(&#x27;(&#x27;)&amp;&amp;c.equals(&#x27;)&#x27;) || top.equals(&#x27;&#123;&#x27;)&amp;&amp;c.equals(&#x27;&#125;&#x27;) || top.equals(&#x27;[&#x27;)&amp;&amp;c.equals(&#x27;]&#x27;))&#123; list.pop(); //弹出栈顶元素 &#125;else&#123; list.push(c); //继续将当前的arr[i]压入栈顶 &#125; &#125; return list.isEmpty(); &#125;&#125; Map[I]HashMap[C] 数据存储的形式是key-value,针对key是无序不可重复的. jdk8.x之前,底层的数据结构是桶数组+链表 jd8.0开始,底层的数据结构是桶数组+链表+红黑树 桶(哈希桶)数组 - 里面的元素放在数组的这个位置是通过一个哈希算法计算得到的. 图示 剖析put方法123456789101112131415161718192021222324public V put(K key, V value) &#123; return putVal(hash(key), key, value, false, true);&#125;//hash函数就是扰动函数//1. 尽可能减少哈希冲突static final int hash(Object key) &#123; int h; return (key == null) ? 0 : (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16);&#125;//map数据结构图示中每个节点static class Node&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; &#123; final int hash; final K key; V value; Node&lt;K,V&gt; next;//单向链表 Node(int hash, K key, V value, Node&lt;K,V&gt; next) &#123; this.hash = hash; this.key = key; this.value = value; this.next = next; &#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566transient Node&lt;K,V&gt;[] table;//默认值是null//hash(key)final V putVal(int hash, K key, V value, boolean onlyIfAbsent, boolean evict) &#123; //第一次进来 Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; int n, i; //第一次进来,第二次肯定不走 if ((tab = table) == null || (n = tab.length) == 0) //第一次肯定会进来 //1. 对tab进行一个初始化操作 //2. 得到初始化数组的长度,赋值给了n n = (tab = resize()).length;//n=16 //第一次肯定判断结果为null if ((p = tab[i = (n - 1) &amp; hash]) == null) //tab[i] = 新的节点 tab[i] = newNode(hash, key, value, null); else &#123; //哈希碰撞了,哈希冲突了. Node&lt;K,V&gt; e; K k; if (p.hash == hash &amp;&amp; ((k = p.key) == key || (key != null &amp;&amp; key.equals(k)))) //key值冲突了. //e = 数组中的旧的Node对象 e = p; //hash虽然碰撞了,但是key是不一样 else if (p instanceof TreeNode)//判断是否为红黑树结构 //当链表的节点&gt;8个,链表结构转成红黑树结构 //当红黑树节点&lt;6个,恢复成链表结构 e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(this, tab, hash, key, value); else &#123;//链表结构 for (int binCount = 0; ; ++binCount) &#123; //p代表的就是哈希碰撞位置的第一个Node对象 if ((e = p.next) == null) &#123;//新的节点挂载到链表的末尾 p.next = newNode(hash, key, value, null); if (binCount &gt;= TREEIFY_THRESHOLD - 1) // -1 for 1st treeifyBin(tab, hash); break; &#125; //新的节点可能和链表结构中的某个节点的key也是一样的 if (e.hash == hash &amp;&amp; ((k = e.key) == key || (key != null &amp;&amp; key.equals(k)))) break; //e肯定是不为null p = e; &#125; &#125; if (e != null) &#123; // existing mapping for key //把旧的节点的value赋值给了oldValue,put方法的返回结果 V oldValue = e.value; if (!onlyIfAbsent || oldValue == null) //新值覆盖旧值 e.value = value; afterNodeAccess(e); return oldValue; &#125; &#125; ++modCount; if (++size &gt; threshold) resize(); afterNodeInsertion(evict); return null;&#125; 扩容方法 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576final Node&lt;K,V&gt;[] resize() &#123; Node&lt;K,V&gt;[] oldTab = table; int oldCap = (oldTab == null) ? 0 : oldTab.length; int oldThr = threshold; int newCap, newThr = 0; if (oldCap &gt; 0) &#123; if (oldCap &gt;= MAXIMUM_CAPACITY) &#123; threshold = Integer.MAX_VALUE; return oldTab; &#125; else if ((newCap = oldCap &lt;&lt; 1) &lt; MAXIMUM_CAPACITY &amp;&amp; oldCap &gt;= DEFAULT_INITIAL_CAPACITY) newThr = oldThr &lt;&lt; 1; // double threshold &#125; else if (oldThr &gt; 0) // initial capacity was placed in threshold newCap = oldThr; else &#123; // zero initial threshold signifies using defaults //第一进来就会执行到此处 , 16 //扩容因子是0.75 newCap = DEFAULT_INITIAL_CAPACITY; newThr = (int)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY); &#125; if (newThr == 0) &#123; float ft = (float)newCap * loadFactor; newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (float)MAXIMUM_CAPACITY ? (int)ft : Integer.MAX_VALUE); &#125; threshold = newThr; //初始化一个长度为16的数组 @SuppressWarnings(&#123;&quot;rawtypes&quot;,&quot;unchecked&quot;&#125;) Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])new Node[newCap]; table = newTab; if (oldTab != null) &#123; for (int j = 0; j &lt; oldCap; ++j) &#123; Node&lt;K,V&gt; e; if ((e = oldTab[j]) != null) &#123; oldTab[j] = null; if (e.next == null) newTab[e.hash &amp; (newCap - 1)] = e; else if (e instanceof TreeNode) ((TreeNode&lt;K,V&gt;)e).split(this, newTab, j, oldCap); else &#123; // preserve order Node&lt;K,V&gt; loHead = null, loTail = null; Node&lt;K,V&gt; hiHead = null, hiTail = null; Node&lt;K,V&gt; next; do &#123; next = e.next; if ((e.hash &amp; oldCap) == 0) &#123; if (loTail == null) loHead = e; else loTail.next = e; loTail = e; &#125; else &#123; if (hiTail == null) hiHead = e; else hiTail.next = e; hiTail = e; &#125; &#125; while ((e = next) != null); if (loTail != null) &#123; loTail.next = null; newTab[j] = loHead; &#125; if (hiTail != null) &#123; hiTail.next = null; newTab[j + oldCap] = hiHead; &#125; &#125; &#125; &#125; &#125; return newTab; &#125; map集合的迭代方式123456789101112131415161718192021//第一种方式 - 将map集合中所有的key全部取出来放入到一个Set集合中.//set集合 - 无序不可重复,map集合的key也是无序不可重复.Set&lt;Integer&gt; sets = maps.keySet();//遍历set集合Iterator&lt;Integer&gt; iter = sets.iterator();while(iter.hasNext())&#123; Integer key = iter.next(); String value = maps.get(key); System.out.println(key+&quot;:&quot;+value);&#125;//第二种方式 - 将map集合中的每对key-value封装到了一个内置的Entry对象中//然后将每个entry对象放入到Set集合中Set&lt;Map.Entry&lt;Integer,String&gt;&gt; entries = maps.entrySet();Iterator&lt;Map.Entry&lt;Integer,String&gt;&gt; iter2 = entries.iterator();while(iter2.hasNext())&#123; Map.Entry&lt;Integer,String&gt; e = iter2.next(); Integer key = e.getKey(); String value = e.getValue(); System.out.println(key+&quot;-&gt;&quot;+value);&#125; Map作业123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475String str = &quot;python java python java mysql java mysql php&quot;; spilt(&quot;\\\\s&quot;)//统计 String[] arr = [&quot;python&quot;,&quot;java&quot;,&quot;python&quot;,&quot;java&quot;,&quot;php&quot;,&quot;python&quot;]; public static void main(String[] args) &#123; String[] arr = &#123;&quot;python&quot;,&quot;java&quot;,&quot;python&quot;,&quot;java&quot;,&quot;php&quot;,&quot;python&quot;&#125;; Map&lt;String,Integer&gt; maps = new HashMap&lt;&gt;(); for (int i = 0; i &lt; arr.length; i++) &#123; maps.put(arr[i],maps.get(arr[i])==null?1:maps.get(arr[i])+1); &#125; Set&lt;Map.Entry&lt;String, Integer&gt;&gt; entries = maps.entrySet(); //遍历 Iterator&lt;Map.Entry&lt;String, Integer&gt;&gt; it = entries.iterator(); while (it.hasNext())&#123; Map.Entry&lt;String, Integer&gt; e = it.next(); System.out.println(e.getKey()+&quot;:&quot;+e.getValue()); &#125;&#125;//统计 int[] arr = &#123;1,2,1,2,3,4,1,2,5,.....&#125;public class CalNumCount &#123; public static void main(String[] args) &#123; int[] arr = &#123;1,2,1,2,3,4,1,2,5,3,4,2,1,3&#125;; Map&lt;Integer,Integer&gt; maps = new HashMap&lt;&gt;(); for (int i = 0; i &lt; arr.length; i++) &#123; maps.put(arr[i],maps.get(arr[i])==null?1:maps.get(arr[i])+1); &#125; System.out.println(maps); &#125;&#125;//统计 String str = &quot;sfhdsfkdfdfjdfjdfdjfdsa&quot;;public class CountStrDemo &#123; public static void main(String[] args) &#123; String str = &quot;ahfdfjdkfjsdafsed&quot;; count(str); &#125; private static void count(String str) &#123; Map&lt;Character,Integer&gt; maps = new HashMap&lt;&gt;(); for (int i = 0; i &lt; str.length(); i++) &#123; //用增强for循环更方便 if (maps.containsKey(str.charAt(i)))&#123; Integer count = maps.get(str.charAt(i)); maps.put(str.charAt(i),count+1); &#125;else &#123; maps.put(str.charAt(i),1); &#125; &#125; //定义list集合 用来存放map中的数据，只有list集合有sort方法！ List&lt;Map.Entry&lt;Character,Integer&gt;&gt; list = new ArrayList&lt;&gt;(); Set&lt;Map.Entry&lt;Character, Integer&gt;&gt; entries = maps.entrySet(); Iterator&lt;Map.Entry&lt;Character, Integer&gt;&gt; it = entries.iterator(); while (it.hasNext())&#123; Map.Entry&lt;Character, Integer&gt; nt = it.next(); //把map里面的值 传给 list里面 list.add(nt); &#125; list.sort((o1,o2)-&gt;o2.getValue()-o1.getValue()); //遍历排好序的集合，完成了排序 for (Map.Entry&lt;Character, Integer&gt; characterIntegerEntry : list) &#123; System.out.println(characterIntegerEntry); &#125; &#125;&#125;//下面有一个分割的 map 和 list排序方法 一致//分割如下： String str = &quot;python java python java mysql java mysql php&quot;; String[] arr1 = str.split(&quot;\\\\s&quot;); // \\\\s 是空格 其他的符号就用 \\\\+符号 for (String s : arr1) &#123; System.out.print(s+&quot;\\t&quot;); &#125; 排序比较器接口Comparator jdk8.0开始,在List接口中已经定义了排序的方法 void sort(Comparator&lt;? super E&gt; c) ; 中 Comparator&lt;? super E&gt; c 就是排列的规则的意思，并且这个规则需要自己去定义。 分析:java.util.Comparator[I]函数式接口 - 允许使用lambda表达式 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162package stu.aistar.day11;import stu.aistar.day10.Book;import java.util.ArrayList;import java.util.Comparator;import java.util.List;/** * 本类用来演示: 集合排序 */public class ListSortDemo &#123; public static void main(String[] args) &#123; Book b1 = new Book(1,&quot;1001&quot;,&quot;java&quot;,100.0d); Book b2 = new Book(2,&quot;1002&quot;,&quot;java&quot;,200.0d); Book b3 = new Book(3,&quot;1003&quot;,&quot;java&quot;,200.0d); Book b4 = new Book(4,&quot;1004&quot;,&quot;python&quot;,300.0d); List&lt;Book&gt; bookList = new ArrayList&lt;&gt;(); bookList.add(b1); bookList.add(b2); bookList.add(b3); bookList.add(b4);// bookList.sort(new Comparator&lt;Book&gt;() &#123;// @Override// public int compare(Book o1, Book o2) &#123;// if(o1.getPrice()&gt;o2.getPrice())// return -1;// else if(o1.getPrice()&lt;o2.getPrice())// return 1;// return 0;// &#125;// &#125;); //根据价格降序排// bookList.sort((o1,o2)-&gt;&#123;// if(o1.getPrice()&gt;o2.getPrice())// return -1;// else if(o1.getPrice()&lt;o2.getPrice())// return 1;// return 0;// &#125;); //根据编号降序排 - String类型// bookList.sort((o1, o2) -&gt; o2.getIsbn().compareTo(o1.getIsbn())); //根据价格降序排,如果价格一样的话,按照编号继续降序排 bookList.sort((o1,o2)-&gt;&#123; if(o1.getPrice()&gt;o2.getPrice()) return -1; else if(o1.getPrice()&lt;o2.getPrice()) return 1; return o2.getIsbn().compareTo(o1.getIsbn()); &#125;); for (Book book : bookList) &#123; System.out.println(book); &#125; &#125;&#125; 可比较接口 排序的对象对应的实体类实现java.lang.Comparable接口 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263package stu.aistar.day11.compares;/** * 本类用来演示: 可比较接口 */ //implements Comparable&lt;Teacher&gt; 特别是里面的泛型需要自己定义public class Teacher implements Comparable&lt;Teacher&gt;&#123; private int id; private String name; private int age; public Teacher() &#123; &#125; public Teacher(int id, String name, int age) &#123; this.id = id; this.name = name; this.age = age; &#125; public int getId() &#123; return id; &#125; public void setId(int id) &#123; this.id = id; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125; @Override public String toString() &#123; final StringBuilder sb = new StringBuilder(&quot;Teacher&#123;&quot;); sb.append(&quot;id=&quot;).append(id); sb.append(&quot;, name=&#x27;&quot;).append(name).append(&#x27;\\&#x27;&#x27;); sb.append(&quot;, age=&quot;).append(age); sb.append(&#x27;&#125;&#x27;); return sb.toString(); &#125; @Override public int compareTo(Teacher o) &#123; //定制排序的规则 return o.age - this.age; &#125;&#125; 123456789101112131415161718192021222324252627282930313233package stu.aistar.day11.compares;import java.util.ArrayList;import java.util.Collections;import java.util.List;/** * 本类用来演示: 在类中实现可比较接口，调用的时候用Collections.sort方法 */public class TestTeacherSort &#123; public static void main(String[] args) &#123; Teacher t1 = new Teacher(1,&quot;tom&quot;,23); Teacher t2 = new Teacher(2,&quot;jack&quot;,25); Teacher t3 = new Teacher(3,&quot;james&quot;,18); Teacher t4 = new Teacher(4,&quot;rose&quot;,17); List&lt;Teacher&gt; list = new ArrayList&lt;&gt;(); list.add(t1); list.add(t2); list.add(t3); list.add(t4); //for (Teacher teacher : list) &#123; //为了查看排序之前 // System.out.println(teacher); //&#125; Collections.sort(list); //调用可比较接口 for (Teacher teacher : list) &#123; System.out.println(teacher); &#125; &#125;&#125; Collections java.util.Collections[C] - 集合工具类 面试题 - Collection和Collections有什么区别? static void sort(List list, Comparator&lt;? super T&gt; c)根据指定的比较器引起的顺序对指定的列表进行排序。 12Collections.sort(bookList,((o1, o2) -&gt; (int) (o2.getPrice()-o1.getPrice())));Collections.sort() //有两种方法 这是第一种 static &lt;T extends Comparable&lt;? super T&gt;&gt; void sort(List list) ; //集合中的对象必须要实现java.lang.Comparable可比较接口 - 第二种 HashSet Set[I]接口下的实现类 - 存储的数据是无序不可重复复的. 添加数据到容器的原理: 当把对象添加到容器中之前,会调用对象的hashCode方法,得到一个哈希值. 如果这个哈希值在这之前没有出现过,说明这个位置没有被占用,那么就可以直接将这个对象放入到这个容器中的这个位置 如果这个哈希值在这之前出现过了.产生了哈希碰撞或者哈希冲突.但是这个时候,还不能确定哈希碰撞的俩个对象是同一个对象 继续调用对象的equals方法,如果返回true,说明是同一个对象.则拒绝添加. 底层数据结构 散列表 桶数组 + 链表 + 红黑树 查看HashSet源码 Set sets = new HashSet&lt;&gt;(); 1234public HashSet() &#123;//HashSet的底层是HashMapmap = new HashMap&lt;&gt;();&#125; HashSet的add方法的底层 123456789private static final Object PRESENT = new Object();//此处的e是添加到容器中的对象public boolean add(E e) &#123;//实际上还是在调用map的put方法//HashSet中添加的对象是作为了Map集合的key//Map的key具有什么特点 = HashSet中的数据有何特点.return map.put(e, PRESENT)==null;&#125;","categories":[{"name":"集合框架","slug":"集合框架","permalink":"http://example.com/categories/%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/"}],"tags":[{"name":"java","slug":"java","permalink":"http://example.com/tags/java/"}]},{"title":"集合框架(一)","slug":"set-list-map","date":"2021-07-31T08:13:36.000Z","updated":"2021-08-02T02:29:37.701Z","comments":true,"path":"2021/07/31/set-list-map/","link":"","permalink":"http://example.com/2021/07/31/set-list-map/","excerpt":"","text":"包装类型每个基本类型都有其对应的包装类型[对象类型] byte-&gt;Byte short-&gt;Short int-&gt;Integer long-&gt;Long float-&gt;Float double-&gt;Double char-&gt;Character boolean-&gt;Boolean 学习掌握目标 包装类型的api的常用方法 包装类型和基本数据类型以及String类型三者之间的相互转换问题. Numberapi:java.lang包,所有关于上面包装类型[数字]的共同的抽象的父类. byte byteValue()返回指定号码作为值 byte ，这可能涉及舍入或截断。 abstract double doubleValue()返回指定数字的值为 double ，可能涉及四舍五入。 abstract float floatValue()返回指定数字的值为 float ，可能涉及四舍五入。 abstract int intValue()返回指定号码作为值 int ，这可能涉及舍入或截断。 abstract long longValue()返回指定数字的值为 long ，可能涉及四舍五入或截断。 short shortValue()返回指定号码作为值 short ，这可能涉及舍入或截断。 提供的这些方法都是关于包装类型转换成对应的基本类型的方法 Integer构造 Integer(int i); //利用int类型的整数来构建一个Integer对象 - int类型 -&gt; Integer类型 Integer(String s); //此处的字符串一定是数字形式的字符串 - String类型 -&gt; Integer类型 如果传入的是一个非数字形式的字符串,那么会抛出java.lang.NumberFormatException数字格式化失败异常 自动解封箱jdk5.x开始支持的新的功能 封箱 - 基本数据类型可以自动转换成对应的包装类型 解箱 - 包装类型可以自动转换成对应的基本的数据类型 常用方法static Integer valueOf(int i);//将int-&gt;Integer 1[-128,127] -&gt; 比较的结果是true,不在这个范围的是返回false !!! 12345678910111213141516171819202122//如果[-128,127]之间,那么直接返回内部的 [缓冲数] 组中的数据//如果不在这个范围,返回一个新的Integer对象public static Integer valueOf(int i) &#123; //缓冲区的底层代码 if (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high) return IntegerCache.cache[i + (-IntegerCache.low)]; return new Integer(i);&#125;private static class IntegerCache &#123; //Integer类内部有一个静态内部类 static final int low = -128; static final int high; //缓冲区,提供了缓冲的数组,数组在静态代码块中进行预初始化,提前赋值了. static final Integer cache[]; static&#123; cache = new Integer[(high - low) + 1]; int j = low; for(int k = 0; k &lt; cache.length; k++) cache[k] = new Integer(j++); &#125;&#125; 12345678910111213141516171819202122232425262728293031323334 // [-128,127] -&gt; 比较的结果是true,不在这个范围的是返回false !!!// 剖析自动封箱Integer a = 127; //Integer a = Integer.valueOf(127);Integer b = 127;System.out.println(a == b); //trueadmindeMacBook-Pro:Desktop admin$ javap -c IntegerHello Compiled from &quot;IntegerHello.java&quot;public class IntegerHello &#123; public IntegerHello(); Code: 0: aload_0 1: invokespecial #1 // Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V 4: return public static void main(java.lang.String[]); Code: 0: bipush 127 2: invokestatic #2 // Method java/lang/Integer.valueOf:(I)Ljava/lang/Integer; 5: astore_1 6: bipush 127 8: invokestatic #2 // Method java/lang/Integer.valueOf:(I)Ljava/lang/Integer; 11: astore_2 12: getstatic #3 // Field java/lang/System.out:Ljava/io/PrintStream; 15: aload_1 16: invokevirtual #4 // Method java/lang/Integer.intValue:()I 19: bipush 7 21: if_icmpne 28 24: iconst_1 25: goto 29 28: iconst_0 29: invokevirtual #5 // Method java/io/PrintStream.println:(Z)V 32: return&#125; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071package stu.aistar.day10;/** * 本类用于演示： 【笔数易错题】 */public class IntegerDemo &#123; public static void main(String[] args) &#123; Integer i = new Integer(&quot;10&quot;); //不可以是非数字的字符串 String -&gt; Integer //Integer -&gt; int Integer内部提供的【非静态】的方法 把Integer转换为Int int i1 = i.intValue(); int i2 = i; //Integer -&gt; int 自动拆箱 Integer j = new Integer(10); //int -&gt; integer System.out.println(j); System.out.println(i == j); //false 创建了两次 都在堆中 有不同的地址值 //封箱 - 基本数据类型可以自动转换成对应的包装类型 //[-128,127]-&gt;比较的结果是true,不在范围的返回false IntegerCache缓冲区属于静态内部类 Integer integer1 = 127; // -&gt; Integer a = Integer.valueOf(-128); Integer integer2 = 127; System.out.println(integer1 == integer2); //Integer中提供的静态方法 将int 转换为Integer类型 Integer x = Integer.valueOf(127); Integer y = Integer.valueOf(&quot;127&quot;); System.out.println(x == y); //true 只要不是new的都符合缓冲区的规则 //Integer -&gt; int Integer z = new Integer(10); //intValue() 是Integer类中的一个【非静态】的方法 (非静态需要通过对象进行调用) int n = z.intValue(); System.out.println(n); //基本类型和包装类型之间的比较 int t = 300; Integer t1 = new Integer(300); //返回值类型是Integer -&gt; int转换为Integer Integer t2 = Integer.valueOf(300); //返回值类型是Integer -&gt; int转换为Integer //当包装类型和基本类型进行比较的时候，包装类型调用调用intValue方法 - // - 转换成基本数据类型之后然后再和基本数据类型进行比较 System.out.println(t == t1); //true System.out.println(t == t2); //true System.out.println(t1 == t2); //false //进制转换 System.out.println(Integer.toBinaryString(10)); //二进制 System.out.println(Integer.toHexString(176)); //十六进制 //八进制 26/8余2 得3/8余3 反转 32 System.out.println(Integer.toOctalString(26)); //String -&gt; int Integer中提供的静态方法 将String转换为Int System.out.println(Integer.parseInt(&quot;10&quot;)); //String -&gt; Integer System.out.println(Integer.valueOf(&quot;100&quot;)); //Integer.valueOf() String -&gt; Integer //int 类型的范围 System.out.println(Integer.MAX_VALUE); System.out.println(Integer.MIN_VALUE); //Integer -&gt; String //String中提供的一个方法将Integer转换为String 任何事务都可以通过String.valueOf System.out.println(String.valueOf(10)); Integer s = new Integer(15); Integer s2 = new Integer(15); System.out.println(s==s2); &#125;&#125; 关于进制转换的方法 2-1. static String toBinaryString(int n); //十进制n转换成对应的二进制 2-2. static String toHexString(int n); //十进制n转换成对应的十六进制 2-3. static String toOctalString(int n); //十进制n转换成对应的八进制 static int parseInt(String s); //将数字形式的字符串转换成int类型,如果传入的是一个非数字形式的字符串,那么会抛出 java.lang.NumberFormatException数字格式化失败异常 static Integer valueOf(String s); //String-&gt;Integer 总结包装类型和基本数据类型以及String类型三者之间的相互转换问题. 1231. java.lang.Integer的构造Integer(int n)2. jdk5.0提供的自动封箱Integer a = 10;3. java.lang.Integer提供的static Integer valueOf(int n); Integer -&gt; int 12341. int intValue(); //java.lang.Number提供的抽象方法,java.lang.Integer重写了该方法2. jdk5.0提供的自动解箱 //intValue方法在Integer中, 所以他指的是一个Integer对象转换为int对象 ！ int-&gt;String 121. java.lang.String提供的方法static String valueOf(int n); //一切类型都可以通过String.valueOf方法进行转换为String类型 String-&gt;int 1231. java.lang.Integer类static int parseInt(String s); //parseInt(String) 是Integer里面的一个方法 (估计是传参时候才能用得到) // 转发 和 重定向 的时候！ int a = Integer.parseInt(&quot;1000&quot;); String-&gt;Integer 12341. java.lang.Integer的构造Integer(String n) //Integer i = new Integer(&quot;10&quot;); 就是创建Integer的时候 里面必须是数字型字符串2. java.lang.Integer的方法static Integer valueOf(String n); //Integer it = Integer.valueOf(&quot;128&quot;); Integer-&gt;String 121. java.lang.Integer的String toString();2. java.lang.String中提供了static String valueOf(Object obj); 作业1笔试题:int和Integer之间的区别 Integer是int的包装类；int是基本数据类型； Integer变量必须实例化后才能使用；int变量不需要； Integer实际是对象的引用，指向此new的Integer对象；int是直接存储数据值 ； Integer的默认值是null；int的默认值是0。 泛型不支持int，但是支持Integer int 存储在栈中。Integer 对象的引用存储在栈空间中，对象的数据存储在堆空间中。 作业2 123456789101112131415161718192021222324252627282930313233343536public class Test &#123; public static void main(String[] args) &#123; Scanner scanner = new Scanner(System.in); int[] arr = new int[13]; System.out.println(&quot;请输入13位的校验码：&quot;); for (int i = 0; i &lt;13 ; i++) &#123; //存储校验码 arr[i] = scanner.nextInt(); &#125; int sum = 0; //计数器 for (int i = 0; i &lt; arr.length; i++) &#123; //计算偶数位之和 if (i%2 == 1)&#123; sum += arr[i]; &#125; &#125; System.out.println(&quot;偶数位上之和为：&quot;+sum); // 2 后面要×3 int sum1 = 0; //计数器 for (int i = 0; i &lt; arr.length-1; i++) &#123; //计算奇数位之和 除了最后一个 if (i%2 == 0)&#123; sum1 += arr[i]; &#125; &#125; System.out.println(&quot;奇数位之和为：&quot;+sum1); //×3的结果 加上sum1 int num = sum*3 + sum1; //记录 偶数成3 + 奇数 int num1 = 0; //记录大于等于num 且结果为10 的最小公倍数 for (int i = num; ; i++) &#123; if (i%10 == 0)&#123; num1 = i; break; &#125; &#125; System.out.println(&quot;大于等于num，且结果为10的最小公倍数的值num1为：&quot;+num1); System.out.println(&quot;最终的校验码X为：&quot;+(num1 - num)); &#125;&#125; Objectjava.lang.Object类是所有的类的基类,根类,超类 所有的类如果没有明确指定父类,都会默认继承Object类. equalsboolean equals(Object obj); //对象之间的比较.默认仍然使用的是 == “业内认可的一种说法” - 基本类型用==比较的值 , 对象类型用==比较的是地址 123public boolean equals(Object obj) &#123; return (this == obj);&#125; 默认的比较方式不符合实际的业务需要,因此需要重写equals方法 success版本 12345678910111213141516171819202122 @Overridepublic boolean equals(Object obj)&#123; //1. 非空性 if(obj == null) return false; //2. 自反性 if(this == obj)//p1.equals(p1) return true; //3. 一致类型,判断具体的哪个属性是一致的,才认为返回true // p1.equals(user); if(obj instanceof Product)&#123; Product p = (Product) obj; //return this.id == p.id; //id和name都一致的时候,才认为是同一个对象 //return (this.id == p.id) &amp;&amp; (this.name.equals(p.name)); //需求 - 认为产品的id以及这个产品对应的产品信息的id一致的时候认为返回true return this.id == p.id &amp;&amp; this.getProductInfo().equals(p.productInfo); &#125; return false;&#125; hashCode方法int hashCode(); //返回对象的哈希值.一般是和equals方法是【成对】出现的.目的是为了提高性能. 容器应用中 - 在什么时候才会去调用equals方法? - 当哈希碰撞的时候,只要哈希不冲突,不会调用equals方法 而调用equals方法执行的时机肯定会慢一点的.因为它需要比较属性值[需要更多的时间] 关于数字31 - 质数 - 1. 尽可能产生更多的哈希值 2. 让哈希碰撞/冲突尽可能少. 1234567@Overridepublic int hashCode() &#123; int result = id != null ? id.hashCode() : 0; result = 31 * result + (name != null ? name.hashCode() : 0); result = 31 * result + (productInfo != null ? productInfo.hashCode() : 0); return result;&#125; 超前知识点 1234567891011121314151617181920212223242526272829303132333435363738394041424344package stu.aistar.day10.hashcodes;import java.util.HashSet;import java.util.Set;/** * 本类用来演示: */public class TestCourse &#123; public static void main(String[] args) &#123; Course c1 = new Course(1,&quot;java&quot;); Course c2 = new Course(1,&quot;java&quot;); Course c3 = new Course(3,&quot;mysql&quot;); Course c4 = new Course(4,&quot;mysql&quot;); Course c5 = new Course(5,&quot;mysql&quot;); Course c6 = new Course(1,&quot;oracle&quot;); //System.out.println(c1 == c2); //false //System.out.println(c1.equals(c2)); //true //集合 - &quot;容器&quot;,比数组更加强大的. //集合 - 里面存储的数据是【无序不可重复】的 //不能存储同一个对象 Set&lt;Course&gt; sets = new HashSet&lt;&gt;(); //1. 当把某个对象放入到该容器之前,先调用了该对象的hashCode方法,得到一个哈希值 //2. 根据这个哈希值就可以被分配一个内存地址 //3. 如果这个哈希值在这之前没有出现过,说明这个位置没有被占用.那么就会直接将该对象放入到 // 这个哈希值对应的在容器中的那个位置 //4. 如果这个哈希值在这之前出现过.但是此时还不能说明这个对象和之前的那个对象是同一个对象 // 因为哈希值是通过哈希算法计算得到的,可能产生&quot;哈希冲突&quot; - &quot;哈希碰撞&quot; //5. 当哈希值一样的时候,那么才会去调用equals方法,如果equals方法仍然返回true,那么才 // 最终确定这个对象曾经出现过,那么就拒绝添加. sets.add(c1); sets.add(c2); //拒绝添加 hashcode一样 hashcode是自定义让他通过id计算的 sets.add(c3); sets.add(c4); sets.add(c5); sets.add(c6); //拒绝添加 for (Course c : sets) &#123; System.out.println(c); &#125; &#125;&#125; 总结 如果俩个对象的hashcode值一样,那么equals比较,不一定返回true 如果俩个对象equals返回true,那么这俩个对象的哈希值必须要一样(必须是hashcode一样才会来走equals) - 数据的完整性. 笔试题== 和 equals的区别 == 基本类型使用,比较的就是基本类型的数值 equals 对象类型使用.如果某个类没有重写equals方法,那么调用的是java.lang.Object中的equals方法,这个时候仍然使用到的是==比较.如果重写了equals,就看equals提供的是哪些属性一致的时候,才返回true. clone方法protected Object clone(); // 默认的克隆方法是浅克隆 浅克隆浅拷贝,浅层复制,浅复制 - 默认的. protected - public 123456@Overridepublic Object clone() throws CloneNotSupportedException &#123;return super.clone();&#125;Object中的clone方法 - native修饰的方法 - 本地方法栈中的方法 - C写的 - Java语言本地调用C程序.protected native Object clone() throws CloneNotSupportedException; 只有实现了java.lang.Cloneable接口[标记接口]的对象才能够调用clone方法,否则会抛出java.lang.CloneNotSupportedException不支持克隆的异常. 123456Product copy = (Product) p1.clone();Product copy2 = new Product(1,&quot;mac&quot;,1000.0d);//为什么需要使用clone,而不直接new一个.//clone方法它直接操作的堆里面的内存 - 效率是高于重新new的. 1234567891011121314151617181920212223242526272829303132333435/** * 本类用来演示:浅拷贝 * 修改原来对象的基本数据类型以及字符串类型,都不会对副本对象产生影响 * 但是如果修改原来对象中的对象类型的属性值的话,会对副本对象产生影响 */public class TestCloneDemo &#123; public static void main(String[] args) &#123; Product p1 = new Product(1,&quot;mac&quot;,1000.0d); ProductInfo info = new ProductInfo(1,&quot;good&quot;); p1.setProductInfo(info); //System.out.println(p1 instanceof Cloneable);//true try &#123; //浅拷贝 Product copy = (Product) p1.clone(); //1. 修饰基本数据类型以及字符串 - 原来的对象 - 是否对copy对象产生影响 - 不会 p1.setId(10); p1.setName(&quot;tom&quot;); //2. 修改对象类型 - 会对copy的对象产生影响的 p1.getProductInfo().setId(100); p1.getProductInfo().setInfo(&quot;bad&quot;); System.out.println(copy); System.out.println(copy.getProductInfo()); //System.out.println(copy == p1);//false &#125; catch (CloneNotSupportedException e) &#123;//不能被克隆的异常 e.printStackTrace(); &#125; &#125;&#125; 深克隆深层复制,深拷贝,深复制 - 需要【自己重写】clone里面的具体的代码的 123456789101112131415161718192021222324/** * 深拷贝 - 修改原来对象中的任何类型的数据都不会对副本对象产生影响 * @return * @throws CloneNotSupportedException */@Overridepublic Object clone() throws CloneNotSupportedException &#123; //Product copy = (Product)p1.clone(); //手动新建一个Product对象 Product product = new Product(); product.setId(id); product.setName(name); product.setPrice(price); ProductInfo infos = getProductInfo(); if(infos!=null)&#123; ProductInfo pi = new ProductInfo(); pi.setId(infos.getId()); pi.setInfo(infos.getInfo()); product.setProductInfo(pi); &#125; return product;&#125; 集合框架就是内存中的”容器对象” - 存储数据的.开发中来替代数组的使用. 结构123456789101112131415api:java.util Collection[I] - List[I] - 【有序可重复】 - ArrayList[C] - LinkedList[C] - Vector[C] - Set[I] - 【无序不可重复】 - HashSet[C] - SortedSet[I] - TreeSet[C]Map[I] - HashMap[C] - 【key-value】的形式存储数据的,针对key是【无序不可重复】. - Hashtable[C] - Properteis[C] - 属性文件在内存中的映射的对象 Collection[I] boolean add(E e);//向容器中添加一个元素 void clear();//清空容器 boolean contains(Object o);//判断容器中是否包含某个对象 boolean isEmpty();//如果集合中没有数据,集合大小为0,返回true Iterator iterator();// 获取集合对象的迭代器 boolean remove(Object obj);//删除集合容器中第一次出现的这个对象.只能删除1个 int size();//返回集合中的数据的个数 - 集合的大小 List[I]特点 - 有序并且是可以重复的. E get(int index); //根据下标去取.集合下标边界[0,集合.size()-1] int indexOf(Object obj); //返回此列表中指定元素的第一次出现的索引，如果此列表不包含元素，则返回-1。 E remove(int index); //根据下标删除,并且返回刚刚删除的那个元素 Object[] toArray(); //将集合转换成数组. ArrayList[C]特点:有序可重复的,底层数据结构就是一个”动态增长”的数组. 优点:因为数组是一个有序的序列,所以它可以通过下标直接取值 - 查询效率高. 缺点:增删效率会低. 分析源码123456789101112131415161718192021222324252627282930 /** * 默认的初始的容量 */private static final int DEFAULT_CAPACITY = 10;/** * Shared empty array instance used for default sized empty instances. We * distinguish this from EMPTY_ELEMENTDATA to know how much to inflate when * first element is added. */private static final Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = &#123;&#125;;//就是真正的存储数据的数组transient Object[] elementData; /** * The size of the ArrayList (the number of elements it contains). * * @serial */private int size;//构造public ArrayList() &#123; //1. 初始化elementData,长度为0 //2. 是为了后面的ensureCapacityInternal方法中判断是否是第一次调用add方法 this.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA; //this.elementData = &#123;&#125; ↑&#125; 剖析add方法 ArrayList扩容的原理 12345public boolean add(E e) &#123;ensureCapacityInternal(size + 1); // Increments modCount!!elementData[size++] = e;return true;&#125; 扩容方法 12345678private void ensureCapacityInternal(int minCapacity) &#123; //第一次进来1if (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123; //true minCapacity = Math.max(DEFAULT_CAPACITY, minCapacity); //第一次minCapacity = 10&#125;ensureExplicitCapacity(minCapacity);&#125; 继续ensureExplicitCapacity(minCapacity); 12345678private void ensureExplicitCapacity(int minCapacity) &#123;modCount++;// overflow-conscious code//第一次进来10-0&gt;0if (minCapacity - elementData.length &gt; 0)grow(minCapacity);&#125; grow(minCapacity) 123456789101112131415private void grow(int minCapacity) &#123;// 第一次//oldCapacity = 0//newCapacity = 0int oldCapacity = elementData.length;int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1); //1.5倍if (newCapacity - minCapacity &lt; 0) //第一次会进来 newCapacity = minCapacity; //newCapacity = 10if (newCapacity - MAX_ARRAY_SIZE &gt; 0) newCapacity = hugeCapacity(minCapacity); // minCapacity is usually close to size, so this is a win://第一次执行add方法的时候,底层会给我们初始化了一个长度为10的Object[]数组elementData = Arrays.copyOf(elementData, newCapacity);&#125; 集合的遍历 直接输出 增强for循环 - 只读 1234567891011121314151617181920212223242526272829//只读的循环.如果在循环的过程中进行了remove操作 - // - 抛出java.util.ConcurrentModificationException并发修改异常 //实际的底层,调用迭代器对象中的next方法 private class Itr implements Iterator&lt;E&gt; &#123; int cursor; // index of next element to return int lastRet = -1; // index of last element returned; -1 if no such int expectedModCount = modCount; public E next() &#123; checkForComodification(); //.... &#125; final void checkForComodification() &#123; //modCount是当初调用add方法,添加1个元素,modCount自增1个 if (modCount != expectedModCount) throw new ConcurrentModificationException(); &#125;&#125; //发现只要调用了remove方法 - modCount++ private void fastRemove(int index) &#123; modCount++; int numMoved = size - index - 1; if (numMoved &gt; 0) System.arraycopy(elementData, index+1, elementData, index, numMoved); elementData[--size] = null; // clear to let GC do its work&#125;","categories":[{"name":"集合框架","slug":"集合框架","permalink":"http://example.com/categories/%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/"}],"tags":[{"name":"java","slug":"java","permalink":"http://example.com/tags/java/"}]},{"title":"String+StringBuilder","slug":"String","date":"2021-07-31T08:12:46.000Z","updated":"2021-07-31T10:08:45.044Z","comments":true,"path":"2021/07/31/String/","link":"","permalink":"http://example.com/2021/07/31/String/","excerpt":"","text":"java.lang.String Java中提供的处理字符串的类. 不可变的字符串 1234//定义到串池中的字符串(只可有一份，如果后面再定义一个&quot;abc&quot;,// - 则在串池中指向的是同一个字符串,而不会再去创建一个&quot;abc&quot;)String s = &quot;abc&quot;; s = &quot;eef&quot;; //ok,&quot;abc&quot;就变成了垃圾对象. 字符串本质上就是一个字符数组 12345678//final修饰的类不可被继承public final class String implements java.io.Serializable, Comparable&lt;String&gt;, CharSequence &#123; //维护的是不可变的字符数组 //String s = &quot;abc&quot;;//将&quot;abc&quot;打散,保存成value[]数组中. private final char value[]; &#125; 字符串构建的方式 通过new关键字来构建 12345//创建了几个对象?//1个或者2个//①通过new关键字在[堆]里面创建一个字符串对象&quot;abc&quot;//②[同时]在&quot;串池&quot;里面扔一个对象&quot;abc&quot;[前提是串池中之前不存在&quot;abc&quot;]String s1 = new String(&quot;abc&quot;); 直接通过”串池”/“字符串常量池”的方式来构建 12345678//创建了几个对象? //它会在&quot;串池&quot;中创建一个&quot;abc&quot;字符串对象,然后将地址给了s1String s1 = &quot;abc&quot;;//&quot;串池&quot;中的特点:优先先到串池中查找是否已经存在&quot;abc&quot;对象,[如果有直接返回地址]给s2//[否则]才会继续[创建新的字符串对象]String s2 = &quot;abc&quot;;System.out.println(s1 == s2);//true 关于字符串的拼接 字符串的拼接使用 + ,但是使用 + 的拼接效率非常低. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647package stu.aistar.day09;import java.util.Date;/** * 本类用来演示: 字符串拼接效率低 - (用时间来证明效率) */public class StringPlusDemo &#123; public static void main(String[] args) &#123; test02();//append - 方法进行字符串的拼接 test01();// + - 方法进行字符串的拼接 &#125; public static void test01()&#123; //在本类中定义静态方法 long t1 = System.currentTimeMillis(); //获取当前系统时间的毫秒数 String str = &quot;&quot;; for (int i = 0; i &lt; 100000; i++) &#123; str+=i; //str = str + i; &#125; long t2 = System.currentTimeMillis(); //+拼接过后的当前系统时间 System.out.println(&quot;str拼接时间:&quot;+(t2-t1)+&quot;ms&quot;); //得到拼接的时间 &#125; public static void test02()&#123; //java.lang.StringBuilder //创建StringBuilder对象,用来接收字符串的拼接 StringBuilder builder = new StringBuilder(); long t1 = System.currentTimeMillis(); //获取当前系统时间的毫秒数 for (int i = 0; i &lt; 100000; i++) &#123; builder.append(i); //拼接方式 &#125; long t2 = System.currentTimeMillis(); //append拼接过后的当前系统时间 System.out.println(&quot;append拼接时间:&quot;+(t2-t1)+&quot;ms&quot;); &#125;&#125;//测试结果+拼接所用的时间远远大于append拼接所用的时间-证明+拼接的效率低 反之append拼接的效率高！ 拼接效率的原因 +底层每次都会产生一个StringBuilder对象 +底层仍然是调用StringBuilder中的append方法 1234567891011121314151617181920212223242526字符串使用+拼接的过程中,会产生新的对象 - 拼接效率低String s1 = &quot;abc&quot;;String s2 = new String(&quot;abc&quot;); admindeMacBook-Pro:Desktop admin$ javap -c HelloStrCompiled from &quot;HelloStr.java&quot;public class HelloStr &#123; public HelloStr(); Code: 0: aload_0 1: invokespecial #1 // Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V 4: return public static void main(java.lang.String[]); Code: 0: ldc #2 // String abc 放在了&quot;串池中&quot; 2: astore_1 3: new #3 // class java/lang/String 6: dup // &quot;abc&quot; -&gt; 堆里面 7: ldc #2 // String abc &quot;串池中已经出现了&quot; 9: invokespecial #4 // Method java/lang/String.&quot;&lt;init&gt;&quot;:(Ljava/lang/String;)V 12: astore_2 13: return&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142String s1 = &quot;abc&quot;;String s2 = new String(&quot;def&quot;);s1 = s1 + s2;//会产生一个新的对象admindeMacBook-Pro:Desktop admin$ javap -c HelloStrCompiled from &quot;HelloStr.java&quot;public class HelloStr &#123; public HelloStr(); Code: 0: aload_0 1: invokespecial #1 // Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V 4: return public static void main(java.lang.String[]); Code: 0: ldc #2 // String abc 在串池中 2: astore_1 3: new #3 // class java/lang/String 6: dup // 同时在堆中开辟一块空间用来存储 String def 7: ldc #4 // String def 在串池中 9: invokespecial #5 // Method java/lang/String.&quot;&lt;init&gt;&quot;:(Ljava/lang/String;)V 12: astore_2 13: new #6 // class java/lang/StringBuilder //字符串每次拼接+,都会产生一个新的StringBuilder对象 16: dup 17: invokespecial #7 // Method java/lang/StringBuilder.&quot;&lt;init&gt;&quot;:()V //StringBuilder builder = new StringBuilder(); 20: aload_1 21: invokevirtual #8 // Method java/lang/StringBuilder.append: //(Ljava/lang/String;)Ljava/lang/StringBuilder; //字符串的+,底层仍然是去调用StringBuilder类中提供的append方法; 24: aload_2 25: invokevirtual #8 // Method java/lang/StringBuilder.append:(Ljava/lang/String;)Ljava/lang/StringBuilder; 28: invokevirtual #9 // Method java/lang/StringBuilder.toString:()Ljava/lang/String; 31: astore_1 32: return&#125; 字符串的比较1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950package stu.aistar.day09;/** * 本类用来演示: 字符串的各种比较 - (笔试题中容易出现) */public class StringCompare &#123; public static void main(String[] args) &#123; String s1 = new String(&quot;abc&quot;); //s1默认指向的是堆里面的字符串对象 String s2 = &quot;abc&quot;; //创建在 串池 中 System.out.println(s1 == s2); //false System.out.println(s1.intern() == s2);//true //因为intern()强制让s1指向串池的对象 String s3 = &quot;b&quot;; String s4 = &quot;a&quot; + s3; //产生一个StringBuilder对象 String s5 = &quot;a&quot; + &quot;b&quot;; //因为此处的&quot;a&quot;和&quot;b&quot;就是字符串常量 //jvm对待字符串常量的拼接 - &quot;a&quot;和&quot;b&quot;的拼接 //当成&quot;ab&quot;的整体,直接扔到常量池中. System.out.println(s4 == s5); //false final String s6 = &quot;b&quot;; //字符串使用final修饰 String s7 = &quot;a&quot; + s6; //&quot;a&quot;+s6 =&gt; &quot;ab&quot;扔到常量池,没有产生新的对象. System.out.println(s5 == s7); //true String x1 = new String(&quot;abc&quot;); //都定义在堆区 x1 x2分别拥有不同的地址值 String x2 = new String(&quot;abc&quot;); System.out.println(x1 == x2); //false 比较的是地址值 System.out.println(x1); //希望字符串的值是一样的,就希望返回true System.out.println(x1.equals(x2)); //true 用equals方法 比较的是字符串的值 //特殊方法获得的字符串 通过subString String o1 = &quot;abc&quot;; String o2 = o1.substring(0); //如果是0开始的话 底层 返回的是他的本身this //也就是o1自己的地址 指向的同一块 System.out.println(o1 == o2); //true 只有当subString全部的时候 才能是true String o3 =o1.substring(1,3); //bc System.out.println(&quot;bc&quot; == o3); //false System.out.println(&quot;ok&quot; == getResult()); &#125; public static String getResult()&#123; // return &quot;ok&quot;; // true 串池中 return new String(&quot;ok&quot;); //false new出来的在堆中 &#125;&#125; 字符串常用方法 构造方法 String(); String(String val); String(StringBuilder builder);//StringBuilder对象转换成String对象 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465package stu.aistar.day09;/** * 本类用来演示: 字符串常用方法 */public class StringMethod &#123; public static void main(String[] args) &#123; String s = new String(&quot;abc&quot;); // 当charAt(&gt;s.length的时候) java.lang.StringIndexOutOfBoundsException //b 1对应的是String对应数组的下标 (string底层是一个char类型的数组) System.out.println(s.charAt(1)); System.out.println(s.length()); //3 字符串的长度 //原来的字符串的末尾添加新的字符串 (底层是通过普通数组的扩容进行拼接的字符串) String result = s.concat(&quot;de&quot;); System.out.println(result); //abcde //判断字符串中是否包含某个序列 (返回类型是一个boolean类型) &lt;- true System.out.println(s.contains(&quot;bc&quot;)); // 判断前缀或者后缀(返回类型是一个boolean类型) &lt;- true System.out.println(&quot;xxx.gif&quot;.endsWith(&quot;.gif&quot;)); System.out.println(&quot;javaScript&quot;.startsWith(&quot;java&quot;));//前缀 &lt;- true System.out.println(&quot;abc&quot;.equals(s)); //true 比较的是字符串的值 System.out.println(&quot;ABc&quot;.equalsIgnoreCase(&quot;abc&quot;));//忽略大小写的比较(ignore) true System.out.println(&quot;abc&quot;.toUpperCase()); //转换大写和小写ABC System.out.println(&quot;ABC&quot;.toLowerCase()); //abc(小写) System.out.println(&quot;abcabc&quot;.indexOf(&quot;bca&quot;));//返回指定字符第一次出现的字符串内的索引(1) //返回最后一个出现该字符的索引(下标) -4 (也可以是一个字符串 &quot;bca&quot;) System.out.println(&quot;abcabc&quot;.lastIndexOf(&quot;b&quot;)); System.out.println(&quot;&quot;.isEmpty());//判断字符串是否为空 长度为0的字符串 - 返回true System.out.println(&quot;I Love Girl&quot;.replace(&quot;Girl&quot;,&quot;Java&quot;));//替换 String ip = &quot;192:168:3:90&quot;; //字符串的切割 String[] arr = ip.split(&quot;\\\\:&quot;); // &quot;\\\\s&quot;指的是空格 想要设置哪个标识进行切割，必须两个\\ for (String s1 : arr) &#123; //增强for循环比遍历arr数组 - (切割过后的值) System.out.println(s1); &#125; //将字符串转换成char类型数组 (String -&gt; Char[]) char[] arr2 = &quot;白日依山尽&quot;.toCharArray(); for (char c : arr2) &#123; System.out.println(c); &#125; String x1 = &quot;abcde&quot;; String x2 = x1.substring(1,3); //[1,3) System.out.println(x2); System.out.println(x1.substring(1));//从1一直截取到最后bcde //trim() - 去除字符串左右两边的空格 System.out.println(&quot; ab c &quot;.trim().length()); //4 System.out.println(&quot; &quot;.trim().length()); //0 String o = String.valueOf(10); //int-&gt;String System.out.println(o+10); &#125;&#125; java.lang.StringBuilder 它是一个[可变]的字符串 - final修饰,性能最高的.默认的容量 [16] .线程不安全的 StringBuilder(); StringBuilder(String val); //String类型转换成StringBuilder类型 扩容机制 研究append方法 12345678910111213141516171819202122232425262728293031323334353637StringBuilder x = new StringBuilder(&quot;abc&quot;);x.append(&quot;def&quot;);//StringBuilder类的父类AbstractStringBuilderpublic AbstractStringBuilder append(String str) &#123;if (str == null) return appendNull();int len = str.length();//len = 3//count+len//count - 原来数组中已经存在的字符的长度//len - 需要存入的新的字符串长度ensureCapacityInternal(count + len);//0+3str.getChars(0, len, value, count);count += len; //把新字符串的长度赋值给count 一遍下一次扩容return this;&#125;//扩容方法private void ensureCapacityInternal(int minimumCapacity) &#123;// overflow-conscious codeif (minimumCapacity - value.length &gt; 0) expandCapacity(minimumCapacity);&#125;//真正的扩容方法void expandCapacity(int minimumCapacity) &#123;int newCapacity = value.length * 2 + 2; //扩容,得到新的长度if (newCapacity - minimumCapacity &lt; 0) //扩容得不够,不够长 newCapacity = minimumCapacity; //直接补充到最长的.if (newCapacity &lt; 0) &#123; //长度会溢出. if (minimumCapacity &lt; 0) // overflow throw new OutOfMemoryError(); newCapacity = Integer.MAX_VALUE;&#125;value = Arrays.copyOf(value, newCapacity);&#125; 常用方法12345678910111213141516171819202122232425262728293031package stu.aistar.day09;/** * 本类用来演示: 常用方法 - 可变的字符串 */public class StringBuilderMethod &#123; public static void main(String[] args) &#123; StringBuilder x = new StringBuilder(&quot;abcd&quot;);//String-&gt;StringBuilder(内部) System.out.println(x); StringBuilder result = x.delete(1,3); //[1,3) System.out.println(&quot;result:&quot;+result); //ad System.out.println(&quot;x:&quot;+x); //ad System.out.println(x.deleteCharAt(0)); //d 根据下标进行删除操作 x.insert(0,&quot;晓恒&quot;); System.out.println(x);//晓恒d System.out.println(x.reverse());//d恒晓 //反转字符串 //int n = 6723; //System.out.println(String.valueOf(n).length());//利用转换成字符串求几位数(字符串的长度=位数) //tringBuilder y = new StringBuilder(String.valueOf(n));//String -&gt; StringBuilder //System.out.println(y.reverse());//利用StringBuilder的反转方法 - (解决数字的反转问题) //StringBuilder-&gt;String System.out.println(x.toString()); &#125;&#125; 总结! String类型和StringBuilder类型之间的相互转换问题 StringBuilder-&gt;String类型 java.lang.StringBuilder中提供的String toString(); java.lang.String类中提供的构造方法String(StringBuilder builder); java.lang.String类中提供的static String valueOf(Object obj);//面向父类编程 String-&gt;StringBuilder java.lang.StringBuilder中提供的构造StringBuilder(String val); java.lang.StringBuffer 它的使用方式和StringBuilder是一模一样的.唯一区别是它是多线程安全的.可变的字符串 因为它里面的方法都使用synchronized关键字进行了修饰,重量级的对象. 性能低于StringBuilder 笔试题 String,StringBuilder,StringBuffer三者的区别? - 查,补充完整 - 作业 三者之间都是使用final修饰的,都是不可被继承的,jdk处于安全角度考虑的 - 共同点 不同点 2-1. String它是不可变的字符串,线程安全的.比较耗系统资源和内存的.性能是三个当中最低的. 2-2. StringBuilder可变的字符串 - 线程不安全的,效率是最高的. 2-3. StringBuffer可变的字符串 - 线程安全的.效率低于StringBuilder,但是高于String String StringBuffer StringBuilder String的值是不可变的，这就导致每次对String的操作都会生成新的String对象，不仅效率低下，而且浪费大量优先的内存空间 StringBuffer是可变类，和线程安全的字符串操作类，任何对它指向的字符串的操作都不会产生新的对象。每个StringBuffer对象都有一定的缓冲区容量，当字符串大小没有超过容量时，不会分配新的容量，当字符串大小超过容量时，会自动增加容量 可变类，速度更快 不可变 可变 可变 线程安全 线程不安全 多线程操作字符串 单线程操作字符串 作业 两道笔试题 1234567891011121314151617181920212223242526272829303132333435363738394041424344//从oldStr中删除指定的target字符串//比如&quot;abcdebcef&quot;,&quot;bc&quot; -&gt; 返回&quot;adeef&quot;//禁止使用replace方法//(此方法为非递归)public class DelByStr &#123;public static void main(String[] args) &#123; String s1 = &quot;abcdebcef&quot;; String s2 = &quot;bc&quot;; System.out.println(delByStr(s1, s2));&#125;public static String delByStr(String oldStr,String target) &#123; while (oldStr.contains(target))&#123; //包含目标串 int index = oldStr.indexOf(target); //获取目标串在老字符串中的索引(下标) //转换成StringBuilder对象,因为里面有一个delete方法 StringBuilder builder = new StringBuilder(oldStr); builder.delete(index,target.length()+index); oldStr = builder.toString(); //转换为原字符串形式 (StringBuilder-&gt;String) &#125; return oldStr;&#125;&#125;//递归方式(easy - 首先得学会递归!) - 根据字符串到原来的字符串中进行删除操作 - 操作的不是原来的字符串// - ,不断返回一个新的字符串.public static String delByStr(String oldStr,String target)&#123; //1. 递归出口 if(!oldStr.contains(target)) return oldStr; //2. oldStr中仍然包含target //找到target字符串在oldStr字符串中的下标位置. //bcbcabca -&gt; ca int startIndex = oldStr.indexOf(target); //返回target在oldStr中第一次出现的下标位置 int endIndex = startIndex+target.length(); //5 //String类型转换成StringBuilder类型 - delete(int start,int end); //[start,end) StringBuilder builder = new StringBuilder(oldStr); StringBuilder result = builder.delete(startIndex,endIndex); //bcbbca return delByStr(result.toString(),target);&#125; 123456789101112131415161718192021222324252627282930//找出俩个字符串中的最大长度的公串//s1：abcbcedfdfdepopoqqq//s2：fdfdbcbceoifdfdeqqa//结果为：bcbce fdfdepublic class FindMaxPublicStr &#123;public static void main(String[] args) &#123; String s1 = &quot;abhbcedfdfdepofabcbc&quot;; String s2 = &quot;fdfdbcbceoifdfabcbc&quot;; String s3 = &quot;&quot;; int max = 0; //记录公串长度 for (int i = 0; i &lt; s1.length(); i++) &#123; for (int j = i; j &lt;= s1.length(); j++) &#123; //不设置= 取不到最后一个 s3 = s1.substring(i,j); //s3中是否包含截取的字符串 if (s2.contains(s3))&#123; if (max&lt;s3.length())&#123; max = s3.length(); //求他的最大公串的长度(这样做可以避免公串有两个的问题) &#125; &#125; &#125; &#125; String str = &quot;&quot;; for (int i = 0; i &lt;= s1.length()-max; i++) &#123; str = s1.substring(i,i+max); if (s2.contains(str))&#123; System.out.println(str); &#125; &#125;&#125;&#125;","categories":[{"name":"字符串","slug":"字符串","permalink":"http://example.com/categories/%E5%AD%97%E7%AC%A6%E4%B8%B2/"}],"tags":[{"name":"java","slug":"java","permalink":"http://example.com/tags/java/"}]},{"title":"单例","slug":"Singleton","date":"2021-07-31T02:29:40.000Z","updated":"2021-11-10T10:01:45.182Z","comments":true,"path":"2021/07/31/Singleton/","link":"","permalink":"http://example.com/2021/07/31/Singleton/","excerpt":"","text":"单例引言 饿汉模式 多线程安全123456789101112131415161718192021222324252627282930package stu.aistar.design.singleton.version01;/** * 本类用于演示：饿汉式 多线程安全 (但是浪费空间,因为如果我只是想调用其中的方法 你干嘛给我创建一个对象) * 将Singleton01设置成饿汉模式 - 单例的 */public class Singleton01 &#123; //2. 初始化一个变量，该变量就是该类的唯一实例[对象] private static Singleton01 instance = new Singleton01(); //1. 私有化构造 private Singleton01()&#123; //比较费时费力的代码，可能需要更多的时间 System.out.println(&quot;Singleton01............&quot;); &#125; //3. 提供一个公开的、静态的、方法来返回这个类的唯一属性 public static Singleton01 getInstance()&#123; return instance; &#125;&#125;//测试public class TestSingleton01 &#123; public static void main(String[] args) &#123; //获取类的实例 Singleton01 s1 = Singleton01.getInstance(); Singleton01 s2 = Singleton01.getInstance(); System.out.println(s1 == s2); //true &#125;&#125; 懒汉模式 多线程不安全1234567891011121314151617181920212223242526272829package stu.aistar.design.singleton.version02;/** * 本类用来演示: 懒汉 * */public class Singleton02 &#123; private static Singleton02 instance; private Singleton02()&#123; System.out.println(&quot;私有化构造&quot;); &#125; public static Singleton02 getInstance()&#123; if (instance == null)&#123; instance = new Singleton02(); &#125; return instance; //return instance == null?instance = new Singleton02():instance; //三元运算符搞定！ &#125;&#125;class TestSingleton02&#123; public static void main(String[] args) &#123; Singleton02 s1 = Singleton02.getInstance(); Singleton02 s2 = Singleton02.getInstance(); System.out.println(s1 == s2); //true &#125;&#125; 双重检查锁 - （笔试脱手写的版本） 懒汉模式下 - 仍然是多线程安全的 12345678910111213141516171819202122232425262728293031323334353637package stu.aistar.design.singleton.version03;/** * 本类用来演示:双重检查锁 - (笔试脱手写的版本) */public class Singleton03 &#123; private static Singleton03 instance; private Singleton03()&#123; System.out.println(&quot;私有化构造&quot;); &#125; public static Singleton03 getInstance()&#123; //因为本身&quot;锁&quot;资源就是一个比较昂贵的资源,为了避免跑得慢的线程去抢这个把锁, // 所以此处也要进行非空判断. if(instance == null)&#123; //跑得快的线程都会进入此处 比如：A,B //A,B线程就会去争抢锁资源,谁抢到锁资源,谁就会进入 //同步代码块去执行里面的代码 //假设A线程抢到了,B就会在等待 synchronized (Singleton03.class)&#123; //A进入判断instance==null //只要抢到&quot;锁&quot;的线程,如果此处没有非null判断 //那么进入到这的线程都会去执行instance = new Singleton03(); if(instance == null)&#123; //由A线程进行实例的初始化 //A继续执行,等A执行完毕之后,那么A就会释放锁资源 //其他线程继续争抢锁资源. instance = new Singleton03(); &#125; &#125; &#125; return instance; &#125;&#125;//测试就是相同的测试... (目前还没到线程进行测试,后续会利用多线程进行单例测试) volatile 可见性 - 忽略 禁止JVM的指令重排 12345678910int i=10;//原子性操作 Student s = new Student();//不是一个原子性操作 ①给s对象分配内存空间 ②调用构造块,执行构造函数 - 初始化动作 ③将引用s指向内存中的那个对象. 但是JVM内部会对这些指令进行一个优化操作. 本来你的顺序应该是①-②-③,经过JVM指令重排之后,顺序有可能 变成①-③-② 123456789101112131415161718192021222324252627282930313233343536package stu.aistar.design.singleton.version03;/** * 本类用来演示:双重检查锁 - (笔试脱手写的版本) */public class Singleton03 &#123; private volatile static Singleton03 instance; //此处就利用volatile进行对jvm的禁止指令重排!!! //private static Singleton03 instance; private Singleton03()&#123; System.out.println(&quot;私有化构造&quot;); &#125; public static Singleton03 getInstance()&#123; //② - 跑得很慢的线程刚刚到达此处,其他线程判断instance是不为null的 //但是instance可能指向的是一个&quot;半成品&quot; - A线程还没有完成构造方法. //其他线程可能会使用到这个&quot;半成品&quot;对象,肯定会有问题. if(instance == null)&#123; synchronized (Singleton03.class)&#123; if(instance == null)&#123; //① - A线程可能执行到2步骤的时候,instance已经不为null //不是一个原子性操作,可能经过JVM指令重排 //1. 给instance对象分配空间 //2. 将对象的内存地址赋值给了instance //3. 调用构造方法 instance = new Singleton03(); &#125; &#125; &#125; return instance; &#125;&#125; PS12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455一、static关键字 1. **static修饰的成员是在JVM加载类的时候就会被立即分配空间以及初始化 - 只有1次**,内存的实例只有1份 2. 非静态的成员的是在每次创建对象的时候才会被分配空间以及初始化 二、作用 &gt; 1. static修饰符类 - 静态内部类[过] &gt; 2. 修饰的属性 - 静态属性 &gt; 3. 方法 - 静态方法 &gt; 4. 代码块 - 静态代码块三、JVM加载类进内存的活动顺序 0. JVM加载类进内存 1. 给所有的静态属性分配空间以及初始化 2. 给所有的静态方法分配空间以及初始化 3. 调用静态代码块 4. 如果创建了对象 4-1. 给这个对象的所有的非静态属性分配空间以及初始化 4-2. 给这个对象的所有的非静态方法分配空间 4-3. 调用普通代码块 4-4. 调用构造块. PS:静态代码块在类第一次被载入时执行，在这里主要是想验证一下，类初始化的顺序。 ( 父类静态变量 父类静态代码块 子类静态变量 子类静态代码块 父类普通变量 父类普通代码块 父类构造函数 子类普通变量 子类普通代码块 子类构造函数 )四、static关键字应用 &gt; 设计模式 - 单例模式 &gt; &gt; 如何保证某个类的对象在内存中永远只有1份.后期,某些类的创建和销毁的时间成本比较高. 这些类有必要设计成单例的. &gt; &gt; 比如jdbc中的连接池对象[重量级的对象]","categories":[{"name":"设计模式","slug":"设计模式","permalink":"http://example.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"java","slug":"java","permalink":"http://example.com/tags/java/"}]},{"title":"面试经典题","slug":"Interview1","date":"2021-07-30T12:50:20.000Z","updated":"2021-07-31T12:58:57.607Z","comments":true,"path":"2021/07/30/Interview1/","link":"","permalink":"http://example.com/2021/07/30/Interview1/","excerpt":"","text":"面试题HashMap 和 HashTable 区别 HashMap 是 HashTable 的轻量级实现，他们都完成了Map 接口，主要区别在于 HashMap 允许 null key 和 null value,由于非线程安全，效率上可能高于 Hashtable。主要区别如下: HashMap允许将 null 作为一个 entry 的 key 或者 value，而 Hashtable 不允许。 HashMap 把 Hashtable 的 contains 方法去掉了，改成 containsValue 和 containsKey。因为 contains 方法容易让人引起误解。 HashTable 继承自 Dictionary 类，而 HashMap 是 Java1.2 引进的 Map interface 的一个实现。 HashTable 的方法是 Synchronize 的，而 HashMap 不是，在多个线程访问 Hashtable 时，不需要自己为它的方法实现同步，而 HashMap 就必须为之提供外同步。 Hashtable 和 HashMap 采用的 hash/rehash 算法都大概一样，所以性能不会有很大的差异。 ArrayList和LinkedList区别 ArrayList是实现了基于动态数组的数据结构，LinkedList基于链表的数据结构。 对于随机访问get和set，ArrayList觉得优于LinkedList，因为LinkedList要移动指针。 对于新增和删除操作add和remove，LinedList比较占优势，因为ArrayList要移动数据 List和Set区别 两个接口都是继承自Collection，是常用来存放数据项的集合，主要区别如下： List和Set之间很重要的一个区别是是否允许重复元素的存在，在List中允许插入重复的元素，而在Set中不允许重复元素存在。 与元素先后存放顺序有关，List是有序集合，会保留元素插入时的顺序，Set是无序集合。 List可以通过下标来访问，而Set不能。 HashSet和HashMap区别 HashSet的底层是HashMap HashMap HashSet HashMap实现了Map接口 HashSet实现了Set接口 HashMap储存键值对 HashSet仅仅存储对象 使用put()方法将元素放入map中 使用add()方法将元素放入set中 HashMap中使用键对象来计算hashcode值 HashSet使用成员对象来计算hashcode值，对于两个对象来说hashcode可能相同，所以equals()方法用来判断对象的相等性，如果两个对象不同的话，那么返回false HashMap比较快，因为是使用唯一的键来获取对象 HashSet较HashMap来说比较慢 ArrayList和HashSet区别 1.HashSet 是不重复的 而且是无序的! ​ 唯一性保证. 重复对象equals方法返回为true ，重复对象hashCode方法返回相同的整数 ​ HashSet其实就是一个HashMap,只是你只能通过Set接口操作这个HashMap的key部分, 2.ArrayList是可重复的 有序的 ​ 特点：查询效率高，增删效率低 轻量级 线程不安全。 arraylist：在数据的插入和删除方面速度不佳，但是在随意提取方面较快 HashSet和TreeSet区别 一、HashSet HashSet内部的数据结构是哈希表，是线程不安全的。 HashSet当中，保证集合中元素是唯一的方法。 通过对象的hashCode和equals方法来完成对象唯一性的判断。 假如，对象的hashCode值是一样的，那么就要用equals方法进行比较。 假如，结果是true，那么就要视作相同元素，不存。 假如，结果是false，那么就视为不同元素，存储。 注意了，假如，元素要存储到HashCode当中，那么就一定要覆盖hashCode方法以及equals方法。 二、TreeSet TreeSet能够对Set集合当中的元素进行排序，是线程不安全的。 TreeSet当中，判断元素唯一性的方法是依据比较方法的返回结果是否为0，假如是0，那么是相同的元素，不存，假如不是0，那么就是不同的元素，存储。 TreeSet对元素进行排序的方式： 1、元素自身具备比较功能，也就是自然排序，需要实现Comparable接口，并覆盖其compareTo方法。 2、元素自身不具备比较功能，那么就要实现Comparator接口，并覆盖其compare方法。 除此之外，还要注意了，LinkedHashSet是一种有序的Set集合。 也就是其元素的存入和输出的顺序是相同的。 HashMap和TreeMap区别 HashMap的底层是Array，所以HashMap在添加，查找，删除等方法上面速度会非常快。而TreeMap的底层是一个Tree结构，所以速度会比较慢。 另外HashMap因为要保存一个Array，所以会造成空间的浪费，而TreeMap只保存要保持的节点，所以占用的空间比较小。 HashMap如果出现hash冲突的话，效率会变差，不过在java 8进行TreeNode转换之后，效率有很大的提升。 TreeMap在添加和删除节点的时候会进行重排序，会对性能有所影响。 ArrayList和Vector区别 Vector是线程安全的，ArrayList不是线程安全的。 ArrayList在底层数组不够用时在原来的基础上扩展0.5倍，Vector是扩展1倍。","categories":[{"name":"Interview","slug":"Interview","permalink":"http://example.com/categories/Interview/"}],"tags":[{"name":"Interview","slug":"Interview","permalink":"http://example.com/tags/Interview/"}]},{"title":"分支语句","slug":"java003","date":"2021-07-19T12:07:25.000Z","updated":"2021-08-01T10:40:45.908Z","comments":true,"path":"2021/07/19/java003/","link":"","permalink":"http://example.com/2021/07/19/java003/","excerpt":"","text":"方法的重载(@overload) 前提: 重载的方法是存在于同一个类中 [前提] 重载的方法的方法名必须相同 重载的方法的参数列表必须不相同 重载的方法的返回类型可以不一样,可以一样 1234567891011121314public class LoadMethodDemo &#123; public static void main(String[] args) &#123; add(20); &#125; public static int add()&#123; System.out.println(&quot;add -&gt; 100&quot;); return 100; &#125; public static void add(int i)&#123; System.out.println(i); &#125;&#125; 优点就是简化api - 方便调用的. 学会使用api 通过学习java.lang.Math - 数学工具类 - 提供了很多关于数学计算的方式. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051package tech.aistar.day03;/** * 本类用来演示: java.lang.Math * * @author: success * @date: 2021/7/19 8:59 上午 */public class MathDemo &#123; public static void main(String[] args) &#123; //绝对值 int n = Math.abs(-10); System.out.println(n); //求随机数 - 伪随机的 //static double random();//[0.0,1.0)之间的随机小数 System.out.println(Math.random()); //[1,100]之间随机的整数 int result = (int) (Math.random()*100+1);//[1,100] System.out.println(result); //[3,5]之间的随机整数 int m = (int) (Math.random()*3+3); System.out.println(m); //求俩个数中的最大值/最小值 System.out.println(Math.max(10,20));//20 //笔试填空题 - //返回小于或等于参数的最大（最接近正无穷大） double值，等于一个数学整数。 //floor方法. System.out.println(Math.floor(3.5));//3.0 System.out.println(Math.floor(4.0));//4.0 System.out.println(Math.floor(-3.5));//-4.0 //返回参数中最接近的 long ，其中 long四舍五入为正无穷大。 //Math.floor(a + 1/2) System.out.println(Math.round(-3.5)); //开根 System.out.println(Math.sqrt(9));//3.0 //次方 System.out.println((int)Math.pow(2,3));//8 &#125;&#125; 语句三元操作符 三目运算符 条件表达式 ? result1 : result2 表达式为true,结果就是result1,否则结果是result2 支持无限嵌套的 - 但是不推荐,可读性差 m ? (表达式?result1:result2):result2 if…else.. if语句单独使用场景 123if(条件)&#123;//成立 //code...&#125; {}可以省略的场景 1234if(条件) //code...如果if&#123;&#125;中的代码只有1行,那么&#123;&#125;可以省略,但是一定要缩进 if…else…使用 1234567891011if(条件)&#123; //条件成立&#125;else&#123; //条件不成立&#125;//如果语句仍然只有一行,&#123;&#125;还是可以省略的if(条件) //codeelse //code.. 多条件分支if…else if…else..if … else… 注意条件是互斥的 123456789if(条件)&#123; //条件成立&#125;else if(条件)&#123; //条件不成立&#125;else if(条件)&#123; //code&#125;else&#123; //code..&#125; if..else语句可以无限嵌套使用 1234567891011121314151617181920212223if(条件)&#123; //条件成立 if(条件)&#123; &#125;else&#123; &#125;&#125;else if(条件)&#123; //条件不成立 if(条件)&#123; //条件成立 &#125;else if(条件)&#123; //条件不成立 &#125;else if(条件)&#123; //code &#125;else&#123; //code.. &#125;&#125;else if(条件)&#123; //code&#125;else&#123; //code..&#125; 习题 买奶茶,每第二杯半价,单价是10元.求总价. 110 5 10 5 10 求某年某月最大天数 switch..case 没有if..else if..else灵活 语法: 1234567891011121314151617switch(变量)/ /byte short int char String enum[枚举类型] //包装类型Byte Short Integer Charactercase 值1: //code [break];case 值2: //code [break];case 值3: //code [break];[default: //code.. [break];]&#125; 当switch括号中的变量能够匹配到某个case后面的值的时候,那么就会进入到对应的case中去执行里面的程序 进入到某个case块中执行的过程中,只有遇到break语句才会跳出switch块.如果没有遇到break语句,那么程序会 自动进入到下一个case块中去执行. default语句可以省略,也是可以随便放的,推荐放在末尾.如果switch括号中的变量没有匹配到任何的case后面的值 的时候,那么就会进入到default 循环语句while 属于后置循环 - 先判断循环条件是否成立,如果成立,则进入到循环体中,否则不执行循环. 使用场景:当不知道循环多少次,但是知道循环退出的条件的时候 - 优先选择while循环. 语法: while(条件){ ​ // 循环体… } 12345678910111213141516171819202122232425262728293031323334353637package tech.aistar.day03;/** * 本类用来演示: while循环 * * @author: success * @date: 2021/7/19 10:53 上午 */public class WhileDemo &#123; public static void main(String[] args) &#123; //while可以代替for的使用 //&#x27;a&#x27;-&#x27;z&#x27; char c = &#x27;a&#x27;; while(c &lt;= &#x27;z&#x27;)&#123; System.out.println(c); c++; &#125; System.out.println(&quot;=====&quot;); //&#x27;A&#x27; - &#x27;Z&#x27; int n = 65; while(n&lt;=90)&#123;//退出的条件 System.out.println((char)n); n++; &#125; //1-10 int m = 1; //死循环... while(true)&#123; //死循环的内部一定要有打破循环的语句 - break System.out.println(m); if(m==10) // 循环退出的条件 break; m++; &#125; &#125;&#125; 练习 求俩个数的最大公约数 12345思路:20 12 -&gt; 4 20 % 12 = 8 12 % 8 = 4 8 % 4 = 0 十进制转换二进制 1 for循环 属于后置循环 单层for 1234567891011for(①表达式1;②表达式2;③表达式3)&#123; //④循环体&#125;①表达式1 - 循环过程中的变量的初始化操作.比如int i = 0; - 仅仅只会执行1次.②表达式2 - 循环退出的条件.比如 i&lt;=10 - 至少执行1次③表达式3 - 循环过程中,变量因子的变化.i++ - 有可能是不执行,可能执行执行顺序①-②[成立]-④-③-②[成立]-④-③..... 怪异的写法 1234for(;;)&#123; //死循环 - break打破循环的语句&#125;三个表达式都是可以任意的省略不写,或者写到其他地方 for循环的复合形态 123for(同时定义若干个变量;条件;表达式)&#123; //循环体...&#125; 嵌套for循环,嵌套的层数不建议超过三层.嵌套越多,性能越低. 2-1. 内外层无关 - 里面的for选中的使用可以单独执行.没有使用到外面for的循环的变量因子的. 2-2. 内外层相关 - 里面的for使用到了外面for循环的变量因子的 练习 - 打印所有的三位数.三位数由数字1,2,3,4组成.但是不能出现重复的. 每打印4个换一行 12345678910111213141516171819202122232425262728293031323334353637package tech.aistar.day03; /** * 本类用来演示: * 练习 - 打印所有的三位数.三位数由数字1,2,3,4组成.但是不能出现重复的. * * 每打印4个换一行 * * @author: success * @date: 2021/7/19 2:26 下午 */public class ForExerciseDemo &#123; public static void main(String[] args) &#123; //定义一个计数器 int count = 0; for (int x = 1; x &lt;=4 ; x++) &#123; for (int y = 1; y &lt;=4; y++) &#123; for (int z = 1; z &lt;=4; z++) &#123;// System.out.print(x+&quot;&quot;+y+z); if(x!=y &amp; x!=z &amp; y!=z)&#123; System.out.print(x*100+y*10+z+&quot;\\t&quot;); count++;// if(count % 4==0)&#123;// System.out.println();// &#125; if(count == 4)&#123; System.out.println(); count = 0; &#125; &#125; &#125; &#125; &#125; &#125;&#125; do..while.. 属于前置循环 - 无论循环条件是否成立,优先先进入到循环体中执行一次. 然后再进行判断条件,决定下一次是否再次进入. do{ //循环体… }while(条件); break语句 break可以跳出swtich块 break可以打破它所在的那一层循环 continue语句 出现在循环体中 跳过本轮循环,继续执行下一轮循环. 数组 数组的诞生 - 为了解决单个变量只能存储单个值的缺点. 数组本身也是属于数据结构[数组,栈,堆,树[红黑树],链表,图…] 数组是属于对象类型,数组是存在在JVM内存的堆区,基本类型存储在JVM内存的栈区 数组在内存中一定是一块连续的空间. 数组的大小[长度,数组中存放的数据的个数]一旦确定了,不能改变. 语法1234567891. 元素类型[] 变量名 = new 元素类型[size];//size数组的大小2. 元素类型 变量名[] = new 元素类型[size];//元素类型就是数据类型[8种基本数据类型,以及对象类型]作用 - 元素类型决定了这个数组中可以存放的数据的类型//arr的数据类型是什么?int[] -&gt; 整数型数组// &quot;定义一个长度为3的int型数组&quot;int[] arr = new int[3]; 赋值方式 如果定义了数组,但是没有进行赋值操作,那么系统会默认分配一个默认值 默认值根据元素类型来决定了. byte,short,int,long -&gt; 0 float,double -&gt; 0.0 boolean -&gt; false char -&gt; 空格 对象类型 -&gt; null 先定义数组,然后通过下标一一赋值 123456int[] arr = new int[3];//数组的下标从[0,数组长度-1]范围//如果下标不在此范围,控制台抛出java.lang.ArrayIndexOutOfBoundsException 数组下标越界异常arr[0] = 10;arr[1] = 10;arr[2] = 10; 定义数组的同时进行赋值 1int[] arr = &#123;3,4,5&#125;; 定义数组的同时进行赋值 1int[] arr = new int[]&#123;3,4,5&#125;; 通过普通for去赋值 1234int[] arr = new int[3];for(int i=0;i&lt;arr.length;i++)&#123; arr[i] = (int)(Math.random()*100+1);&#125; 数组的遍历 通过下标一一取值 1System.out.println(arr[下标]); 数组提供了属性length - 获取数组的长度 通过普通for循环进行遍历 123for (int i = 0; i &lt; arr.length; i++) &#123; System.out.println(arr[i]);&#125; 使用jdk5.x提供的增强for循环的语法 属于只读的for 1234567int[] arr2 = &#123;3,4,5&#125;;for(元素类型 元素变量:数组变量名)&#123; System.out.println(元素);&#125;for(int e:arr2)&#123;//此处的e不是代表下标,就是代表真正的元素 System.out.println(e);&#125; 拓展 - 数组的内存123456789101112131415//通过new关键字在Jvm的堆中开辟新的空间01,用来存储这个对象&#123;10,20,30&#125;//然后将这个对象在堆空间中的内存地址赋值给了引用变量arr1[存储在栈]//&quot;结论&quot; - arr1的本质不是对象,只是一个引用变量而已//&quot;结论&quot; - 引用和对象之间的关系// 引用变量中存储的就是对象在堆空间中的内存地址// &quot;气球理论&quot; - 一个引用变量在同一个时刻,只能指向一个对象// - &quot;一个对象可以在同一个时刻被多个引用指向&quot;int[] arr1 = new int[]&#123;10,20,30&#125;;//通过new关键字在Jvm的堆中开辟新的空间02,用来存储这个对象&#123;10,20,30&#125;int[] arr2 = &#123;10,20,30&#125;;arr1 = arr2;//arr1和arr2都是指向第二次创建出来的数组对象 //原来第一次创建出来的对象就成为内存中的垃圾对象 - GC[垃圾回收线程进行回收,释放内存] //&quot;垃圾对象&quot; - 没有任何引用指向的对象 拓展 - 方法的参数传递方式 基本类型采用值传递 对象类型[引用类型]采用地址传递 总结:**Java中只有值传递,没有地址传递.**比较特殊的是String类型[虽然是一个对象类型,但是具备基本类型传递的特点]","categories":[{"name":"java基础语法","slug":"java基础语法","permalink":"http://example.com/categories/java%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/"}],"tags":[{"name":"java","slug":"java","permalink":"http://example.com/tags/java/"}]},{"title":"定义变量+修饰符all","slug":"Operator","date":"2021-07-16T12:33:36.000Z","updated":"2021-08-01T10:42:00.189Z","comments":true,"path":"2021/07/16/Operator/","link":"","permalink":"http://example.com/2021/07/16/Operator/","excerpt":"","text":"变量的定义和使用123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101package stu.aistar.day02;import java.util.Date;/** * 本类用来演示: 变量的定义和使用 */public class VarInitDemo &#123; public static void main(String[] args) &#123; byte b = 127; short s = 100;//使用频率很少 //开发中常用的整数型类型 - int,long //int类型可以初始化的值有哪些 int a = 100; //存储一个二进制,只要0b二进制,1010对应的十进制 //java中的int类型表示的是十进制的数据 //1010 = 1*2^3+1+2^1 = 10 int a1 = 0b1010; System.out.println(a1); //java中使用单引号来表示一个字符 //&#x27;a&#x27;-&gt;char类型-&gt;int类型 //&#x27;a&#x27;对应的ascii码97 //&#x27;A&#x27;对应的ascii码是65 //&#x27;0&#x27;对应的ascii码是48 int a2 = &#x27;a&#x27;; System.out.println(a2); //java中以0开头的代表是八进制 //八进制转换十进制032 = 3*8^1 + 2*8^0 = 26 int a3 = 032; System.out.println(a3);//26 //长整型 - long //int类型-&gt;long类型 long x1 = 100; //推荐定义long的方式采用隐式转换 long x2 = 200L; //jdk7.x提供的 - 为了增强数字的可读性而已. long x3 = 3_14_15_926L; System.out.println(x3);// Date date = new Date(3L*24*60*60*100*1000*1000*2000);// System.out.println(date); //浮点数 - 并不是用来进行精确计算的 //后面java.math.Decimal类解决小数计算的时候精度丢失的问题. double d = 1.75; //推荐定义double double d2 = 5.67D; //float的精度是7或者8 //double的精度是16 //double类型强制转换成float类型 float f = (float) 3.14; //隐式转换 float f2 = 3.14F; System.out.println(f2); //补充 //数字进行计算的时候,都会转换成二进制进行计算 //小数进行计算的时候,还是不可逆的 //0.8999999999999999 System.out.println(2.0-1.1); //0.9 System.out.println(2.0f - 1.1f); //int-&gt;float × //int-&gt;double √ int n = 123456789; float ft = n; System.out.println(ft);//1.23456792E8 double db = n; System.out.println(db);//1.23456789E8 float f3 = 1.234567565f; System.out.println(f3);//1.2345675 //定义布尔类型 boolean flag = true; System.out.println(flag); //最特殊的是char类型 char c = 65; System.out.println(c); &#125;&#125; char类型 java中是使用单引号表示char类型,使用双引号来表示字符串. java的底层的编码是unicode编码,char类型也是采用unicode编码 unicode编码是双字节[16bit],所以存储一个汉字. ascii码和unicode码的关系? 不同的国家,符号表示的方式不同,所以ascii码[0127]不够用.所以unicode[065535]码诞生了,几乎 包含了所有国家的符号,unicode码包含ascii码.char类型在进行计算的时候会转换成ascii码来进行计算. 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748package tech.aistar.day02;/** * 本类用来演示: char类型 * * @author: success * @date: 2021/7/16 9:14 上午 */public class CharDemo &#123; public static void main(String[] args) &#123; //java中是使用单引号表示char类型 //char的空间大小也是确定的 char c = &#x27;a&#x27;; System.out.println(c); //十六进制 //由数字0-9或者字母a-f/A-F,字母a代表就是数字10 //cmd - 输入native2ascii -&gt; 输入中文 char c2 = &#x27;\\u34af&#x27;; System.out.println(c2); //char底层采用的是unicode编码,所以存储一个汉字 char c3 = &#x27;星&#x27;; System.out.println(c3); char c4 = 48; System.out.println(c4); int m = 48; char c5 = (char) m; System.out.println(c5); //char类型在进行计算的时候会转换成ascii码来进行计算. //&#x27;a&#x27; = 97,&#x27;A&#x27; = 65,&#x27;0&#x27; = 48 //char类型的计算 - 进阶部分 char n1 = &#x27;a&#x27; + 1;//ok System.out.println(n1);// &#x27;b&#x27; char cc = &#x27;a&#x27;; char nn = (char) (cc + 1); System.out.println(cc); //char-&gt;int int result = &#x27;a&#x27; + &#x27;b&#x27;;//ok System.out.println(result);//195 &#125;&#125; 变量的赋值方式 单个赋值 int a = 10; 通过表达式赋值 1234int a = 10;int b = 20;//表达式:由字面量或者变量以及运算符号组成的合法的语句int result = a + b; 链式赋值 123int a=10,b=20,c=30;//同时声明了三个变量,并且都进行初始化int a,b,c = 100;//此处仅仅是对c进行赋值操作,如果一个局部变量没有进行赋值,那么将不能够使用 可以先定义变量,然后再进行赋值 1234int a;a = 10;a = 20;System.out.println(a); 通过方法进行赋值 - 暂时了解 12345678910int result = getResult(); /** * 自定义了一个方法 - 千万不要将它放在main方法中 * java语法 - 方法体内部是不能够再去定义方法的 * @return 整数 */public static int getResult()&#123; return 100;&#125; 变量的分类 局部变量 - 定义在方法体内部 使用的范围就是在它所在的最近的那个{}中 全局变量 - 定义在方法体外部的变量 生命周期 - 面向对象 常量 使用final修饰的变量 - 常量 - 不可改变的量 语法 1final 数据类型 变量 [= 初始值]; 123456789101112131415161718192021222324252627282930313233343536373839404142434445package tech.aistar.day02;/** * 本类用来演示: 局部变量和全局变量 * * @author: success * @date: 2021/7/16 10:04 上午 */public class LocalVarAndGlobalDemo &#123; //定义全部变量 static int c = 100;//静态变量 - 暂不了解 public static void main(String[] args) &#123; //代码块 //局部变量 - 定义在方法体内部 int a= 10; &#123;// 使用的范围就是在它所在的最近的那个&#123;&#125;中 int b = 20; System.out.println(a);//ok System.out.println(b);//ok &#125; //使用的范围就是在它所在的最近的那个&#123;&#125;中 //System.out.println(b);//error //访问全局变量 System.out.println(c); //定义一个常量 - 不可改变的量 final int s = 100; //s = 200; //final - b肯定不可变 final byte b = 100; byte result = b + 1;//ok &#125;&#125; 运算符算术运算符12345678910111213141516171819201. + java语言中唯一重载[具有多个意义]的运算符 数值之间表示的加法运算,如果出现了&quot;字符串&quot;,表示拼接[后面就会知道拼接效率很低] 2. - 减法 * 乘法 3. / 除法[配合计算过程中需要注意的结果的类型而已] - 取整 4. % 取余/模 /和%结合使用,可以获取某个数字任意位上的数值. 5. += -= *= /= %= 未来知道:开发中尽量不要使用,不是一个原子操作,导致多线程不安全. 底层会判断是否需要进行一个类型的窄化操作[类型的强制转换操作] 6. ++和-- 前++/后++ - 变量本身都会自增1 前--/后-- - 变量本身都会自减1 未来知道:开发中尽量不要使用,不是一个原子操作,导致多线程不安全. 底层会判断是否需要进行一个类型的窄化操作[类型的强制转换操作] 比较运算符12&gt; &lt;= &gt;= &lt; !=比较得到的结果是一个boolean类型即可 逻辑运算符 &amp;&amp; - 逻辑与,短路与.作用不是用来进行计算的,而是用来连接条件[多个,条件表达式(包含比较运算符)]的. 为true - 所有的条件表达式都是返回true 短路的特性:当左边的条件表达式已经能够决定整个结果了,那么后面的条件表达式将不会执行. 推荐:将条件表达式结果最有可能为false的放在最左边 - 提高代码的执行效率. || - 逻辑或,短路或.作用不是用来进行计算的,而是用来连接条件[多个,条件表达式(包含比较运算符)]的. 为true - 只要有一个表达式是true,那么结果就是true 短路的特性:当左边的条件表达式已经能够决定整个结果了,那么后面的条件表达式将不会执行. 推荐:将条件表达式结果最有可能为true的放在最左边 - 提高代码的执行效率. ! - 逻辑非,true成为false,false成为true 位运算符 &amp; - 按位&amp;,非短路与,最主要的作用就是用来计算的,但是可以用来连接条件表达式. ​ 计算:都是1,结果才是1.只要出现1个0,那么结果就是0 ​ 连接条件:为true - 所有的条件表达式都是返回true 1234567891011121310 &amp; 8 = 8 十进制的数不断除以2,直到商为0,然后倒过来取余数 - 101010 / 2 = 商5......余05 / 2 = 商2 ...... 12/ 2 = 1 ........ 01/2 = 0 .........1 1 0 1 0 &amp; 1 0 0 0------------------ 1 0 0 0 -&gt; 对应的十进制8 | - 按位或,非短路或,最主要的作用就是用来计算的,但是可以用来连接条件表达式. 计算:只要存在一个1,结果就是1 连接条件:为true - 只要存在一个条件表达式为true. 123456710 | 8 = ? 1 0 1 0| 1 0 0 0------------------ 1 0 1 0 -&gt; 对应的十进制10 异或^ 作用:进行计算的 - 相同为0,不同为1 12345610 ^ 8 = 2 1 0 1 0 | 1 0 0 0------------------ 0 0 1 0 -&gt; 2 10 ^ 8 ^ 8 = 10 12340 0 1 0 1 0 0 0----------------- 1 0 1 0 -&gt; 10 结论:一个数字连续异或同一个数字俩次结果是它本身. 可以进行加密和解密的操作 123456789101112131415161718192021222324252627282930313233343536373839404142笔试题: 交换俩个变量的值,不允许出现第三方变量package tech.aistar.day02; /** * 本类用来演示: 笔试题: 交换俩个变量的值,不允许出现第三方变量 * * @author: success * @date: 2021/7/16 11:09 上午 */public class ChangeVarValue &#123; public static void main(String[] args) &#123; //1. 使用第三方变量 int a = 10; int b = 20; int temp = a; a = b; b = temp; System.out.println(&quot;a:&quot;+a); System.out.println(&quot;b:&quot;+b); //一个数字连续异或同一个数字俩次结果是它本身. int m = 100; int n = 200; m = m ^ n;//m = 100 ^ 200 n = m ^ n;//n = 100 ^ 200 ^ 200 = 100 m = m ^ n;//m = 100 ^ 200 ^ 100 = 200 System.out.println(&quot;m:&quot;+m); System.out.println(&quot;n:&quot;+n); //自创写法(success独家的) - 不推荐写 - 防止菜鸟看不懂 int x = 100; int y = 200; //y = 100 ^ 200 ^ 200 = 100 y = x ^ (x = y) ^ y; System.out.println(&quot;x:&quot;+x); System.out.println(&quot;y:&quot;+y); &#125;&#125; 取反~,1变0,0变成1 补码 - 负数在计算机中的表现形式就是以补码的形式存在的 123456789101112131415161718192021222324252627282930补码 = 反码 + 1;反码 = 原码符号位不变,其余位依次取反符号位 - 最高位代表的是符号位.1代表的是负数,0代表的是正数.反码本身没有意义的,它的存在就是为了计算补码正数的补码,反码,原码都是它本身.计算一下:-10的二进制是多少?-10的补码是多少?计算步骤:1. -10原码 10000000 00000000 00000000 000010102. -10的反码 10000000 00000000 00000000 00001010 11111111 11111111 11111111 111101013. -10的补码 = 反码+1 11111111 11111111 11111111 11110101 + 1 ------------------------------------- 11111111 11111111 11111111 11110110 -&gt; -10的二进制计算~900000000 00000000 00000000 0000100111111111 11111111 11111111 11110110 -&gt; ~9取反的结果-10 = ~9结论:-(x+1) = ~x 移位操作 笔试题 - 计算性能最高的操作,jdk源码里面很多都是移位操作 12345678910111213141516171819&lt;&lt; 向左移动2&lt;&lt;2 =&gt; 0010 &lt;&lt; 2 = 1000 = 8原题:请你用最高性能的方式计算出2的3次方.&gt;&gt; 带符号的右移动,向右移动多少位,那么就在最高位补符号位-10 &gt;&gt; 2 = -311111111 11111111 11111111 11110110 &gt;&gt; 211111111 11111111 11111111 11111101 -&gt; 负数的二进制,最高位是100000000 00000000 00000000 00000010 取反 ~2=-3&gt;&gt;&gt; 不带符号的右移动,向右移动多少位,就在最高位补0 -10 &gt;&gt;&gt; 2 11111111 11111111 11111111 11110110 &gt;&gt; 2 00111111 11111111 11111111 11111101 -&gt; 计算出十进制 01000000 00000000 00000000 00000000 - 3----------------------------------------- 1073741821 练习-15&gt;&gt;2 -15&gt;&gt;&gt;2 -15 = ~14 11111111…… 0001 &gt;&gt;&gt; 2 00111111 11111111 11111111 11111101 00111111 11111111 11111111 1111100 = 1073741820 方法 - Method 非常重要,如果没有跟上,直接出局. 相当于其他语言中函数function,功能是用来封装代码的逻辑. 把一段代码封装到方法中,方便以后复用,提高了代码的可维护性. 语法1234修饰符 返回类型 方法名([参数列表]) [throws 可抛出的异常列表]&#123;..方法体...&#125;现阶段:修饰符 返回类型 方法名([参数列表])&#123;..方法体...&#125; 修饰符访问修饰符 作用:就是决定了这个方法可以被调用的范围. public - 公开的,公共的.如果一个方法被public进行了修饰,那么代表这个方法可以在别的地方被调用. private - 私有的,只能在当前类内部被调用 - 体现了”封装性” - 不对外公开的. 默认的 受保护的 特殊修饰符[超纲的内容] static - 静态的 如果使用static修饰的方法 - 静态方法 如果没有使用static修饰的方法 - 非静态方法 是否为静态的方法决定了这个方法被调用的方式. 返回类型 有返回类型 可以是八种基本数据类型,也可以是对象类型[内置对象类型或者自定义对象类型] 方法体的最终的出口一定有return 返回值. 12345678return 作用1 - 返回方法最终的执行结果 作用2 - 用来结束整个方法正常情况方法的返回类型是什么,返回值的结果的类型也应该是什么非正常情况 - 支持类型的自动转换和强制类型转换的.调用的时候 - 需要使用数据类型和变量来接受这个方法调用的结果. 方法的返回类型是什么,就用什么类型去定义.当然也是支持类型的转换 无返回类型 - void 1不需要使用return + 返回值; 该如何选择? 如果某个方法的执行结果可能在另外一个地方被使用到,那么一定要定义成有返回类型 如果一个方法仅仅是为了输出,只要定义void 12public static int test01(int m,int n)&#123; //code... return m和n的最大公约数 //System.out.println(公约数) } //int m = test01(20,12);//m-&gt;4 public static int test02(int m,int n){ int 公约数 = test01(m,n); return mn/公约数; } int n = test02(20,12);//n-&gt;60=2012/4=60 1 方法名 参考变量名的命名规则 - 一模一样 标识符 - 给类,包,变量,方法取的名称 参数列表 无参列表 带参列表 可变长列表 该如何定义方法 方法体内部不能够再去定义方法了 main方法仍然是程序的主入口. 自定义的方法希望能够被调用,那么最终肯定是在main方法中进行调用的 方法的调用方式 取决于这个方法是静态的还是非静态的 - static 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253package tech.aistar.day02.method;/** * 本类用来演示: 方法的定义 * * @author: success * @date: 2021/7/16 2:20 下午 */public class MethodHelloDemo &#123; /** * main - 仍然是程序的主入口 * @param args */ public static void main(String[] args) &#123; //类中的方法 - 类里面的成员 //static - 静态的成员被初始化的时机 //静态方法什么时候被初始化的? - 当JVM加载类进内存的时候,就会立即给所有的静态的成员分配空间以及初始化 //在这个阶段,压根就没有对象的概念,只有类. //结论 - 静态的成员属于类的,并且初始化的时机有且1次. //属于谁,就由谁去调用! //1. 调用静态的方法,直接通过类.方法名([参数]) //类 - 该静态方法所在的当前类 MethodHelloDemo.sub(); //non-static -&gt; 非静态的成员被初始化的时机? //当遇到创建对象的语法.每次创建对象的时候,都会给各自的非静态成员分配空间以及初始化 //如果没有创建对象,就不会初始化这些非静态成员. //结论: 非静态成员是属于对象的.属于谁,由谁调用. //2. 非静态方法 - 通过对象去调用 //调用哪个类中的方法,就去创建哪个类的对象 //后面的OO知识点 -&gt; 类名 变量 = new 类名(); //创建了一个 MethodHelloDemo对象,m就是对象名 MethodHelloDemo m = new MethodHelloDemo(); m.add(); &#125; /** * 定义了公开的非静态的无返回类型的方法 */ public void add()&#123; System.out.println(&quot;add...&quot;); &#125; /** * 定义了公开的静态的无返回类型的方法 */ public static void sub()&#123; System.out.println(&quot;sub...&quot;); &#125;&#125; 静态方法中只能够直接调用静态方法 非静态方法中可以直接调用非静态方法以及静态方法 通用的原则 - 类名.静态方法或者对象.非静态方法 静态方法属于类拥有的,非静态方法属于对象拥有的 静态的方法是jvm加载类进内存的时候就会立即被分配空间以及初始化,并且机会仅仅只有1次. 而非静态方法必须是等到创建对象的时候,才会被分配空间以及初始化 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475&gt;package tech.aistar.day02.method;&gt;/**&gt;* 本类用来演示:&gt;*&gt;* @author: success&gt;* @date: 2021/7/16 2:43 下午&gt;*/&gt;public class StaticDetailDemo &#123; //定义了全局变量 //属性,方法 =&gt; 成员 //非静态的属性 int n = 10;//等创建对象的时候,才会分配空间和初始化 //静态属性-初始化的时机优先于静态方法 static int m = 100; public static void main(String[] args) &#123; //此时n还未初始化 //System.out.println(n);//编译错误 //System.out.println(m); //调用test03 - 非静态的 StaticDetailDemo s = new StaticDetailDemo(); s.test03(); System.out.println(s); &#125; //非静态的 public void test01()&#123; System.out.println(&quot;test01..&quot;); &#125; //静态的 public static void test02()&#123; int n = 10; System.out.println(&quot;test02...&quot;); //自定义的方法中是可以调用自己自定义的方法的 //1. 另外一个静态方法test04 StaticDetailDemo.test04(); //静态方法中可以直接调用静态方法 test04(); //2. 另外一个非静态方法test03 StaticDetailDemo s1 = new StaticDetailDemo(); s1.test03(); &#125; public void test03()&#123; //static int n = 20;//非静态方法中不允许定义静态的局部变量 System.out.println(&quot;test03..&quot;); //非静态方法中调用静态方法 - 类名.方法 //StaticDetailDemo.test04();//ok test04();//ok //非静态方法中直接调用另外一个非静态方法呢??? - 肯定是需要一个对象去调用. test01();//ok //实际上省略了一个关键字this //this代表的是当前对象 //当前对象 - 调用该方法[test03]的对象 //this.test01(); System.out.println(this); &#125; public static void test04()&#123; System.out.println(&quot;test04..&quot;); &#125;&gt;&#125; 方法调用补充 方法的调用者和方法的定义者在同一个类中. 方法的调用者和方法的定义者不在同一个类中,但是仍然在同一个package中. 只能使用通用的原则类名.静态方法或者对象.非静态方法 方法的调用者和方法的定义者是存在于不同包下的不同类中. 必须先通过import关键字进行导包操作. 使用jdk中的类的时候,除了java.lang包下的不需要手动import,其余包下的都需要先import 递归算法 - 错误的写法 - 方法内部直接调用自己 private 和 public 该选择使用123456789101112131415161718192021222324252627public class 牛叉的工具类&#123; public static void 牛叉的方法01()&#123; //肯定是会被外面的人调用的... //内部的代码的业务逻辑非常负责,由很多小的功能组成的 小的牛叉方法01(); //... //.. //... &#125; private static void 小的牛叉方法01()&#123; //专门封装了小的功能. &#125; public static void 牛叉的方法02()&#123; //肯定是会被外面的人调用的... //内部的代码的业务逻辑非常负责,由很多小的功能组成的 小的牛叉方法01(); //... //... //... &#125;&#125;","categories":[{"name":"java基础语法","slug":"java基础语法","permalink":"http://example.com/categories/java%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/"}],"tags":[{"name":"java","slug":"java","permalink":"http://example.com/tags/java/"}]},{"title":"java开发历史+数据类型","slug":"origin","date":"2021-07-15T12:58:04.000Z","updated":"2021-08-01T10:40:56.487Z","comments":true,"path":"2021/07/15/origin/","link":"","permalink":"http://example.com/2021/07/15/origin/","excerpt":"","text":"Java的历史 原先是属于SUN公司[Standford University Network 斯坦福网络大学] Sun Microsystem -太阳微电子公司 后来在2010年10月份被Oracle公司[出名的产品 -oracle数据库 - NO.1] 74亿美金收购 - www.oracle.com 前身Oak语言[橡树]，印度尼西亚的爪哇岛[咖啡豆 - javabean] 诞生于1995年5月23日，96年正式推出jdk1.0版本 商用的jdk版本 - jdk8.x，jdk11.x，jdk16.x java之父-james gosling 詹姆斯 高斯林 Java支持的三个平台原先的名称j2se，j2ee，j2me JavaSE - Java Standard Editional - Java标准版 适合做桌面应用程序[维护比较麻烦,服务器端如果更新,客户端需要更新],包含了java里面的基础的语法,核心 JavaEE - 2018年 - JakartaEE - 雅佳达EE - Java Enterprise Editional - Java企业版 是一套技术的规范的体系.不是一门具体的技术.里面包含了13种核心技术 比如jdbc,servlet等遵守javaee的规范.现在javaee里面的核心技术已经使用不多了 现在普遍都在使用spring全家桶中的技术. 适合做web应用程序[web网站] JavaME - Java Micro Editional - Java微型版,适合做手持设备 - “不用” 检测JDK的环境变量是否配置成功12345C:\\Users\\ASUS&gt; java -version java version &quot;1.8.0_66&quot;Java(TM) SE Runtime Environment (build 1.8.0_66-b17)Java HotSpot(TM) 64-Bit Server VM (build 25.66-b17, mixed mode) 环境变量的配置 Java.zip - 解压缩 - 比如放在D盘 所有的软件不要放在中文目录下,不要放在带有特殊符号的目录下[programe files(x86)] 尽量不要放在C盘[权限的问题,拒绝你的访问的] 桌面 - 右击计算机 - 属性 - 高级系统设置 - 环境变量(N) - 定位到系统变量 新建 变量名:JAVA_HOME 变量值:jdk1.8.0_66的绝对路径 确定 找到内置的变量名Path - 编辑 - 新建 %JAVA_HOME%\\bin 关闭刚所有打开的设置窗口,重新打开终端[黑窗口] win+r - cmd -&gt;输入 java -version Java语言特点 简单 可移植性 面向对象 - 核心 与平台无关性 [跨平台性，跨操作系统平台] 安全性 - 本身就是属于强类型的语言，在编译期间就要确定数据的类型。 JDK 和 JRE 和 JVM JDK - Java Development Kit - Java开发工具包,针对于开发者的.包含了很多开发工具 比如java.exe , javac.exe, javadoc.exe , jar.exe等 JDK中是包含JRE的 JRE - Java Runtime Enviroment - Java运行时环境,包含了很多核心的内库. 针对于使用java语言开发出来软件的用户.如果一个用户仅仅想运行一个java程序的话 那么计算机中只需要安装jre即可. JRE包含JVM JVM - Java Virtual Machine - Java虚拟机 - 后期重点详细介绍jvm[笔试的大头 - 内存模型] jvm本身就是用C语言编写的 - jvm的源码通读一遍. java程序并不是直接在计算机中进行跑的.而是在虚拟机上执行的.虚拟机是安装在操作系统上的. 注意的是java语言是跨平台的[使用java语言编写的程序可以运行在不同的os上],但是jvm不是跨平台的 不同的操作系统需要安装不同的jvm HelloWorld程序 java的基础单元是类class 类的命名 - 标识符的命名 只能由字母,数字,下划线,$符号组成,但是不能以数字开头 推荐使用”大驼峰”命名规则,单词首字母必须要大写.其余单词小写 不能是jdk中内置的对象类型[String,System] 不能是java中的一些关键字,关键字[java语言赋予了这些单词具备一定的语法含义] byte,short,int,long,float,double,char,boolean,if,for,else,while,break,continue,class, public,private,protected等 不能是java中的保留关键字 - goto,const 不推荐使用中文,防止出现乱码问题. 不推荐使用中文的拼音 推荐见名知意 代码 在D盘根目下新建一个文件HelloWorld.java java的源文件就是以.java为后缀的文件 记事本打开HelloWorld.java文件 12345678910111213141516171819//编程语言中,只要出现了符号,一定必须都是英文输入法下的//整体的结构//java是以类作为基础的单位的 - 定义类//关键是class//类的名称要和文件的名称高度保持一致//&#123;&#125; - block - 块 - 代码块public class HelloWorld&#123;//1. 类 //规范 - 缩进四个空格 //定义一个main方法 - 程序的&quot;大门&quot; //运行该程序的时候,jvm就会自动寻找main方法,然后进入到这个main //方法中去执行 //今天先记住语法 public static void main(String[] args)&#123;//2. 方法 //方法体,现阶段代码一定是放在方法体内部的. //jdk中提供了内置的对象[拥有一些功能],提供好了,开发者就可以直接使用 //java.lang.System类 - 向控制台输出一句话 System.out.println(&quot;HelloWorld&quot;);//3. 具体的程序 &#125;&#125; java源代码是不能够直接执行的.因为计算机是不识别java语言程序的. 需要对.java为后缀的源文件进行一个编译操作.如果一旦语法发生了问题,都会导致编译失败. 假设HelloWorld.java文件是放在D盘根目录下,需要打开终端,然后通过dos命令进入到D盘 12C:/User/admin&gt;d:D:/&gt;javac HelloWorld.java 效果,javac.exe工具其实就是在调用jdk中的编译器,作用:就是.java源文件编译成.class字节码文件 思考如何运行一个java程序呢? 利用java.exe 1D:/&gt;java HelloWorld 过程 编写.java源代码 javac.exe - 编译 java.exe - 执行 Java程序的执行的原理 12345678.java源文件 -&gt; 经过jdk中的编译器,成为.class字节码文件 -&gt; 经过jvm中的解释器[进行逐行翻译(解释)]-&gt; 机器能够识别的符号java属于解释型的语言,&quot;JVM把它YY成以.class字节码为指令的CPU&quot;编译型语言 - C语言,将这个语言编写的程序直接编译成计算机能够执行的程序.比如C语言写的代码可以直接编译成可执行文件 xx.exeC语言执行的性能高于java语言(每次执行都会经过jvm解释器进行解释) 集成开发环境 eclipse[日食] - 免费的,IBM公司的产品[收购SUN公司的] idea - 最好的,收费的 d:/aistar/j03s_student Java中的包-package 包是用来管理类的.包的本质就是一个文件夹.包对于类的作用相当于文件夹对于文件的作用. 包的命名规则 2-1. 推荐全部采用小写字母,如果出现多个单词,请你用.隔开,.隔开的每个部分都是一个目录 2-2. 包的命名推荐采用公司的域名倒置[唯一性] + 项目代号 ​ com.baidu.car tech.aistar 2-3. 不用采用java或者javax开头 - 因为jdk中的内置的类和拓展的类都是在java或者javax包中. 一旦创建了package,需要在类文件的首行采用package关键字来声明包. java中三种注释 单行注释 // ctrl+/ 添加/取消注释 多行注释 12345/* * * 多行注释的内容 - 注释的内容是不会经过jdk的编译器的 * */ 文档注释 可以生成文档树 123456/*** 放在类上面* 放在方法上**/ main方法细节12345678910public[公开的,公共的] static[静态的] - 都是属于后期学习OO中的修饰符修饰符在使用的时候,之间是没有顺序的.public static void main(String[] args)&#123;...&#125; //okstatic public void main(String[] args)&#123;...&#125; //ok//jdk8中方法的参数支持可变长参数public static void main(String... args)&#123;...&#125; //ok//args - 我们传给虚拟机的参数 输出语句 System.out.println(); // 换行 1System.out.print(&quot;\\n&quot;); \\n和\\r 1234567891011121314151617181920212223242526package tech.aistar.day01; /** * 本类用来演示: \\n \\r * * @author: success * @date: 2021/7/15 3:18 下午 */public class NrDemo &#123; public static void main(String[] args) &#123; //相当于是System.out.println(&quot;hello&quot;); System.out.print(&quot;hello\\n&quot;);//输出之后不换行 System.out.println(&quot;world&quot;); // \\n - 当输出完毕之后,光标停在下一行的起始位置 - 换行 // \\r - 当输出完毕之后,光标停在当前行的起始位置 回车 // \\n\\r 诞生的场景就是早期的打字机 //外面的终端执行的结果是 - veyy √ //伪终端显示的结果是 - ve System.out.println(&quot;Loyy\\rve&quot;); &#125;&#125; 特殊字符 \\ 是代表转义字符 \\n - 当输出完毕之后,光标停在下一行的起始位置 - 换行 \\r - 当输出完毕之后,光标停在当前行的起始位置 回车 \\b - 退格 \\t - 制表符,相当于tab键,默认是空4格 双引号 1\\&quot; 单引号 1\\&#x27; 单个\\ 1\\\\ 123456789101112131415161718192021222324252627282930package tech.aistar.day01;/** * 本类用来演示: 特殊字符 * * @author: success * @date: 2021/7/15 3:35 下午 */public class SignDemo &#123; public static void main(String[] args) &#123; //\\b - 退格 System.out.println(&quot;xxx\\byy&quot;);//xxyy //\\t - 制表符,相当于tab键,默认是空4格 System.out.println(&quot;hello\\tworld&quot;); //输出 james:&quot;success is good boy&quot; //双引号 System.out.println(&quot;james:\\&quot;success is good boy\\&quot;&quot;); // \\ 转义含义 //单个\\ System.out.println(&quot;D:\\\\temp\\\\news&quot;); //输出\\\\ System.out.println(&quot;\\\\\\\\&quot;); &#125;&#125; 变量 编程的核心就是从定义变量开始 java语言是一个强类型的语言[在编译期间必须要确定好数据的类型],javascript弱类型的语言 变量的本质 - “内存中某块区域的名称”,编程的任务就是对数据进行crud+数据分析的操作. 但是前提是数据需要先进行存储[内存,磁盘(文件,db数据库) - JVM内存 “JVM对字节码文件进行解释的前奏工作 - 把这个字节码文件加载到自己的内存中,java只能操作内存中的数据” java中是如何定义和存储简单的这些数据呢? 就是通过数据类型以及变量来定义和存储的. 数据类型 java中的数据类型有两大块 基本数据类型(8种) - 编程思想中将void归纳为第9种 数据类型决定了存储数据的这块空间的大小,并且这个大小一旦确定了,将不能够改变了. 对象类型(无数种) 2-1. 内置对象类型 - System,String - Jdk中提供的类 2-2. 自定义对象类型 - 自己定义的那些类HelloWorld,SignDemo 八种基本数据类型 名称 大小 范围 默认值 byte 字节 占1个字节8bit -128~127 0 short 短整型 占2个字节16bit -2^15~2^15-1 0 int 整型 占4个字节32bit -2^31~2^31-1 0 long 长整型 占8个字节64bit -2^63~2^63-1 0 float 单精度浮点数 占4个字节32bit +-(3.4*10^38) 0.0 double 双精度浮点数 占8个字节64bit +-(1.798*10^308) 0.0 char 字符 占2个字节16bit 0~65535 ‘\\u0000’空格 boolean 布尔类型 占1个字节8bit true/false false 变量的定义 变量的命名的规范请你参考类的命名规范,除了类的命名采用的”大驼峰”,而变量命名采用的是”小驼峰” “小驼峰” - 首字母小写,其余每个单词的首字母大写.比如studentAge 语法 1数据类型 变量名 [= 变量值]; 剖析变量的背后12345678910111213141516171819202122232425262728293031323334353637383940package tech.aistar.day01;/** * 本类用来演示: 变量入门 * * @author: success * @date: 2021/7/15 3:43 下午 */public class VarDemo &#123; public static void main(String[] args) &#123; //数据类型 变量名 [= 变量值]; byte b = 10; //代码的背后 - 埋了个&quot;种子&quot;,&quot;发芽&quot; //1. 数据肯定是存储在JVM内存中的 //2. 定义在方法内部的变量 - 局部变量[JVM的栈区] //3. 局部变量的生命周期是伴随着方法(main)的调用的开始和结束 //讲解的本质 //流程 //1. JVM加载VarDemo.class到内存 //2. JVM找到main方法想要去执行里面的程序 //3. 此处需要申请一块区域来保存数据10 // 3-1. 区域的大小由前面的数据类型来决定的 - int类型 - 区域4个字节32bit的大小 // 3-2. 栈里面的区域的大小一旦被确定了,就不能改变 - 肯定有的时候会有内存的浪费 // 3-3. 虽然空间浪费了,但是读取的效率会提高 - 典型的&quot;以空间换时间&quot; //4. 只要是内存中的空间,这个空间必然会有一个地址,所以变量的存在是为了给这个区域取了个名字 // 变量是为了方便用户来通过它访问到这个空间中存储的具体的那个值的 //把整数10赋值给一个int类型的变量a int a = 10; System.out.println(a); // == 比较的就是&quot;坑 - 区域&quot;里面存储的数据 System.out.println(b == a);//true &#125;&#125; 数据类型的转换 常识规定 a. java中看到一个整数,默认就是int类型 b. java中看到一个小数,默认就是double类型 c. 大的数据类型和小的数据类型进行计算的时候,计算得到的结果是偏向类型大的一方. 自动转换 小的数据类型可以自动转换成大的数据类型. byte-&gt;short-&gt;int-&gt;long char-&gt;int int-&gt;double 强制类型转换 大的数据类型转换成小的数据类型的时候,需要进行强制类型转换的操作 123MaxType 变量1 = 值1; MinType 变量2 = (MinType)变量1;","categories":[{"name":"java基础语法","slug":"java基础语法","permalink":"http://example.com/categories/java%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/"}],"tags":[{"name":"java","slug":"java","permalink":"http://example.com/tags/java/"}]}],"categories":[{"name":"面试+工作","slug":"面试-工作","permalink":"http://example.com/categories/%E9%9D%A2%E8%AF%95-%E5%B7%A5%E4%BD%9C/"},{"name":"IOC和DI(依赖注入)","slug":"IOC和DI-依赖注入","permalink":"http://example.com/categories/IOC%E5%92%8CDI-%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5/"},{"name":"数据库","slug":"数据库","permalink":"http://example.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"设计模式","slug":"设计模式","permalink":"http://example.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"大题小做","slug":"大题小做","permalink":"http://example.com/categories/%E5%A4%A7%E9%A2%98%E5%B0%8F%E5%81%9A/"},{"name":"多线程","slug":"多线程","permalink":"http://example.com/categories/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"},{"name":"枚举类型","slug":"枚举类型","permalink":"http://example.com/categories/%E6%9E%9A%E4%B8%BE%E7%B1%BB%E5%9E%8B/"},{"name":"泛型","slug":"泛型","permalink":"http://example.com/categories/%E6%B3%9B%E5%9E%8B/"},{"name":"IO流","slug":"IO流","permalink":"http://example.com/categories/IO%E6%B5%81/"},{"name":"异常处理","slug":"异常处理","permalink":"http://example.com/categories/%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/"},{"name":"java基础语法","slug":"java基础语法","permalink":"http://example.com/categories/java%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/"},{"name":"抽象的数据类型","slug":"抽象的数据类型","permalink":"http://example.com/categories/%E6%8A%BD%E8%B1%A1%E7%9A%84%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"},{"name":"日期日历","slug":"日期日历","permalink":"http://example.com/categories/%E6%97%A5%E6%9C%9F%E6%97%A5%E5%8E%86/"},{"name":"Interview","slug":"Interview","permalink":"http://example.com/categories/Interview/"},{"name":"集合框架","slug":"集合框架","permalink":"http://example.com/categories/%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/"},{"name":"字符串","slug":"字符串","permalink":"http://example.com/categories/%E5%AD%97%E7%AC%A6%E4%B8%B2/"}],"tags":[{"name":"最终冲刺","slug":"最终冲刺","permalink":"http://example.com/tags/%E6%9C%80%E7%BB%88%E5%86%B2%E5%88%BA/"},{"name":"Spring","slug":"Spring","permalink":"http://example.com/tags/Spring/"},{"name":"mysql","slug":"mysql","permalink":"http://example.com/tags/mysql/"},{"name":"java","slug":"java","permalink":"http://example.com/tags/java/"},{"name":"题目","slug":"题目","permalink":"http://example.com/tags/%E9%A2%98%E7%9B%AE/"},{"name":"Interview","slug":"Interview","permalink":"http://example.com/tags/Interview/"}]}